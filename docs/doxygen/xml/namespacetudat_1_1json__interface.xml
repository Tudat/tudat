<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.9.1" xml:lang="en-US">
  <compounddef id="namespacetudat_1_1json__interface" kind="namespace" language="C++">
    <compoundname>tudat::json_interface</compoundname>
    <innerclass refid="classtudat_1_1json__interface_1_1SpiceSettings" prot="public">tudat::json_interface::SpiceSettings</innerclass>
    <innerclass refid="classtudat_1_1json__interface_1_1JsonEstimationManager" prot="public">tudat::json_interface::JsonEstimationManager</innerclass>
    <innerclass refid="classtudat_1_1json__interface_1_1JsonSimulationManager" prot="public">tudat::json_interface::JsonSimulationManager</innerclass>
    <innerclass refid="classtudat_1_1json__interface_1_1JsonVariationalEquationsSimulationManager" prot="public">tudat::json_interface::JsonVariationalEquationsSimulationManager</innerclass>
    <innerclass refid="classtudat_1_1json__interface_1_1ExportSettings" prot="public">tudat::json_interface::ExportSettings</innerclass>
    <innerclass refid="classtudat_1_1json__interface_1_1ValueAccessError" prot="public">tudat::json_interface::ValueAccessError</innerclass>
    <innerclass refid="classtudat_1_1json__interface_1_1UnrecognizedValueAccessError" prot="public">tudat::json_interface::UnrecognizedValueAccessError</innerclass>
    <innerclass refid="classtudat_1_1json__interface_1_1UndefinedKeyError" prot="public">tudat::json_interface::UndefinedKeyError</innerclass>
    <innerclass refid="classtudat_1_1json__interface_1_1IllegalValueError" prot="public">tudat::json_interface::IllegalValueError</innerclass>
    <innerclass refid="classtudat_1_1json__interface_1_1ReportableBugError" prot="public">tudat::json_interface::ReportableBugError</innerclass>
    <innerclass refid="classtudat_1_1json__interface_1_1AutoReportableBugError" prot="public">tudat::json_interface::AutoReportableBugError</innerclass>
    <innerclass refid="classtudat_1_1json__interface_1_1nullptrPointerError" prot="public">tudat::json_interface::nullptrPointerError</innerclass>
    <innerclass refid="classtudat_1_1json__interface_1_1UnknownEnumError" prot="public">tudat::json_interface::UnknownEnumError</innerclass>
    <innerclass refid="classtudat_1_1json__interface_1_1UnsupportedEnumError" prot="public">tudat::json_interface::UnsupportedEnumError</innerclass>
    <innerclass refid="classtudat_1_1json__interface_1_1UnimplementedEnumError" prot="public">tudat::json_interface::UnimplementedEnumError</innerclass>
    <innerclass refid="structtudat_1_1json__interface_1_1SpecialKeys" prot="public">tudat::json_interface::SpecialKeys</innerclass>
    <innerclass refid="structtudat_1_1json__interface_1_1Keys" prot="public">tudat::json_interface::Keys</innerclass>
    <innerclass refid="classtudat_1_1json__interface_1_1KeyPath" prot="public">tudat::json_interface::KeyPath</innerclass>
    <innerclass refid="classtudat_1_1json__interface_1_1ApplicationOptions" prot="public">tudat::json_interface::ApplicationOptions</innerclass>
      <sectiondef kind="enum">
      <memberdef kind="enum" id="jsonInterface_8h_1af6504a0ad6207090ab5705bc6bbfd240" prot="public" static="no" strong="no">
        <type></type>
        <name>JsonSimulationTypes</name>
        <enumvalue id="jsonInterface_8h_1af6504a0ad6207090ab5705bc6bbfd240a6708315bc2bd38fb359b37ba0bdd0eba" prot="public">
          <name>equations_of_motion_propagation</name>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="jsonInterface_8h_1af6504a0ad6207090ab5705bc6bbfd240a203c2be8eae062e76e998275ab4b6f1c" prot="public">
          <name>variational_equations_propagation</name>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="jsonInterface_8h_1af6504a0ad6207090ab5705bc6bbfd240a14e423898e1b3965c23b06650ac5f1a0" prot="public">
          <name>state_estimation</name>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/Users/jonashener/tudatpy_dev/tudat-bundle/tudat/include/tudat/interface/json/jsonInterface.h" line="33" column="1" bodyfile="/Users/jonashener/tudatpy_dev/tudat-bundle/tudat/include/tudat/interface/json/jsonInterface.h" bodystart="34" bodyend="38"/>
      </memberdef>
      <memberdef kind="enum" id="state_8h_1a5c1a96a1a5b825c908457175fadc17ff" prot="public" static="no" strong="no">
        <type></type>
        <name>StateType</name>
        <enumvalue id="state_8h_1a5c1a96a1a5b825c908457175fadc17ffab49e2f29de03f78a184726714f9badda" prot="public">
          <name>cartesianElements</name>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="state_8h_1a5c1a96a1a5b825c908457175fadc17ffaeff71f08566ba16289987068c36b6ac2" prot="public">
          <name>keplerianElements</name>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="state_8h_1a5c1a96a1a5b825c908457175fadc17ffabc1120bb634816b3bfc42f324a967957" prot="public">
          <name>sphericalElements</name>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <briefdescription>
<para>Possible ways of providing initial translational states. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/Users/jonashener/tudatpy_dev/tudat-bundle/tudat/include/tudat/interface/json/propagation/state.h" line="30" column="1" bodyfile="/Users/jonashener/tudatpy_dev/tudat-bundle/tudat/include/tudat/interface/json/propagation/state.h" bodystart="31" bodyend="35"/>
      </memberdef>
      <memberdef kind="enum" id="errorHandling_8h_1acbdff2a6b5648e1dee30630bcad0b6cb" prot="public" static="no" strong="no">
        <type></type>
        <name>ExceptionResponseType</name>
        <enumvalue id="errorHandling_8h_1acbdff2a6b5648e1dee30630bcad0b6cba2a50a7b63d5c9a47131014a0475c5272" prot="public">
          <name>continueSilently</name>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="errorHandling_8h_1acbdff2a6b5648e1dee30630bcad0b6cba97b9251a7363c0438e905ef81326947d" prot="public">
          <name>printWarning</name>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="errorHandling_8h_1acbdff2a6b5648e1dee30630bcad0b6cbacc0c9da5fcb7bfb0bff3a5f8265d4daa" prot="public">
          <name>throwError</name>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <briefdescription>
<para>Possible responses to an exception during validation phase in Tudat apps that use json_interface. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/Users/jonashener/tudatpy_dev/tudat-bundle/tudat/include/tudat/interface/json/support/errorHandling.h" line="32" column="1" bodyfile="/Users/jonashener/tudatpy_dev/tudat-bundle/tudat/include/tudat/interface/json/support/errorHandling.h" bodystart="33" bodyend="37"/>
      </memberdef>
      </sectiondef>
      <sectiondef kind="typedef">
      <memberdef kind="typedef" id="valueAccess_8h_1a05790a8600f275aa6ba09da643582a1f" prot="public" static="no">
        <templateparamlist>
          <param>
            <type>typename T</type>
          </param>
        </templateparamlist>
        <type>std::unordered_map&lt; std::string, std::vector&lt; std::shared_ptr&lt; T &gt; &gt; &gt;</type>
        <definition>using tudat::json_interface::SingleBodyMap = typedef std::unordered_map&lt; std::string, std::vector&lt; std::shared_ptr&lt; T &gt; &gt; &gt;</definition>
        <argsstring></argsstring>
        <name>SingleBodyMap</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/Users/jonashener/tudatpy_dev/tudat-bundle/tudat/include/tudat/interface/json/support/valueAccess.h" line="478" column="1" bodyfile="/Users/jonashener/tudatpy_dev/tudat-bundle/tudat/include/tudat/interface/json/support/valueAccess.h" bodystart="478" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="valueAccess_8h_1a4f5378f74e491d2e2efb888c557c4355" prot="public" static="no">
        <templateparamlist>
          <param>
            <type>typename T</type>
          </param>
        </templateparamlist>
        <type>std::unordered_map&lt; std::string, SingleBodyMap&lt; T &gt; &gt;</type>
        <definition>using tudat::json_interface::BodyToBodyMap = typedef std::unordered_map&lt; std::string, SingleBodyMap&lt; T &gt; &gt;</definition>
        <argsstring></argsstring>
        <name>BodyToBodyMap</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/Users/jonashener/tudatpy_dev/tudat-bundle/tudat/include/tudat/interface/json/support/valueAccess.h" line="481" column="1" bodyfile="/Users/jonashener/tudatpy_dev/tudat-bundle/tudat/include/tudat/interface/json/support/valueAccess.h" bodystart="481" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="valueAccess_8h_1adce9496f99b25b4eb9b73aecaeed3f5f" prot="public" static="no">
        <templateparamlist>
          <param>
            <type>typename T</type>
          </param>
        </templateparamlist>
        <type>std::unordered_map&lt; std::string, std::vector&lt; T &gt; &gt;</type>
        <definition>using tudat::json_interface::NoPointerSingleBodyMap = typedef std::unordered_map&lt; std::string, std::vector&lt; T &gt; &gt;</definition>
        <argsstring></argsstring>
        <name>NoPointerSingleBodyMap</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/Users/jonashener/tudatpy_dev/tudat-bundle/tudat/include/tudat/interface/json/support/valueAccess.h" line="484" column="1" bodyfile="/Users/jonashener/tudatpy_dev/tudat-bundle/tudat/include/tudat/interface/json/support/valueAccess.h" bodystart="484" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="valueAccess_8h_1a0a6500f35e771de7e5e4e2a3c6c102b6" prot="public" static="no">
        <templateparamlist>
          <param>
            <type>typename T</type>
          </param>
        </templateparamlist>
        <type>std::unordered_map&lt; std::string, NoPointerSingleBodyMap&lt; T &gt; &gt;</type>
        <definition>using tudat::json_interface::NoPointerBodyToBodyMap = typedef std::unordered_map&lt; std::string, NoPointerSingleBodyMap&lt; T &gt; &gt;</definition>
        <argsstring></argsstring>
        <name>NoPointerBodyToBodyMap</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/Users/jonashener/tudatpy_dev/tudat-bundle/tudat/include/tudat/interface/json/support/valueAccess.h" line="487" column="1" bodyfile="/Users/jonashener/tudatpy_dev/tudat-bundle/tudat/include/tudat/interface/json/support/valueAccess.h" bodystart="487" bodyend="-1"/>
      </memberdef>
      </sectiondef>
      <sectiondef kind="var">
      <memberdef kind="variable" id="jsonInterface_8h_1abad141f8e58e8d64b6104d0715775801" prot="public" static="yes" mutable="no">
        <type>std::map&lt; JsonSimulationTypes, std::string &gt;</type>
        <definition>std::map&lt; JsonSimulationTypes, std::string &gt; tudat::json_interface::simulationTypes</definition>
        <argsstring></argsstring>
        <name>simulationTypes</name>
        <initializer>=
{
    { equations_of_motion_propagation, &quot;EoM&quot; },
    { variational_equations_propagation, &quot;Variational&quot; },
    { state_estimation, &quot;Estimation&quot; }
}</initializer>
        <briefdescription>
<para>Map of <computeroutput>ObservableType</computeroutput> string representations. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/Users/jonashener/tudatpy_dev/tudat-bundle/tudat/include/tudat/interface/json/jsonInterface.h" line="42" column="17" bodyfile="/Users/jonashener/tudatpy_dev/tudat-bundle/tudat/include/tudat/interface/json/jsonInterface.h" bodystart="42" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="jsonInterface_8h_1a8091d90737c17894e6429bdcfb7a05b6" prot="public" static="yes" mutable="no">
        <type>std::map&lt; std::string, JsonSimulationTypes &gt;</type>
        <definition>std::map&lt; std::string, JsonSimulationTypes &gt; tudat::json_interface::simulationTypesInverse</definition>
        <argsstring></argsstring>
        <name>simulationTypesInverse</name>
        <initializer>=
{
    { &quot;EoM&quot;, equations_of_motion_propagation },
    { &quot;Variational&quot;, variational_equations_propagation },
    { &quot;Estimation&quot;, state_estimation }

}</initializer>
        <briefdescription>
<para>Map of <computeroutput>ObservableType</computeroutput> string representations. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/Users/jonashener/tudatpy_dev/tudat-bundle/tudat/include/tudat/interface/json/jsonInterface.h" line="50" column="17" bodyfile="/Users/jonashener/tudatpy_dev/tudat-bundle/tudat/include/tudat/interface/json/jsonInterface.h" bodystart="50" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="state_8h_1a9194ac6c7cffaee65c5602cdc65862e2" prot="public" static="yes" mutable="no">
        <type>std::map&lt; StateType, std::string &gt;</type>
        <definition>std::map&lt; StateType, std::string &gt; tudat::json_interface::stateTypes</definition>
        <argsstring></argsstring>
        <name>stateTypes</name>
        <initializer>=
{
    { cartesianElements, &quot;cartesian&quot; },
    { keplerianElements, &quot;keplerian&quot; },
    { sphericalElements, &quot;spherical&quot; }
}</initializer>
        <briefdescription>
<para>Map of <computeroutput>StateType</computeroutput> string representations. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/Users/jonashener/tudatpy_dev/tudat-bundle/tudat/include/tudat/interface/json/propagation/state.h" line="38" column="17" bodyfile="/Users/jonashener/tudatpy_dev/tudat-bundle/tudat/include/tudat/interface/json/propagation/state.h" bodystart="38" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="state_8h_1ae5c8c85b382b9b5e244e021fad7902a2" prot="public" static="yes" mutable="no">
        <type>std::vector&lt; StateType &gt;</type>
        <definition>std::vector&lt; StateType &gt; tudat::json_interface::unsupportedStateTypes</definition>
        <argsstring></argsstring>
        <name>unsupportedStateTypes</name>
        <initializer>= { }</initializer>
        <briefdescription>
<para><computeroutput>StateType</computeroutput> not supported by <computeroutput>json_interface</computeroutput>. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/Users/jonashener/tudatpy_dev/tudat-bundle/tudat/include/tudat/interface/json/propagation/state.h" line="46" column="20" bodyfile="/Users/jonashener/tudatpy_dev/tudat-bundle/tudat/include/tudat/interface/json/propagation/state.h" bodystart="46" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="options_8h_1ab98a49d7608e2d1e7d79ba47db725423" prot="public" static="yes" mutable="no">
        <type>std::map&lt; ExceptionResponseType, std::string &gt;</type>
        <definition>std::map&lt; ExceptionResponseType, std::string &gt; tudat::json_interface::exceptionResponseTypes</definition>
        <argsstring></argsstring>
        <name>exceptionResponseTypes</name>
        <initializer>=
{
    { continueSilently, &quot;continueSilently&quot; },
    { printWarning, &quot;printWarning&quot; },
    { throwError, &quot;throwError&quot; }
}</initializer>
        <briefdescription>
<para>Map of <computeroutput>ExceptionResponseType</computeroutput> string representations. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/Users/jonashener/tudatpy_dev/tudat-bundle/tudat/include/tudat/interface/json/support/options.h" line="26" column="17" bodyfile="/Users/jonashener/tudatpy_dev/tudat-bundle/tudat/include/tudat/interface/json/support/options.h" bodystart="26" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="path_8h_1a77c819a165767e4ee7fcf0b96cc274df" prot="public" static="yes" mutable="no">
        <type>std::vector&lt; std::pair&lt; std::string, std::string &gt; &gt;</type>
        <definition>std::vector&lt; std::pair&lt; std::string, std::string &gt; &gt; tudat::json_interface::pathPlaceholders</definition>
        <argsstring></argsstring>
        <name>pathPlaceholders</name>
        <initializer>=
{
    std::make_pair( &quot;ATMOSPHERE_TABLES_PATH&quot;, paths::getAtmosphereTablesPath( ) + &quot;/&quot; ),
    std::make_pair( &quot;SPICE_KERNELS_PATH&quot;, paths::getSpiceKernelPath( ) + &quot;/&quot; ),
    std::make_pair( &quot;GRAVITY_MODELS_PATH&quot;, paths::getGravityModelsPath( ) + &quot;/&quot; )
}</initializer>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Names for replacable paths in JSON files. E.g., the text &quot;${TUDAT_ROOT_PATH}&quot; will be replaced with the actual path when reading JSON files. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/Users/jonashener/tudatpy_dev/tudat-bundle/tudat/include/tudat/interface/json/support/path.h" line="27" column="20" bodyfile="/Users/jonashener/tudatpy_dev/tudat-bundle/tudat/include/tudat/interface/json/support/path.h" bodystart="27" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="valueAccess_8h_1a9d7bb35387f6a44ca9fd21551ec537ea" prot="public" static="no" mutable="no">
        <type>std::set&lt; <ref refid="classtudat_1_1json__interface_1_1KeyPath" kindref="compound">KeyPath</ref> &gt;</type>
        <definition>std::set&lt; KeyPath &gt; tudat::json_interface::accessedKeyPaths</definition>
        <argsstring></argsstring>
        <name>accessedKeyPaths</name>
        <initializer>= { }</initializer>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Global variable containing all the key paths that were accessed since clearAccessHistory() was called for the last time (or since this variable was initialized). </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/Users/jonashener/tudatpy_dev/tudat-bundle/tudat/src/interface/json/support/valueAccess.cpp" line="129" column="10" bodyfile="/Users/jonashener/tudatpy_dev/tudat-bundle/tudat/src/interface/json/support/valueAccess.cpp" bodystart="129" bodyend="-1" declfile="/Users/jonashener/tudatpy_dev/tudat-bundle/tudat/include/tudat/interface/json/support/valueAccess.h" declline="119" declcolumn="17"/>
      </memberdef>
      </sectiondef>
      <sectiondef kind="func">
      <memberdef kind="function" id="interface_2json_2environment_2body_8h_1a1243e942271dc5aaf3c31b4fe29a5a3d" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>std::shared_ptr&lt; <ref refid="structtudat_1_1simulation__setup_1_1BodySettings" kindref="compound">simulation_setup::BodySettings</ref> &gt;</type>
        <definition>std::shared_ptr&lt; simulation_setup::BodySettings &gt; tudat::json_interface::createBodySettings</definition>
        <argsstring>(const nlohmann::json &amp;jsonObject)</argsstring>
        <name>createBodySettings</name>
        <param>
          <type>const nlohmann::json &amp;</type>
          <declname>jsonObject</declname>
        </param>
        <briefdescription>
<para>Create a <ref refid="structtudat_1_1simulation__setup_1_1BodySettings" kindref="compound">simulation_setup::BodySettings</ref> object with the settings from <computeroutput>jsonObject</computeroutput>. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>jsonObject</parametername>
</parameternamelist>
<parameterdescription>
<para>The <computeroutput>json</computeroutput> object containing the settings for one body. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Body settings object. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/Users/jonashener/tudatpy_dev/tudat-bundle/tudat/src/interface/json/environment/body.cpp" line="59" column="17" bodyfile="/Users/jonashener/tudatpy_dev/tudat-bundle/tudat/src/interface/json/environment/body.cpp" bodystart="59" bodyend="65" declfile="/Users/jonashener/tudatpy_dev/tudat-bundle/tudat/include/tudat/interface/json/environment/body.h" declline="42" declcolumn="17"/>
      </memberdef>
      <memberdef kind="function" id="interface_2json_2environment_2body_8h_1abc6df904e9e19d938dd953d30594b708" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void tudat::json_interface::updateBodySettings</definition>
        <argsstring>(std::shared_ptr&lt; simulation_setup::BodySettings &gt; &amp;bodySettings, const nlohmann::json &amp;jsonObject)</argsstring>
        <name>updateBodySettings</name>
        <param>
          <type>std::shared_ptr&lt; <ref refid="structtudat_1_1simulation__setup_1_1BodySettings" kindref="compound">simulation_setup::BodySettings</ref> &gt; &amp;</type>
          <declname>bodySettings</declname>
        </param>
        <param>
          <type>const nlohmann::json &amp;</type>
          <declname>jsonObject</declname>
        </param>
        <briefdescription>
<para>Update <computeroutput>bodySettings</computeroutput> with the settings from <computeroutput>jsonObject</computeroutput>. </para>
        </briefdescription>
        <detaileddescription>
<para>Does not change the values already defined in <computeroutput>bodySettings</computeroutput> that are not specified in <computeroutput>jsonObject</computeroutput>. <parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>bodySettings</parametername>
</parameternamelist>
<parameterdescription>
<para>Body settings object to be updated. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>jsonObject</parametername>
</parameternamelist>
<parameterdescription>
<para>The <computeroutput>json</computeroutput> object containing only the settings for one body. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/Users/jonashener/tudatpy_dev/tudat-bundle/tudat/src/interface/json/environment/body.cpp" line="68" column="6" bodyfile="/Users/jonashener/tudatpy_dev/tudat-bundle/tudat/src/interface/json/environment/body.cpp" bodystart="68" bodyend="83" declfile="/Users/jonashener/tudatpy_dev/tudat-bundle/tudat/include/tudat/interface/json/environment/body.h" declline="51" declcolumn="6"/>
      </memberdef>
      <memberdef kind="function" id="interface_2json_2environment_2body_8h_1ac7ca8f4c19731f33398fde9130fb12ec" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename TimeType</type>
            <defval>double</defval>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void tudat::json_interface::updateBodiesFromJSON</definition>
        <argsstring>(const nlohmann::json &amp;jsonObject, simulation_setup::SystemOfBodies &amp;bodies, simulation_setup::BodyListSettings &amp;bodySettingsMap, const std::string globalFrameOrigin, const std::string globalFrameOrientation, const std::shared_ptr&lt; SpiceSettings &gt; &amp;spiceSettings, const std::shared_ptr&lt; numerical_integrators::IntegratorSettings&lt; TimeType &gt; &gt; &amp;integratorSettings=nullptr)</argsstring>
        <name>updateBodiesFromJSON</name>
        <param>
          <type>const nlohmann::json &amp;</type>
          <declname>jsonObject</declname>
        </param>
        <param>
          <type><ref refid="classtudat_1_1simulation__setup_1_1SystemOfBodies" kindref="compound">simulation_setup::SystemOfBodies</ref> &amp;</type>
          <declname>bodies</declname>
        </param>
        <param>
          <type><ref refid="classtudat_1_1simulation__setup_1_1BodyListSettings" kindref="compound">simulation_setup::BodyListSettings</ref> &amp;</type>
          <declname>bodySettingsMap</declname>
        </param>
        <param>
          <type>const std::string</type>
          <declname>globalFrameOrigin</declname>
        </param>
        <param>
          <type>const std::string</type>
          <declname>globalFrameOrientation</declname>
        </param>
        <param>
          <type>const std::shared_ptr&lt; <ref refid="classtudat_1_1json__interface_1_1SpiceSettings" kindref="compound">SpiceSettings</ref> &gt; &amp;</type>
          <declname>spiceSettings</declname>
        </param>
        <param>
          <type>const std::shared_ptr&lt; <ref refid="classtudat_1_1numerical__integrators_1_1IntegratorSettings" kindref="compound">numerical_integrators::IntegratorSettings</ref>&lt; TimeType &gt; &gt; &amp;</type>
          <declname>integratorSettings</declname>
          <defval>nullptr</defval>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Update <computeroutput>bodies</computeroutput> and <computeroutput>bodySettingsMap</computeroutput> from <computeroutput>jsonObject</computeroutput> (using <computeroutput>spiceSettings</computeroutput> for default settings and initial time from <computeroutput>integratorSettings</computeroutput>).</para>
<para>Update <computeroutput>bodies</computeroutput> and <computeroutput>bodySettingsMap</computeroutput> from <computeroutput>jsonObject</computeroutput> (using <computeroutput>spiceSettings</computeroutput> for default settings and initial time from <computeroutput>integratorSettings</computeroutput>). <parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>jsonObject</parametername>
</parameternamelist>
<parameterdescription>
<para>The root <computeroutput>json</computeroutput> object containing all the relevant fields (&quot;bodies&quot; mandatory, &quot;finalEpoch&quot; mandatory if Spice kernels should be preloaded, &quot;globalFrameOrigin&quot; and &quot;globalFrameOrientation&quot; optional). </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>bodies</parametername>
</parameternamelist>
<parameterdescription>
<para>The named system of bodies to be updated (returned by reference). </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>bodySettingsMap</parametername>
</parameternamelist>
<parameterdescription>
<para>The map of body settings created from <computeroutput>jsonObject</computeroutput> and used to create <computeroutput>bodies</computeroutput> (returned by reference). </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>globalFrameOrigin</parametername>
</parameternamelist>
<parameterdescription>
<para>Name of the global frame origin. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>globalFrameOrientation</parametername>
</parameternamelist>
<parameterdescription>
<para>Name of the global frame orientation. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>spiceSettings</parametername>
</parameternamelist>
<parameterdescription>
<para>The settings for Spice (nullptr if Spice not used). </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>integratorSettings</parametername>
</parameternamelist>
<parameterdescription>
<para>The settings for the integrator (nullptr if Spice not used). </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="exception"><parameteritem>
<parameternamelist>
<parametername>std::runtime_error</parametername>
</parameternamelist>
<parameterdescription>
<para>If any body is configured to be created using default settings and either <computeroutput>spiceSettings</computeroutput> is <computeroutput>nullptr</computeroutput> or <computeroutput>integratorSettings</computeroutput> is <computeroutput>nullptr</computeroutput> and Spice is configured to preload kernels. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/Users/jonashener/tudatpy_dev/tudat-bundle/tudat/include/tudat/interface/json/environment/body.h" line="71" column="6" bodyfile="/Users/jonashener/tudatpy_dev/tudat-bundle/tudat/include/tudat/interface/json/environment/body.h" bodystart="71" bodyend="167"/>
      </memberdef>
      <memberdef kind="function" id="json_2environment_2spice_8h_1a252c843812b43090e7f975c21f80c4cf" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void tudat::json_interface::to_json</definition>
        <argsstring>(nlohmann::json &amp;jsonObject, const std::shared_ptr&lt; SpiceSettings &gt; &amp;spiceSettings)</argsstring>
        <name>to_json</name>
        <param>
          <type>nlohmann::json &amp;</type>
          <declname>jsonObject</declname>
        </param>
        <param>
          <type>const std::shared_ptr&lt; <ref refid="classtudat_1_1json__interface_1_1SpiceSettings" kindref="compound">SpiceSettings</ref> &gt; &amp;</type>
          <declname>spiceSettings</declname>
        </param>
        <briefdescription>
<para>Create a <computeroutput>json</computeroutput> object from a shared pointer to a <computeroutput><ref refid="classtudat_1_1json__interface_1_1SpiceSettings" kindref="compound">SpiceSettings</ref></computeroutput> object. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/Users/jonashener/tudatpy_dev/tudat-bundle/tudat/src/interface/json/environment/spice.cpp" line="21" column="6" bodyfile="/Users/jonashener/tudatpy_dev/tudat-bundle/tudat/src/interface/json/environment/spice.cpp" bodystart="21" bodyend="46" declfile="/Users/jonashener/tudatpy_dev/tudat-bundle/tudat/include/tudat/interface/json/environment/spice.h" declline="120" declcolumn="6"/>
      </memberdef>
      <memberdef kind="function" id="json_2environment_2spice_8h_1a92092412eb5fc8bb8bcc6b77416f1d27" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void tudat::json_interface::from_json</definition>
        <argsstring>(const nlohmann::json &amp;jsonObject, std::shared_ptr&lt; SpiceSettings &gt; &amp;spiceSettings)</argsstring>
        <name>from_json</name>
        <param>
          <type>const nlohmann::json &amp;</type>
          <declname>jsonObject</declname>
        </param>
        <param>
          <type>std::shared_ptr&lt; <ref refid="classtudat_1_1json__interface_1_1SpiceSettings" kindref="compound">SpiceSettings</ref> &gt; &amp;</type>
          <declname>spiceSettings</declname>
        </param>
        <briefdescription>
<para>Create a shared pointer to a <computeroutput><ref refid="classtudat_1_1json__interface_1_1SpiceSettings" kindref="compound">SpiceSettings</ref></computeroutput> object from a <computeroutput>json</computeroutput> object. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/Users/jonashener/tudatpy_dev/tudat-bundle/tudat/src/interface/json/environment/spice.cpp" line="49" column="6" bodyfile="/Users/jonashener/tudatpy_dev/tudat-bundle/tudat/src/interface/json/environment/spice.cpp" bodystart="49" bodyend="73" declfile="/Users/jonashener/tudatpy_dev/tudat-bundle/tudat/include/tudat/interface/json/environment/spice.h" declline="123" declcolumn="6"/>
      </memberdef>
      <memberdef kind="function" id="json_2environment_2spice_8h_1a7ee8dbec21bb536d67ca6ed9139ea298" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void tudat::json_interface::loadSpiceKernels</definition>
        <argsstring>(const std::shared_ptr&lt; SpiceSettings &gt; &amp;spiceSettings)</argsstring>
        <name>loadSpiceKernels</name>
        <param>
          <type>const std::shared_ptr&lt; <ref refid="classtudat_1_1json__interface_1_1SpiceSettings" kindref="compound">SpiceSettings</ref> &gt; &amp;</type>
          <declname>spiceSettings</declname>
        </param>
        <briefdescription>
<para>Load in Tudat the Spice kernels specified in <computeroutput>spiceSettings</computeroutput>. </para>
        </briefdescription>
        <detaileddescription>
<para><simplesect kind="remark"><para>Clears any Spice kernel loaded previously. </para>
</simplesect>
<simplesect kind="remark"><para>If <computeroutput>spiceSettings</computeroutput> is <computeroutput>nullptr</computeroutput>, no kernels are loaded. </para>
</simplesect>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>spiceSettings</parametername>
</parameternamelist>
<parameterdescription>
<para>The Spice settings containing the paths to the kernels to be loaded. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/Users/jonashener/tudatpy_dev/tudat-bundle/tudat/src/interface/json/environment/spice.cpp" line="77" column="6" bodyfile="/Users/jonashener/tudatpy_dev/tudat-bundle/tudat/src/interface/json/environment/spice.cpp" bodystart="77" bodyend="102" declfile="/Users/jonashener/tudatpy_dev/tudat-bundle/tudat/include/tudat/interface/json/environment/spice.h" declline="133" declcolumn="6"/>
      </memberdef>
      <memberdef kind="function" id="jsonInterface_8h_1a05a0d61ca8332fb5133ebf2bc6349d28" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>void</type>
        <definition>void tudat::json_interface::to_json</definition>
        <argsstring>(nlohmann::json &amp;jsonObject, const JsonSimulationTypes &amp;simulationType)</argsstring>
        <name>to_json</name>
        <param>
          <type>nlohmann::json &amp;</type>
          <declname>jsonObject</declname>
        </param>
        <param>
          <type>const JsonSimulationTypes &amp;</type>
          <declname>simulationType</declname>
        </param>
        <briefdescription>
<para>Convert <computeroutput>ObservableType</computeroutput> to <computeroutput>json</computeroutput>. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/Users/jonashener/tudatpy_dev/tudat-bundle/tudat/include/tudat/interface/json/jsonInterface.h" line="59" column="13" bodyfile="/Users/jonashener/tudatpy_dev/tudat-bundle/tudat/include/tudat/interface/json/jsonInterface.h" bodystart="59" bodyend="62"/>
      </memberdef>
      <memberdef kind="function" id="jsonInterface_8h_1a6684bf09477f319c76f3def402f1c006" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>void</type>
        <definition>void tudat::json_interface::from_json</definition>
        <argsstring>(const nlohmann::json &amp;jsonObject, JsonSimulationTypes &amp;simulationType)</argsstring>
        <name>from_json</name>
        <param>
          <type>const nlohmann::json &amp;</type>
          <declname>jsonObject</declname>
        </param>
        <param>
          <type>JsonSimulationTypes &amp;</type>
          <declname>simulationType</declname>
        </param>
        <briefdescription>
<para>Convert <computeroutput>json</computeroutput> to <computeroutput>ObservableType</computeroutput>. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/Users/jonashener/tudatpy_dev/tudat-bundle/tudat/include/tudat/interface/json/jsonInterface.h" line="65" column="13" bodyfile="/Users/jonashener/tudatpy_dev/tudat-bundle/tudat/include/tudat/interface/json/jsonInterface.h" bodystart="65" bodyend="68"/>
      </memberdef>
      <memberdef kind="function" id="jsonInterface_8h_1a028b57d891cac4ad11595138570b778f" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename TimeType</type>
          </param>
          <param>
            <type>typename StateScalarType</type>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void tudat::json_interface::to_json</definition>
        <argsstring>(nlohmann::json &amp;jsonObject, const std::shared_ptr&lt; JsonSimulationManager&lt; TimeType, StateScalarType &gt; &gt; &amp;jsonSimulationManager)</argsstring>
        <name>to_json</name>
        <param>
          <type>nlohmann::json &amp;</type>
          <declname>jsonObject</declname>
        </param>
        <param>
          <type>const std::shared_ptr&lt; <ref refid="classtudat_1_1json__interface_1_1JsonSimulationManager" kindref="compound">JsonSimulationManager</ref>&lt; TimeType, StateScalarType &gt; &gt; &amp;</type>
          <declname>jsonSimulationManager</declname>
        </param>
        <briefdescription>
<para>Function to create a <computeroutput>json</computeroutput> object from a Simulation object. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/Users/jonashener/tudatpy_dev/tudat-bundle/tudat/include/tudat/interface/json/jsonInterface.h" line="664" column="6" bodyfile="/Users/jonashener/tudatpy_dev/tudat-bundle/tudat/include/tudat/interface/json/jsonInterface.h" bodystart="664" bodyend="692"/>
      </memberdef>
      <memberdef kind="function" id="export_8h_1aa3f7e6a82060a6457ffd1ba221b1aa28" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void tudat::json_interface::to_json</definition>
        <argsstring>(nlohmann::json &amp;jsonObject, const std::shared_ptr&lt; ExportSettings &gt; &amp;saveSettings)</argsstring>
        <name>to_json</name>
        <param>
          <type>nlohmann::json &amp;</type>
          <declname>jsonObject</declname>
        </param>
        <param>
          <type>const std::shared_ptr&lt; <ref refid="classtudat_1_1json__interface_1_1ExportSettings" kindref="compound">ExportSettings</ref> &gt; &amp;</type>
          <declname>saveSettings</declname>
        </param>
        <briefdescription>
<para>Create a <computeroutput>json</computeroutput> object from a shared pointer to a <computeroutput><ref refid="classtudat_1_1json__interface_1_1ExportSettings" kindref="compound">ExportSettings</ref></computeroutput> object. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/Users/jonashener/tudatpy_dev/tudat-bundle/tudat/src/interface/json/propagation/export.cpp" line="21" column="6" bodyfile="/Users/jonashener/tudatpy_dev/tudat-bundle/tudat/src/interface/json/propagation/export.cpp" bodystart="21" bodyend="37" declfile="/Users/jonashener/tudatpy_dev/tudat-bundle/tudat/include/tudat/interface/json/propagation/export.h" declline="73" declcolumn="6"/>
      </memberdef>
      <memberdef kind="function" id="export_8h_1a90d2603dcb8774797358e3a186dfebd3" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void tudat::json_interface::from_json</definition>
        <argsstring>(const nlohmann::json &amp;jsonObject, std::shared_ptr&lt; ExportSettings &gt; &amp;saveSettings)</argsstring>
        <name>from_json</name>
        <param>
          <type>const nlohmann::json &amp;</type>
          <declname>jsonObject</declname>
        </param>
        <param>
          <type>std::shared_ptr&lt; <ref refid="classtudat_1_1json__interface_1_1ExportSettings" kindref="compound">ExportSettings</ref> &gt; &amp;</type>
          <declname>saveSettings</declname>
        </param>
        <briefdescription>
<para>Create a shared pointer to a <computeroutput><ref refid="classtudat_1_1json__interface_1_1ExportSettings" kindref="compound">ExportSettings</ref></computeroutput> object from a <computeroutput>json</computeroutput> object. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/Users/jonashener/tudatpy_dev/tudat-bundle/tudat/src/interface/json/propagation/export.cpp" line="40" column="6" bodyfile="/Users/jonashener/tudatpy_dev/tudat-bundle/tudat/src/interface/json/propagation/export.cpp" bodystart="40" bodyend="55" declfile="/Users/jonashener/tudatpy_dev/tudat-bundle/tudat/include/tudat/interface/json/propagation/export.h" declline="76" declcolumn="6"/>
      </memberdef>
      <memberdef kind="function" id="export_8h_1a437ea52b410bf2ce7e2f2dcb93b92fb8" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename TimeType</type>
            <defval>double</defval>
          </param>
          <param>
            <type>typename StateScalarType</type>
            <defval>double</defval>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void tudat::json_interface::exportResultsOfDynamicsSimulator</definition>
        <argsstring>(const std::shared_ptr&lt; propagators::SingleArcDynamicsSimulator&lt; StateScalarType, TimeType &gt; &gt; &amp;singleArcDynamicsSimulator, const std::vector&lt; std::shared_ptr&lt; ExportSettings &gt; &gt; &amp;exportSettingsVector, const bool variationalEquationsAreSaved=false)</argsstring>
        <name>exportResultsOfDynamicsSimulator</name>
        <param>
          <type>const std::shared_ptr&lt; <ref refid="classtudat_1_1propagators_1_1SingleArcDynamicsSimulator" kindref="compound">propagators::SingleArcDynamicsSimulator</ref>&lt; StateScalarType, TimeType &gt; &gt; &amp;</type>
          <declname>singleArcDynamicsSimulator</declname>
        </param>
        <param>
          <type>const std::vector&lt; std::shared_ptr&lt; <ref refid="classtudat_1_1json__interface_1_1ExportSettings" kindref="compound">ExportSettings</ref> &gt; &gt; &amp;</type>
          <declname>exportSettingsVector</declname>
        </param>
        <param>
          <type>const bool</type>
          <declname>variationalEquationsAreSaved</declname>
          <defval>false</defval>
        </param>
        <briefdescription>
<para>Export results of <computeroutput>dynamicsSimulator</computeroutput> according to the settings specified in <computeroutput>exportSettingsVector</computeroutput>. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>singleArcDynamicsSimulator</parametername>
</parameternamelist>
<parameterdescription>
<para>The dynamics simulator containing the results. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>exportSettingsVector</parametername>
</parameternamelist>
<parameterdescription>
<para>The vector containing export settings (each element represents a file to be exported). </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>variationalEquationsAreSaved</parametername>
</parameternamelist>
<parameterdescription>
<para>Boolean denoting whether to save the variational equations (default is false). </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="exception"><parameteritem>
<parameternamelist>
<parametername>std::exception</parametername>
</parameternamelist>
<parameterdescription>
<para>If any of the requested variables is not recognized or was not stored in the results of <computeroutput>dynamicsSimulator</computeroutput>. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/Users/jonashener/tudatpy_dev/tudat-bundle/tudat/include/tudat/interface/json/propagation/export.h" line="89" column="6" bodyfile="/Users/jonashener/tudatpy_dev/tudat-bundle/tudat/include/tudat/interface/json/propagation/export.h" bodystart="89" bodyend="306"/>
      </memberdef>
      <memberdef kind="function" id="export_8h_1a60d7a3275d29f4655b91842ed05e2a97" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename StateScalarType</type>
            <defval>double</defval>
          </param>
          <param>
            <type>typename TimeType</type>
            <defval>double</defval>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void tudat::json_interface::exportResultsOfVariationalEquations</definition>
        <argsstring>(const std::shared_ptr&lt; propagators::SingleArcVariationalEquationsSolver&lt; StateScalarType, TimeType &gt; &gt; variationalEquationsSolver, const std::vector&lt; std::shared_ptr&lt; ExportSettings &gt; &gt; &amp;exportSettingsVector)</argsstring>
        <name>exportResultsOfVariationalEquations</name>
        <param>
          <type>const std::shared_ptr&lt; <ref refid="classtudat_1_1propagators_1_1SingleArcVariationalEquationsSolver" kindref="compound">propagators::SingleArcVariationalEquationsSolver</ref>&lt; StateScalarType, TimeType &gt; &gt;</type>
          <declname>variationalEquationsSolver</declname>
        </param>
        <param>
          <type>const std::vector&lt; std::shared_ptr&lt; <ref refid="classtudat_1_1json__interface_1_1ExportSettings" kindref="compound">ExportSettings</ref> &gt; &gt; &amp;</type>
          <declname>exportSettingsVector</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/Users/jonashener/tudatpy_dev/tudat-bundle/tudat/include/tudat/interface/json/propagation/export.h" line="309" column="6" bodyfile="/Users/jonashener/tudatpy_dev/tudat-bundle/tudat/include/tudat/interface/json/propagation/export.h" bodystart="309" bodyend="359"/>
      </memberdef>
      <memberdef kind="function" id="propagator_8h_1a5ac3eb5f970c74407a75807adf5ce602" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>std::string</type>
        <definition>std::string tudat::json_interface::getAssociatedKey</definition>
        <argsstring>(const propagators::IntegratedStateType integratedStateType)</argsstring>
        <name>getAssociatedKey</name>
        <param>
          <type>const propagators::IntegratedStateType</type>
          <declname>integratedStateType</declname>
        </param>
        <briefdescription>
<para>Get the associated key (defined in a body JSON object) for an integrated state. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>integratedStateType</parametername>
</parameternamelist>
<parameterdescription>
<para>The integrated state type for which the associated key is requested. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>The associated key for the integrated state. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/Users/jonashener/tudatpy_dev/tudat-bundle/tudat/include/tudat/interface/json/propagation/propagator.h" line="38" column="20" bodyfile="/Users/jonashener/tudatpy_dev/tudat-bundle/tudat/include/tudat/interface/json/propagation/propagator.h" bodystart="38" bodyend="52"/>
      </memberdef>
      <memberdef kind="function" id="propagator_8h_1a9e762441447cce904fa0b62ac56534e9" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename TimeType</type>
          </param>
          <param>
            <type>typename StateScalarType</type>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void tudat::json_interface::determineInitialStates</definition>
        <argsstring>(nlohmann::json &amp;jsonObject, const simulation_setup::SystemOfBodies &amp;bodies, const std::shared_ptr&lt; numerical_integrators::IntegratorSettings&lt; TimeType &gt; &gt; &amp;integratorSettings)</argsstring>
        <name>determineInitialStates</name>
        <param>
          <type>nlohmann::json &amp;</type>
          <declname>jsonObject</declname>
        </param>
        <param>
          <type>const <ref refid="classtudat_1_1simulation__setup_1_1SystemOfBodies" kindref="compound">simulation_setup::SystemOfBodies</ref> &amp;</type>
          <declname>bodies</declname>
        </param>
        <param>
          <type>const std::shared_ptr&lt; <ref refid="classtudat_1_1numerical__integrators_1_1IntegratorSettings" kindref="compound">numerical_integrators::IntegratorSettings</ref>&lt; TimeType &gt; &gt; &amp;</type>
          <declname>integratorSettings</declname>
        </param>
        <briefdescription>
<para>Determine initial states for the propagator object contained in <computeroutput>jsonObject</computeroutput> (if not provided). </para>
        </briefdescription>
        <detaileddescription>
<para>Determine initial states for the propagator object contained in <computeroutput>jsonObject</computeroutput> (if not provided). The initial states can be inferred either from the state properties of the body settings (e.g. body.initialState, body.mass, etc.) or from the ephemeris of the body objects in <computeroutput>bodies</computeroutput> at the initial time determined from <computeroutput>integratorSettings</computeroutput>. If the initial states cannot be inferred, the initialStates of the propagators in <computeroutput>jsonObject</computeroutput> won&apos;t be updated. <parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>jsonObject</parametername>
</parameternamelist>
<parameterdescription>
<para>The root <computeroutput>json</computeroutput> object to be updated with the inferred initial states (returned by reference). </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>bodies</parametername>
</parameternamelist>
<parameterdescription>
<para>Body map containing only bodies to be propagated with valid ephemeris. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>integratorSettings</parametername>
</parameternamelist>
<parameterdescription>
<para>Integrator settings containing the initial epoch for the ephemeris to be used. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/Users/jonashener/tudatpy_dev/tudat-bundle/tudat/include/tudat/interface/json/propagation/propagator.h" line="66" column="6" bodyfile="/Users/jonashener/tudatpy_dev/tudat-bundle/tudat/include/tudat/interface/json/propagation/propagator.h" bodystart="66" bodyend="180"/>
      </memberdef>
      <memberdef kind="function" id="propagator_8h_1a57a916583f997af73742c0a588fe140f" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename StateScalarType</type>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void tudat::json_interface::resetDependentVariableSaveSettings</definition>
        <argsstring>(std::shared_ptr&lt; propagators::MultiTypePropagatorSettings&lt; StateScalarType &gt; &gt; &amp;propagatorSettings, const std::vector&lt; std::shared_ptr&lt; ExportSettings &gt; &gt; &amp;exportSettingsVector, const bool printOutputVariables=false)</argsstring>
        <name>resetDependentVariableSaveSettings</name>
        <param>
          <type>std::shared_ptr&lt; <ref refid="classtudat_1_1propagators_1_1MultiTypePropagatorSettings" kindref="compound">propagators::MultiTypePropagatorSettings</ref>&lt; StateScalarType &gt; &gt; &amp;</type>
          <declname>propagatorSettings</declname>
        </param>
        <param>
          <type>const std::vector&lt; std::shared_ptr&lt; <ref refid="classtudat_1_1json__interface_1_1ExportSettings" kindref="compound">ExportSettings</ref> &gt; &gt; &amp;</type>
          <declname>exportSettingsVector</declname>
        </param>
        <param>
          <type>const bool</type>
          <declname>printOutputVariables</declname>
          <defval>false</defval>
        </param>
        <briefdescription>
<para>Update dependent variable save settings of propagator from export settings object. </para>
        </briefdescription>
        <detaileddescription>
<para>Update dependent variable save settings of propagator from export settings object. <parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>propagatorSettings</parametername>
</parameternamelist>
<parameterdescription>
<para>The propagator settings object to be updated (passed by reference). </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>exportSettingsVector</parametername>
</parameternamelist>
<parameterdescription>
<para>The export settings settings object containing the variables to be saved. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/Users/jonashener/tudatpy_dev/tudat-bundle/tudat/include/tudat/interface/json/propagation/propagator.h" line="189" column="6" bodyfile="/Users/jonashener/tudatpy_dev/tudat-bundle/tudat/include/tudat/interface/json/propagation/propagator.h" bodystart="189" bodyend="219"/>
      </memberdef>
      <memberdef kind="function" id="propagator_8h_1a7c33b3334f1e1ce46cc92677934642ff" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename TimeType</type>
          </param>
        </templateparamlist>
        <type>TimeType</type>
        <definition>TimeType tudat::json_interface::getTerminationEpoch</definition>
        <argsstring>(const std::shared_ptr&lt; propagators::PropagationTerminationSettings &gt; &amp;terminationSettings)</argsstring>
        <name>getTerminationEpoch</name>
        <param>
          <type>const std::shared_ptr&lt; <ref refid="classtudat_1_1propagators_1_1PropagationTerminationSettings" kindref="compound">propagators::PropagationTerminationSettings</ref> &gt; &amp;</type>
          <declname>terminationSettings</declname>
        </param>
        <briefdescription>
<para>Get end epoch for propagator. Returns <computeroutput>TUDAT_NAN</computeroutput> if there is no time termination condition. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/Users/jonashener/tudatpy_dev/tudat-bundle/tudat/include/tudat/interface/json/propagation/propagator.h" line="223" column="10" bodyfile="/Users/jonashener/tudatpy_dev/tudat-bundle/tudat/include/tudat/interface/json/propagation/propagator.h" bodystart="223" bodyend="251"/>
      </memberdef>
      <memberdef kind="function" id="state_8h_1a5bb2d6432b36d5d2afee3d7030ae7d91" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>void</type>
        <definition>void tudat::json_interface::to_json</definition>
        <argsstring>(nlohmann::json &amp;jsonObject, const StateType &amp;stateType)</argsstring>
        <name>to_json</name>
        <param>
          <type>nlohmann::json &amp;</type>
          <declname>jsonObject</declname>
        </param>
        <param>
          <type>const StateType &amp;</type>
          <declname>stateType</declname>
        </param>
        <briefdescription>
<para>Convert <computeroutput>StateType</computeroutput> to <computeroutput>json</computeroutput>. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/Users/jonashener/tudatpy_dev/tudat-bundle/tudat/include/tudat/interface/json/propagation/state.h" line="49" column="13" bodyfile="/Users/jonashener/tudatpy_dev/tudat-bundle/tudat/include/tudat/interface/json/propagation/state.h" bodystart="49" bodyend="52"/>
      </memberdef>
      <memberdef kind="function" id="state_8h_1ab4cc0936a93b8f6e3c0f67406cf9b8da" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>void</type>
        <definition>void tudat::json_interface::from_json</definition>
        <argsstring>(const nlohmann::json &amp;jsonObject, StateType &amp;stateType)</argsstring>
        <name>from_json</name>
        <param>
          <type>const nlohmann::json &amp;</type>
          <declname>jsonObject</declname>
        </param>
        <param>
          <type>StateType &amp;</type>
          <declname>stateType</declname>
        </param>
        <briefdescription>
<para>Convert <computeroutput>json</computeroutput> to <computeroutput>StateType</computeroutput>. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/Users/jonashener/tudatpy_dev/tudat-bundle/tudat/include/tudat/interface/json/propagation/state.h" line="55" column="13" bodyfile="/Users/jonashener/tudatpy_dev/tudat-bundle/tudat/include/tudat/interface/json/propagation/state.h" bodystart="55" bodyend="58"/>
      </memberdef>
      <memberdef kind="function" id="state_8h_1a03cb1a86473d85a87fb80ab3c559a41e" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename StateScalarType</type>
          </param>
        </templateparamlist>
        <type>Eigen::Matrix&lt; StateScalarType, 6, 1 &gt;</type>
        <definition>Eigen::Matrix&lt; StateScalarType, 6, 1 &gt; tudat::json_interface::getCartesianState</definition>
        <argsstring>(const nlohmann::json &amp;jsonObject, const KeyPath &amp;keyPath=KeyPath(), const std::shared_ptr&lt; simulation_setup::Body &gt; &amp;centralBody=nullptr, double epoch=TUDAT_NAN)</argsstring>
        <name>getCartesianState</name>
        <param>
          <type>const nlohmann::json &amp;</type>
          <declname>jsonObject</declname>
        </param>
        <param>
          <type>const <ref refid="classtudat_1_1json__interface_1_1KeyPath" kindref="compound">KeyPath</ref> &amp;</type>
          <declname>keyPath</declname>
          <defval><ref refid="classtudat_1_1json__interface_1_1KeyPath" kindref="compound">KeyPath</ref>()</defval>
        </param>
        <param>
          <type>const std::shared_ptr&lt; <ref refid="classtudat_1_1simulation__setup_1_1Body" kindref="compound">simulation_setup::Body</ref> &gt; &amp;</type>
          <declname>centralBody</declname>
          <defval>nullptr</defval>
        </param>
        <param>
          <type>double</type>
          <declname>epoch</declname>
          <defval>TUDAT_NAN</defval>
        </param>
        <briefdescription>
<para>Get a Cartesian state from a JSON object. </para>
        </briefdescription>
        <detaileddescription>
<para>Get a Cartesian state from a JSON object. The <computeroutput>jsonObject</computeroutput> can be either an array of 6 numbers (in which case it is assumed to be directly the Cartesian state) or an object with different keys (such as vx, eccentricity, etc.) and different possible types (Cartesian, Keplerian, spherical). <parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>jsonObject</parametername>
</parameternamelist>
<parameterdescription>
<para>The JSON object. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>keyPath</parametername>
</parameternamelist>
<parameterdescription>
<para>The key path at which the state array/object can be retrieved from <computeroutput>jsonObject</computeroutput>. Empty if <computeroutput>jsonObject</computeroutput> is already the array/object (default value). </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>centralBody</parametername>
</parameternamelist>
<parameterdescription>
<para>Associated central body from which the central gravitational parameter, average radius, ephemeris, etc. are retrieved when converting certain elements types to Cartesian. This information can also be provided in the <computeroutput>jsonObject</computeroutput>, in which case this can be set to <computeroutput>nullptr</computeroutput> (default value). </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>epoch</parametername>
</parameternamelist>
<parameterdescription>
<para>The associated epoch for converting from spherical to Cartesian elements. This information can also be provided in the <computeroutput>jsonObject</computeroutput>, in which case this can be set to <computeroutput>TUDAT_NAN</computeroutput> (default value). </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/Users/jonashener/tudatpy_dev/tudat-bundle/tudat/include/tudat/interface/json/propagation/state.h" line="75" column="15" bodyfile="/Users/jonashener/tudatpy_dev/tudat-bundle/tudat/include/tudat/interface/json/propagation/state.h" bodystart="75" bodyend="336"/>
      </memberdef>
      <memberdef kind="function" id="deserialization_8h_1ad61acf3f7461146e7781c174412776c6" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>nlohmann::json</type>
        <definition>nlohmann::json tudat::json_interface::readJSON</definition>
        <argsstring>(const boost::filesystem::path &amp;filePath, const boost::filesystem::path &amp;parentFilePath=boost::filesystem::path(), const boost::filesystem::path &amp;rootFilePath=boost::filesystem::path())</argsstring>
        <name>readJSON</name>
        <param>
          <type>const boost::filesystem::path &amp;</type>
          <declname>filePath</declname>
        </param>
        <param>
          <type>const boost::filesystem::path &amp;</type>
          <declname>parentFilePath</declname>
          <defval>boost::filesystem::path()</defval>
        </param>
        <param>
          <type>const boost::filesystem::path &amp;</type>
          <declname>rootFilePath</declname>
          <defval>boost::filesystem::path()</defval>
        </param>
        <briefdescription>
<para>Read a JSON file into a <computeroutput>json</computeroutput> object. </para>
        </briefdescription>
        <detaileddescription>
<para>If <computeroutput>inclusionFile</computeroutput> is not empty, the strings matching the expression &quot;#path(relativePath)&quot; are replaced by the corresponding relative path relative to the file in which it is being included. <parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>filePath</parametername>
</parameternamelist>
<parameterdescription>
<para>Path to the JSON file. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>parentFilePath</parametername>
</parameternamelist>
<parameterdescription>
<para>File from which the contents of <computeroutput>filePath</computeroutput> are being read (empty if <computeroutput>filePath</computeroutput> is equal to <computeroutput>parentFilePath</computeroutput>). </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>rootFilePath</parametername>
</parameternamelist>
<parameterdescription>
<para>Path to the root file that was passed as command-line argument to the application (empty if <computeroutput>filePath</computeroutput> is equal to <computeroutput>rootFilePath</computeroutput>). </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Read <computeroutput>json</computeroutput> object. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/Users/jonashener/tudatpy_dev/tudat-bundle/tudat/src/interface/json/support/deserialization.cpp" line="169" column="16" bodyfile="/Users/jonashener/tudatpy_dev/tudat-bundle/tudat/src/interface/json/support/deserialization.cpp" bodystart="169" bodyend="187" declfile="/Users/jonashener/tudatpy_dev/tudat-bundle/tudat/include/tudat/interface/json/support/deserialization.h" declline="35" declcolumn="16"/>
      </memberdef>
      <memberdef kind="function" id="deserialization_8h_1abe4feef6c8be6aaf4b6565785ef1ff05" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>boost::filesystem::path</type>
        <definition>boost::filesystem::path tudat::json_interface::getPathForJSONFile</definition>
        <argsstring>(const std::string &amp;file, const boost::filesystem::path &amp;basePath=boost::filesystem::current_path())</argsstring>
        <name>getPathForJSONFile</name>
        <param>
          <type>const std::string &amp;</type>
          <declname>file</declname>
        </param>
        <param>
          <type>const boost::filesystem::path &amp;</type>
          <declname>basePath</declname>
          <defval>boost::filesystem::current_path()</defval>
        </param>
        <briefdescription>
<para>Get the path for a JSON file. </para>
        </briefdescription>
        <detaileddescription>
<para>Get the path for a JSON file. This function will first try to locate the file &quot;basePath/file&quot;. If this fails, and <computeroutput>file</computeroutput> contains no extension, the function will try to locate the file &quot;basePath/file/main.json&quot;. If this also fails, the function will then try to locate the file &quot;basePath/file.json&quot;. If this also fails, an error will be thrown. <parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>file</parametername>
</parameternamelist>
<parameterdescription>
<para>Name of the JSON file (with extension) or directory at which a &quot;main.json&quot; file is located. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>basePath</parametername>
</parameternamelist>
<parameterdescription>
<para>Parent directory in which to look for the requested file. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Path for the JSON file. </para>
</simplesect>
<parameterlist kind="exception"><parameteritem>
<parameternamelist>
<parametername>Error</parametername>
</parameternamelist>
<parameterdescription>
<para>if the file does not exist. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/Users/jonashener/tudatpy_dev/tudat-bundle/tudat/src/interface/json/support/deserialization.cpp" line="26" column="25" bodyfile="/Users/jonashener/tudatpy_dev/tudat-bundle/tudat/src/interface/json/support/deserialization.cpp" bodystart="26" bodyend="62" declfile="/Users/jonashener/tudatpy_dev/tudat-bundle/tudat/include/tudat/interface/json/support/deserialization.h" declline="49" declcolumn="25"/>
      </memberdef>
      <memberdef kind="function" id="deserialization_8h_1a59c09dfbbf8e907089dc0c9de3e51a3f" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>nlohmann::json</type>
        <definition>nlohmann::json tudat::json_interface::getDeserializedJSON</definition>
        <argsstring>(const boost::filesystem::path &amp;inputFilePath)</argsstring>
        <name>getDeserializedJSON</name>
        <param>
          <type>const boost::filesystem::path &amp;</type>
          <declname>inputFilePath</declname>
        </param>
        <briefdescription>
<para>Read and parse a (normal) <computeroutput>json</computeroutput> object from a file, and then parse its imported modular files. </para>
        </briefdescription>
        <detaileddescription>
<para>Read and parse a (normal) <computeroutput>json</computeroutput> object from a file, and then parse its imported modular files using parseModularJSON(). <parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>inputFilePath</parametername>
</parameternamelist>
<parameterdescription>
<para>Path to the root JSON file. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Object containing the keys defined in the original file and all the imported files. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/Users/jonashener/tudatpy_dev/tudat-bundle/tudat/src/interface/json/support/deserialization.cpp" line="465" column="16" bodyfile="/Users/jonashener/tudatpy_dev/tudat-bundle/tudat/src/interface/json/support/deserialization.cpp" bodystart="465" bodyend="471" declfile="/Users/jonashener/tudatpy_dev/tudat-bundle/tudat/include/tudat/interface/json/support/deserialization.h" declline="58" declcolumn="16"/>
      </memberdef>
      <memberdef kind="function" id="errorHandling_8h_1a660f7866fa0b2959798544a4afbd6259" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename T</type>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void tudat::json_interface::assertNonnullptrPointer</definition>
        <argsstring>(const std::shared_ptr&lt; T &gt; &amp;pointer)</argsstring>
        <name>assertNonnullptrPointer</name>
        <param>
          <type>const std::shared_ptr&lt; T &gt; &amp;</type>
          <declname>pointer</declname>
        </param>
        <briefdescription>
<para>Check that a pointer is not <computeroutput>nullptr</computeroutput>. </para>
        </briefdescription>
        <detaileddescription>
<para>Check that a pointer to an object of type <computeroutput>T</computeroutput> is not <computeroutput>nullptr</computeroutput>. <parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>pointer</parametername>
</parameternamelist>
<parameterdescription>
<para>The pointer that is not allowed to be <computeroutput>nullptr</computeroutput>. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="exception"><parameteritem>
<parameternamelist>
<parametername>nullptrPointerError&lt;</parametername>
</parameternamelist>
<parameterdescription>
<para>T &gt; If <computeroutput>pointer</computeroutput> is <computeroutput>nullptr</computeroutput>. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/Users/jonashener/tudatpy_dev/tudat-bundle/tudat/include/tudat/interface/json/support/errorHandling.h" line="350" column="6" bodyfile="/Users/jonashener/tudatpy_dev/tudat-bundle/tudat/include/tudat/interface/json/support/errorHandling.h" bodystart="350" bodyend="360"/>
      </memberdef>
      <memberdef kind="function" id="errorHandling_8h_1a334e809674a1a4561cbad805f0889c88" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename EnumType</type>
          </param>
        </templateparamlist>
        <type>EnumType</type>
        <definition>EnumType tudat::json_interface::enumFromString</definition>
        <argsstring>(const std::string &amp;stringValue, const std::map&lt; EnumType, std::string &gt; &amp;stringValues)</argsstring>
        <name>enumFromString</name>
        <param>
          <type>const std::string &amp;</type>
          <declname>stringValue</declname>
        </param>
        <param>
          <type>const std::map&lt; EnumType, std::string &gt; &amp;</type>
          <declname>stringValues</declname>
        </param>
        <briefdescription>
<para>Get an <computeroutput>enum</computeroutput> value of type <computeroutput>EnumType</computeroutput> from a <computeroutput>std::string</computeroutput>. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>stringValue</parametername>
</parameternamelist>
<parameterdescription>
<para>The string to be converted to <computeroutput>EnumType</computeroutput>. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>stringValues</parametername>
</parameternamelist>
<parameterdescription>
<para>Map containing the string representation for the values of <computeroutput>EnumType</computeroutput>. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>The <computeroutput>EnumType</computeroutput> corresponding to <computeroutput>stringValue</computeroutput>. </para>
</simplesect>
<parameterlist kind="exception"><parameteritem>
<parameternamelist>
<parametername><ref refid="classtudat_1_1json__interface_1_1UnknownEnumError" kindref="compound">UnknownEnumError</ref></parametername>
</parameternamelist>
<parameterdescription>
<para>If no entry with value <computeroutput>stringValue</computeroutput> is found in <computeroutput>stringValues</computeroutput>. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/Users/jonashener/tudatpy_dev/tudat-bundle/tudat/include/tudat/interface/json/support/errorHandling.h" line="392" column="10" bodyfile="/Users/jonashener/tudatpy_dev/tudat-bundle/tudat/include/tudat/interface/json/support/errorHandling.h" bodystart="392" bodyend="409"/>
      </memberdef>
      <memberdef kind="function" id="errorHandling_8h_1acfc2899b6df94caca570e544309fdea6" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename EnumType</type>
          </param>
        </templateparamlist>
        <type>std::string</type>
        <definition>std::string tudat::json_interface::stringFromEnum</definition>
        <argsstring>(const EnumType enumValue, const std::map&lt; EnumType, std::string &gt; &amp;stringValues)</argsstring>
        <name>stringFromEnum</name>
        <param>
          <type>const EnumType</type>
          <declname>enumValue</declname>
        </param>
        <param>
          <type>const std::map&lt; EnumType, std::string &gt; &amp;</type>
          <declname>stringValues</declname>
        </param>
        <briefdescription>
<para>Get a <computeroutput>std::string</computeroutput> from an <computeroutput>enum</computeroutput> value of type <computeroutput>EnumType</computeroutput>. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>enumValue</parametername>
</parameternamelist>
<parameterdescription>
<para>The <computeroutput>EnumType</computeroutput> to be converted to string. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>stringValues</parametername>
</parameternamelist>
<parameterdescription>
<para>Map containing the string representation for the values of <computeroutput>EnumType</computeroutput>. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>The <computeroutput>std::string</computeroutput> corresponding to <computeroutput>enumValue</computeroutput>. </para>
</simplesect>
<parameterlist kind="exception"><parameteritem>
<parameternamelist>
<parametername><ref refid="classtudat_1_1json__interface_1_1UnknownEnumError" kindref="compound">UnknownEnumError</ref></parametername>
</parameternamelist>
<parameterdescription>
<para>If no entry with key <computeroutput>enumValue</computeroutput> is found in <computeroutput>stringValues</computeroutput>. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/Users/jonashener/tudatpy_dev/tudat-bundle/tudat/include/tudat/interface/json/support/errorHandling.h" line="420" column="13" bodyfile="/Users/jonashener/tudatpy_dev/tudat-bundle/tudat/include/tudat/interface/json/support/errorHandling.h" bodystart="420" bodyend="432"/>
      </memberdef>
      <memberdef kind="function" id="errorHandling_8h_1ad66b734e4a05cd2af739ecdb12b3fafa" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename EnumType</type>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void tudat::json_interface::handleUnimplementedEnumValue</definition>
        <argsstring>(const EnumType enumValue, const std::map&lt; EnumType, std::string &gt; &amp;stringValues, const std::vector&lt; EnumType &gt; &amp;unssupportedValues)</argsstring>
        <name>handleUnimplementedEnumValue</name>
        <param>
          <type>const EnumType</type>
          <declname>enumValue</declname>
        </param>
        <param>
          <type>const std::map&lt; EnumType, std::string &gt; &amp;</type>
          <declname>stringValues</declname>
        </param>
        <param>
          <type>const std::vector&lt; EnumType &gt; &amp;</type>
          <declname>unssupportedValues</declname>
        </param>
        <briefdescription>
<para>Handle an unimplemented <computeroutput>enum</computeroutput> value of type <computeroutput>EnumType</computeroutput>. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>enumValue</parametername>
</parameternamelist>
<parameterdescription>
<para>The <computeroutput>enum</computeroutput> value of type <computeroutput>T</computeroutput> that is not implemented. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>stringValues</parametername>
</parameternamelist>
<parameterdescription>
<para>Map containing the string representation for the values of <computeroutput>EnumType</computeroutput> (including <computeroutput>enumValue</computeroutput>). </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>unssupportedValues</parametername>
</parameternamelist>
<parameterdescription>
<para>Vector of values of <computeroutput>EnumType</computeroutput> that are not supported by json_interface. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="exception"><parameteritem>
<parameternamelist>
<parametername>UnsupportedEnumError&lt;EnumType&gt;</parametername>
</parameternamelist>
<parameterdescription>
<para>If <computeroutput>enumValue</computeroutput> is contained in <computeroutput>unssupportedValues</computeroutput>. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>UnimplementedEnumError&lt;EnumType&gt;</parametername>
</parameternamelist>
<parameterdescription>
<para>If <computeroutput>enumValue</computeroutput> is not contained in <computeroutput>unssupportedValues</computeroutput>. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/Users/jonashener/tudatpy_dev/tudat-bundle/tudat/include/tudat/interface/json/support/errorHandling.h" line="508" column="6" bodyfile="/Users/jonashener/tudatpy_dev/tudat-bundle/tudat/include/tudat/interface/json/support/errorHandling.h" bodystart="508" bodyend="522"/>
      </memberdef>
      <memberdef kind="function" id="keys_8h_1a0c24d05b8f177529559344c2033fe5f8" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>int</type>
        <definition>int tudat::json_interface::indexFromKey</definition>
        <argsstring>(const std::string &amp;key)</argsstring>
        <name>indexFromKey</name>
        <param>
          <type>const std::string &amp;</type>
          <declname>key</declname>
        </param>
        <briefdescription>
<para>Get the int-value of an int-convertible key. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>key</parametername>
</parameternamelist>
<parameterdescription>
<para>The int-convertible key, of the type &quot;@0&quot;, &quot;@1&quot;, etc. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>The array index, or -1 if the key is not convertible to integer. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/Users/jonashener/tudatpy_dev/tudat-bundle/tudat/src/interface/json/support/keys.cpp" line="500" column="5" bodyfile="/Users/jonashener/tudatpy_dev/tudat-bundle/tudat/src/interface/json/support/keys.cpp" bodystart="500" bodyend="513" declfile="/Users/jonashener/tudatpy_dev/tudat-bundle/tudat/include/tudat/interface/json/support/keys.h" declline="545" declcolumn="5"/>
      </memberdef>
      <memberdef kind="function" id="keys_8h_1a8c88965fa091aaeadcdfe862d7593c7b" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>std::ostream &amp;</type>
        <definition>std::ostream &amp; tudat::json_interface::operator&lt;&lt;</definition>
        <argsstring>(std::ostream &amp;stringRepresentation, KeyPath const &amp;keyPath)</argsstring>
        <name>operator&lt;&lt;</name>
        <param>
          <type>std::ostream &amp;</type>
          <declname>stringRepresentation</declname>
        </param>
        <param>
          <type><ref refid="classtudat_1_1json__interface_1_1KeyPath" kindref="compound">KeyPath</ref> const &amp;</type>
          <declname>keyPath</declname>
        </param>
        <briefdescription>
<para>String representation for <computeroutput><ref refid="classtudat_1_1json__interface_1_1KeyPath" kindref="compound">KeyPath</ref></computeroutput>, as key.subkey.vectorIndex.subsubkey ... </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/Users/jonashener/tudatpy_dev/tudat-bundle/tudat/src/interface/json/support/keys.cpp" line="538" column="1" bodyfile="/Users/jonashener/tudatpy_dev/tudat-bundle/tudat/src/interface/json/support/keys.cpp" bodystart="538" bodyend="563" declfile="/Users/jonashener/tudatpy_dev/tudat-bundle/tudat/include/tudat/interface/json/support/keys.h" declline="612" declcolumn="1"/>
      </memberdef>
      <memberdef kind="function" id="keys_8h_1a9a4c76cb56fa4f0682b7b60609cddd72" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classtudat_1_1json__interface_1_1KeyPath" kindref="compound">KeyPath</ref></type>
        <definition>KeyPath tudat::json_interface::operator/</definition>
        <argsstring>(KeyPath path1, const KeyPath &amp;path2)</argsstring>
        <name>operator/</name>
        <param>
          <type><ref refid="classtudat_1_1json__interface_1_1KeyPath" kindref="compound">KeyPath</ref></type>
          <declname>path1</declname>
        </param>
        <param>
          <type>const <ref refid="classtudat_1_1json__interface_1_1KeyPath" kindref="compound">KeyPath</ref> &amp;</type>
          <declname>path2</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/Users/jonashener/tudatpy_dev/tudat-bundle/tudat/include/tudat/interface/json/support/keys.h" line="614" column="16" bodyfile="/Users/jonashener/tudatpy_dev/tudat-bundle/tudat/include/tudat/interface/json/support/keys.h" bodystart="614" bodyend="621"/>
      </memberdef>
      <memberdef kind="function" id="keys_8h_1a9b3628570b18492a4efa940a87fbc2c2" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classtudat_1_1json__interface_1_1KeyPath" kindref="compound">KeyPath</ref></type>
        <definition>KeyPath tudat::json_interface::operator/</definition>
        <argsstring>(const KeyPath &amp;path, const std::string &amp;str)</argsstring>
        <name>operator/</name>
        <param>
          <type>const <ref refid="classtudat_1_1json__interface_1_1KeyPath" kindref="compound">KeyPath</ref> &amp;</type>
          <declname>path</declname>
        </param>
        <param>
          <type>const std::string &amp;</type>
          <declname>str</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/Users/jonashener/tudatpy_dev/tudat-bundle/tudat/include/tudat/interface/json/support/keys.h" line="623" column="16" bodyfile="/Users/jonashener/tudatpy_dev/tudat-bundle/tudat/include/tudat/interface/json/support/keys.h" bodystart="623" bodyend="626"/>
      </memberdef>
      <memberdef kind="function" id="keys_8h_1a1d7bd5ef250b68745a46baf1d323ef8b" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classtudat_1_1json__interface_1_1KeyPath" kindref="compound">KeyPath</ref></type>
        <definition>KeyPath tudat::json_interface::operator/</definition>
        <argsstring>(const std::string &amp;str, const KeyPath &amp;path)</argsstring>
        <name>operator/</name>
        <param>
          <type>const std::string &amp;</type>
          <declname>str</declname>
        </param>
        <param>
          <type>const <ref refid="classtudat_1_1json__interface_1_1KeyPath" kindref="compound">KeyPath</ref> &amp;</type>
          <declname>path</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/Users/jonashener/tudatpy_dev/tudat-bundle/tudat/include/tudat/interface/json/support/keys.h" line="628" column="16" bodyfile="/Users/jonashener/tudatpy_dev/tudat-bundle/tudat/include/tudat/interface/json/support/keys.h" bodystart="628" bodyend="631"/>
      </memberdef>
      <memberdef kind="function" id="keys_8h_1ae0a7147e8f6781cd0ea53e3c9b20cb87" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classtudat_1_1json__interface_1_1KeyPath" kindref="compound">KeyPath</ref></type>
        <definition>KeyPath tudat::json_interface::operator/</definition>
        <argsstring>(const std::string &amp;str1, const std::string &amp;str2)</argsstring>
        <name>operator/</name>
        <param>
          <type>const std::string &amp;</type>
          <declname>str1</declname>
        </param>
        <param>
          <type>const std::string &amp;</type>
          <declname>str2</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/Users/jonashener/tudatpy_dev/tudat-bundle/tudat/include/tudat/interface/json/support/keys.h" line="633" column="16" bodyfile="/Users/jonashener/tudatpy_dev/tudat-bundle/tudat/include/tudat/interface/json/support/keys.h" bodystart="633" bodyend="636"/>
      </memberdef>
      <memberdef kind="function" id="keys_8h_1a759b3e13a29cf73281c471432cb26d38" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classtudat_1_1json__interface_1_1KeyPath" kindref="compound">KeyPath</ref></type>
        <definition>KeyPath tudat::json_interface::operator/</definition>
        <argsstring>(const KeyPath &amp;path, const char *str)</argsstring>
        <name>operator/</name>
        <param>
          <type>const <ref refid="classtudat_1_1json__interface_1_1KeyPath" kindref="compound">KeyPath</ref> &amp;</type>
          <declname>path</declname>
        </param>
        <param>
          <type>const char *</type>
          <declname>str</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/Users/jonashener/tudatpy_dev/tudat-bundle/tudat/include/tudat/interface/json/support/keys.h" line="638" column="16" bodyfile="/Users/jonashener/tudatpy_dev/tudat-bundle/tudat/include/tudat/interface/json/support/keys.h" bodystart="638" bodyend="641"/>
      </memberdef>
      <memberdef kind="function" id="keys_8h_1a0f4e9a239f7dec8c0a1dc3738afabf8f" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classtudat_1_1json__interface_1_1KeyPath" kindref="compound">KeyPath</ref></type>
        <definition>KeyPath tudat::json_interface::operator/</definition>
        <argsstring>(const char *str, const KeyPath &amp;path)</argsstring>
        <name>operator/</name>
        <param>
          <type>const char *</type>
          <declname>str</declname>
        </param>
        <param>
          <type>const <ref refid="classtudat_1_1json__interface_1_1KeyPath" kindref="compound">KeyPath</ref> &amp;</type>
          <declname>path</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/Users/jonashener/tudatpy_dev/tudat-bundle/tudat/include/tudat/interface/json/support/keys.h" line="643" column="16" bodyfile="/Users/jonashener/tudatpy_dev/tudat-bundle/tudat/include/tudat/interface/json/support/keys.h" bodystart="643" bodyend="646"/>
      </memberdef>
      <memberdef kind="function" id="keys_8h_1afa191f402576fa2192e8c15684736d20" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classtudat_1_1json__interface_1_1KeyPath" kindref="compound">KeyPath</ref></type>
        <definition>KeyPath tudat::json_interface::operator/</definition>
        <argsstring>(const KeyPath &amp;path, const unsigned int vectorIndex)</argsstring>
        <name>operator/</name>
        <param>
          <type>const <ref refid="classtudat_1_1json__interface_1_1KeyPath" kindref="compound">KeyPath</ref> &amp;</type>
          <declname>path</declname>
        </param>
        <param>
          <type>const unsigned int</type>
          <declname>vectorIndex</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/Users/jonashener/tudatpy_dev/tudat-bundle/tudat/include/tudat/interface/json/support/keys.h" line="648" column="16" bodyfile="/Users/jonashener/tudatpy_dev/tudat-bundle/tudat/include/tudat/interface/json/support/keys.h" bodystart="648" bodyend="651"/>
      </memberdef>
      <memberdef kind="function" id="keys_8h_1a59222d9bfccc84cae63841ef174f0596" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classtudat_1_1json__interface_1_1KeyPath" kindref="compound">KeyPath</ref></type>
        <definition>KeyPath tudat::json_interface::operator/</definition>
        <argsstring>(const unsigned int vectorIndex, const KeyPath &amp;path)</argsstring>
        <name>operator/</name>
        <param>
          <type>const unsigned int</type>
          <declname>vectorIndex</declname>
        </param>
        <param>
          <type>const <ref refid="classtudat_1_1json__interface_1_1KeyPath" kindref="compound">KeyPath</ref> &amp;</type>
          <declname>path</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/Users/jonashener/tudatpy_dev/tudat-bundle/tudat/include/tudat/interface/json/support/keys.h" line="653" column="16" bodyfile="/Users/jonashener/tudatpy_dev/tudat-bundle/tudat/include/tudat/interface/json/support/keys.h" bodystart="653" bodyend="656"/>
      </memberdef>
      <memberdef kind="function" id="keys_8h_1abe372f35f48824e50f4a6ad043688662" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classtudat_1_1json__interface_1_1KeyPath" kindref="compound">KeyPath</ref></type>
        <definition>KeyPath tudat::json_interface::operator/</definition>
        <argsstring>(const std::string &amp;str, const unsigned int vectorIndex)</argsstring>
        <name>operator/</name>
        <param>
          <type>const std::string &amp;</type>
          <declname>str</declname>
        </param>
        <param>
          <type>const unsigned int</type>
          <declname>vectorIndex</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/Users/jonashener/tudatpy_dev/tudat-bundle/tudat/include/tudat/interface/json/support/keys.h" line="658" column="16" bodyfile="/Users/jonashener/tudatpy_dev/tudat-bundle/tudat/include/tudat/interface/json/support/keys.h" bodystart="658" bodyend="661"/>
      </memberdef>
      <memberdef kind="function" id="keys_8h_1a2659f6fda4118daa65ac83b557de28f7" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classtudat_1_1json__interface_1_1KeyPath" kindref="compound">KeyPath</ref></type>
        <definition>KeyPath tudat::json_interface::operator/</definition>
        <argsstring>(const unsigned int vectorIndex, const std::string &amp;str)</argsstring>
        <name>operator/</name>
        <param>
          <type>const unsigned int</type>
          <declname>vectorIndex</declname>
        </param>
        <param>
          <type>const std::string &amp;</type>
          <declname>str</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/Users/jonashener/tudatpy_dev/tudat-bundle/tudat/include/tudat/interface/json/support/keys.h" line="663" column="16" bodyfile="/Users/jonashener/tudatpy_dev/tudat-bundle/tudat/include/tudat/interface/json/support/keys.h" bodystart="663" bodyend="666"/>
      </memberdef>
      <memberdef kind="function" id="keys_8h_1a5d74571cfbc1e80fd5208bbab20d5bd4" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classtudat_1_1json__interface_1_1KeyPath" kindref="compound">KeyPath</ref></type>
        <definition>KeyPath tudat::json_interface::operator/</definition>
        <argsstring>(const KeyPath &amp;path, const int vectorIndex)</argsstring>
        <name>operator/</name>
        <param>
          <type>const <ref refid="classtudat_1_1json__interface_1_1KeyPath" kindref="compound">KeyPath</ref> &amp;</type>
          <declname>path</declname>
        </param>
        <param>
          <type>const int</type>
          <declname>vectorIndex</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/Users/jonashener/tudatpy_dev/tudat-bundle/tudat/include/tudat/interface/json/support/keys.h" line="668" column="16" bodyfile="/Users/jonashener/tudatpy_dev/tudat-bundle/tudat/include/tudat/interface/json/support/keys.h" bodystart="668" bodyend="671"/>
      </memberdef>
      <memberdef kind="function" id="keys_8h_1a7479aec54884534d26ae6ac7011ce585" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classtudat_1_1json__interface_1_1KeyPath" kindref="compound">KeyPath</ref></type>
        <definition>KeyPath tudat::json_interface::operator/</definition>
        <argsstring>(const int vectorIndex, const KeyPath &amp;path)</argsstring>
        <name>operator/</name>
        <param>
          <type>const int</type>
          <declname>vectorIndex</declname>
        </param>
        <param>
          <type>const <ref refid="classtudat_1_1json__interface_1_1KeyPath" kindref="compound">KeyPath</ref> &amp;</type>
          <declname>path</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/Users/jonashener/tudatpy_dev/tudat-bundle/tudat/include/tudat/interface/json/support/keys.h" line="673" column="16" bodyfile="/Users/jonashener/tudatpy_dev/tudat-bundle/tudat/include/tudat/interface/json/support/keys.h" bodystart="673" bodyend="676"/>
      </memberdef>
      <memberdef kind="function" id="keys_8h_1ad861e8c63265511fd83f771b01cf27dd" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classtudat_1_1json__interface_1_1KeyPath" kindref="compound">KeyPath</ref></type>
        <definition>KeyPath tudat::json_interface::operator/</definition>
        <argsstring>(const std::string &amp;str, const int vectorIndex)</argsstring>
        <name>operator/</name>
        <param>
          <type>const std::string &amp;</type>
          <declname>str</declname>
        </param>
        <param>
          <type>const int</type>
          <declname>vectorIndex</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/Users/jonashener/tudatpy_dev/tudat-bundle/tudat/include/tudat/interface/json/support/keys.h" line="678" column="16" bodyfile="/Users/jonashener/tudatpy_dev/tudat-bundle/tudat/include/tudat/interface/json/support/keys.h" bodystart="678" bodyend="681"/>
      </memberdef>
      <memberdef kind="function" id="keys_8h_1a8a0716e6c01417ac82f431ad72e09977" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classtudat_1_1json__interface_1_1KeyPath" kindref="compound">KeyPath</ref></type>
        <definition>KeyPath tudat::json_interface::operator/</definition>
        <argsstring>(const int vectorIndex, const std::string &amp;str)</argsstring>
        <name>operator/</name>
        <param>
          <type>const int</type>
          <declname>vectorIndex</declname>
        </param>
        <param>
          <type>const std::string &amp;</type>
          <declname>str</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/Users/jonashener/tudatpy_dev/tudat-bundle/tudat/include/tudat/interface/json/support/keys.h" line="683" column="16" bodyfile="/Users/jonashener/tudatpy_dev/tudat-bundle/tudat/include/tudat/interface/json/support/keys.h" bodystart="683" bodyend="686"/>
      </memberdef>
      <memberdef kind="function" id="keys_8h_1ae7b01c57b74988c7aef3452e82debfde" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classtudat_1_1json__interface_1_1KeyPath" kindref="compound">KeyPath</ref></type>
        <definition>KeyPath tudat::json_interface::operator/</definition>
        <argsstring>(const char *str1, const std::string &amp;str2)</argsstring>
        <name>operator/</name>
        <param>
          <type>const char *</type>
          <declname>str1</declname>
        </param>
        <param>
          <type>const std::string &amp;</type>
          <declname>str2</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/Users/jonashener/tudatpy_dev/tudat-bundle/tudat/include/tudat/interface/json/support/keys.h" line="688" column="16" bodyfile="/Users/jonashener/tudatpy_dev/tudat-bundle/tudat/include/tudat/interface/json/support/keys.h" bodystart="688" bodyend="691"/>
      </memberdef>
      <memberdef kind="function" id="keys_8h_1af25c9cad3f2d2e8e79d32b6f896aa8a3" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classtudat_1_1json__interface_1_1KeyPath" kindref="compound">KeyPath</ref></type>
        <definition>KeyPath tudat::json_interface::operator/</definition>
        <argsstring>(const std::string &amp;str1, const char *str2)</argsstring>
        <name>operator/</name>
        <param>
          <type>const std::string &amp;</type>
          <declname>str1</declname>
        </param>
        <param>
          <type>const char *</type>
          <declname>str2</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/Users/jonashener/tudatpy_dev/tudat-bundle/tudat/include/tudat/interface/json/support/keys.h" line="693" column="16" bodyfile="/Users/jonashener/tudatpy_dev/tudat-bundle/tudat/include/tudat/interface/json/support/keys.h" bodystart="693" bodyend="696"/>
      </memberdef>
      <memberdef kind="function" id="options_8h_1aa31d67279e4c5ccff0502be0b40a46ca" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>void</type>
        <definition>void tudat::json_interface::to_json</definition>
        <argsstring>(nlohmann::json &amp;jsonObject, const ExceptionResponseType &amp;exceptionResponseType)</argsstring>
        <name>to_json</name>
        <param>
          <type>nlohmann::json &amp;</type>
          <declname>jsonObject</declname>
        </param>
        <param>
          <type>const ExceptionResponseType &amp;</type>
          <declname>exceptionResponseType</declname>
        </param>
        <briefdescription>
<para>Convert <computeroutput>ExceptionResponseType</computeroutput> to <computeroutput>json</computeroutput>. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/Users/jonashener/tudatpy_dev/tudat-bundle/tudat/include/tudat/interface/json/support/options.h" line="34" column="13" bodyfile="/Users/jonashener/tudatpy_dev/tudat-bundle/tudat/include/tudat/interface/json/support/options.h" bodystart="34" bodyend="37"/>
      </memberdef>
      <memberdef kind="function" id="options_8h_1a7b66f25830d8e781dfb08fbc8ef97b75" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>void</type>
        <definition>void tudat::json_interface::from_json</definition>
        <argsstring>(const nlohmann::json &amp;jsonObject, ExceptionResponseType &amp;exceptionResponseType)</argsstring>
        <name>from_json</name>
        <param>
          <type>const nlohmann::json &amp;</type>
          <declname>jsonObject</declname>
        </param>
        <param>
          <type>ExceptionResponseType &amp;</type>
          <declname>exceptionResponseType</declname>
        </param>
        <briefdescription>
<para>Convert <computeroutput>json</computeroutput> to <computeroutput>ExceptionResponseType</computeroutput>. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/Users/jonashener/tudatpy_dev/tudat-bundle/tudat/include/tudat/interface/json/support/options.h" line="40" column="13" bodyfile="/Users/jonashener/tudatpy_dev/tudat-bundle/tudat/include/tudat/interface/json/support/options.h" bodystart="40" bodyend="43"/>
      </memberdef>
      <memberdef kind="function" id="options_8h_1a98970410c36fbffb10bb478f4408c4d9" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void tudat::json_interface::to_json</definition>
        <argsstring>(nlohmann::json &amp;jsonObject, const std::shared_ptr&lt; ApplicationOptions &gt; &amp;spiceSettings)</argsstring>
        <name>to_json</name>
        <param>
          <type>nlohmann::json &amp;</type>
          <declname>jsonObject</declname>
        </param>
        <param>
          <type>const std::shared_ptr&lt; <ref refid="classtudat_1_1json__interface_1_1ApplicationOptions" kindref="compound">ApplicationOptions</ref> &gt; &amp;</type>
          <declname>spiceSettings</declname>
        </param>
        <briefdescription>
<para>Create a <computeroutput>json</computeroutput> object from a shared pointer to a <computeroutput><ref refid="classtudat_1_1json__interface_1_1ApplicationOptions" kindref="compound">ApplicationOptions</ref></computeroutput> object. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/Users/jonashener/tudatpy_dev/tudat-bundle/tudat/src/interface/json/support/options.cpp" line="21" column="6" bodyfile="/Users/jonashener/tudatpy_dev/tudat-bundle/tudat/src/interface/json/support/options.cpp" bodystart="21" bodyend="35" declfile="/Users/jonashener/tudatpy_dev/tudat-bundle/tudat/include/tudat/interface/json/support/options.h" declline="77" declcolumn="6"/>
      </memberdef>
      <memberdef kind="function" id="options_8h_1ad9012924a406403ba66e7944da5e679d" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void tudat::json_interface::from_json</definition>
        <argsstring>(const nlohmann::json &amp;jsonObject, std::shared_ptr&lt; ApplicationOptions &gt; &amp;spiceSettings)</argsstring>
        <name>from_json</name>
        <param>
          <type>const nlohmann::json &amp;</type>
          <declname>jsonObject</declname>
        </param>
        <param>
          <type>std::shared_ptr&lt; <ref refid="classtudat_1_1json__interface_1_1ApplicationOptions" kindref="compound">ApplicationOptions</ref> &gt; &amp;</type>
          <declname>spiceSettings</declname>
        </param>
        <briefdescription>
<para>Create a shared pointer to a <computeroutput><ref refid="classtudat_1_1json__interface_1_1ApplicationOptions" kindref="compound">ApplicationOptions</ref></computeroutput> object from a <computeroutput>json</computeroutput> object. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/Users/jonashener/tudatpy_dev/tudat-bundle/tudat/src/interface/json/support/options.cpp" line="38" column="6" bodyfile="/Users/jonashener/tudatpy_dev/tudat-bundle/tudat/src/interface/json/support/options.cpp" bodystart="38" bodyend="58" declfile="/Users/jonashener/tudatpy_dev/tudat-bundle/tudat/include/tudat/interface/json/support/options.h" declline="80" declcolumn="6"/>
      </memberdef>
      <memberdef kind="function" id="path_8h_1ab4da950c66afd5146b5dca334f510b0c" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>std::string</type>
        <definition>std::string tudat::json_interface::pathAddingPlaceholders</definition>
        <argsstring>(std::string path)</argsstring>
        <name>pathAddingPlaceholders</name>
        <param>
          <type>std::string</type>
          <declname>path</declname>
        </param>
        <briefdescription>
<para>Return <computeroutput>path</computeroutput> with the recognized paths replaced by placeholders (such as ${TUDAT_ROOT_PATH}). </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>path</parametername>
</parameternamelist>
<parameterdescription>
<para>Path without placeholders. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Path with placeholders. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/Users/jonashener/tudatpy_dev/tudat-bundle/tudat/src/interface/json/support/path.cpp" line="23" column="13" bodyfile="/Users/jonashener/tudatpy_dev/tudat-bundle/tudat/src/interface/json/support/path.cpp" bodystart="23" bodyend="38" declfile="/Users/jonashener/tudatpy_dev/tudat-bundle/tudat/include/tudat/interface/json/support/path.h" declline="40" declcolumn="13"/>
      </memberdef>
      <memberdef kind="function" id="path_8h_1aafcaf20255b58021863712680a81886c" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>std::string</type>
        <definition>std::string tudat::json_interface::pathRemovingPlaceholders</definition>
        <argsstring>(std::string path)</argsstring>
        <name>pathRemovingPlaceholders</name>
        <param>
          <type>std::string</type>
          <declname>path</declname>
        </param>
        <briefdescription>
<para>Return <computeroutput>path</computeroutput> with the recognized path placeholders (such as ${TUDAT_ROOT_PATH}) replaced by the actual paths. </para>
        </briefdescription>
        <detaileddescription>
<para>If any of the placeholders is not recognized, it will not be replaced and no warning or error will be generated. <parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>path</parametername>
</parameternamelist>
<parameterdescription>
<para>Path with placeholders. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Path without placeholders. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/Users/jonashener/tudatpy_dev/tudat-bundle/tudat/src/interface/json/support/path.cpp" line="41" column="13" bodyfile="/Users/jonashener/tudatpy_dev/tudat-bundle/tudat/src/interface/json/support/path.cpp" bodystart="41" bodyend="51" declfile="/Users/jonashener/tudatpy_dev/tudat-bundle/tudat/include/tudat/interface/json/support/path.h" declline="49" declcolumn="13"/>
      </memberdef>
      <memberdef kind="function" id="interface_2json_2support_2utilities_8h_1a875400e34f8e428774d96860a8c6224f" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename T</type>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void tudat::json_interface::split</definition>
        <argsstring>(const std::string &amp;string, const char delimiter, const bool trimSpaces, T result)</argsstring>
        <name>split</name>
        <param>
          <type>const std::string &amp;</type>
          <declname>string</declname>
        </param>
        <param>
          <type>const char</type>
          <declname>delimiter</declname>
        </param>
        <param>
          <type>const bool</type>
          <declname>trimSpaces</declname>
        </param>
        <param>
          <type>T</type>
          <declname>result</declname>
        </param>
        <briefdescription>
<para>Split <computeroutput>string</computeroutput> using <computeroutput>delimiter</computeroutput>. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/Users/jonashener/tudatpy_dev/tudat-bundle/tudat/include/tudat/interface/json/support/utilities.h" line="35" column="6" bodyfile="/Users/jonashener/tudatpy_dev/tudat-bundle/tudat/include/tudat/interface/json/support/utilities.h" bodystart="35" bodyend="44"/>
      </memberdef>
      <memberdef kind="function" id="interface_2json_2support_2utilities_8h_1ae125a6aa546881e82b48be8a91d0a2e0" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>std::vector&lt; std::string &gt;</type>
        <definition>std::vector&lt; std::string &gt; tudat::json_interface::split</definition>
        <argsstring>(const std::string &amp;string, const char delimiter, const bool trim=true)</argsstring>
        <name>split</name>
        <param>
          <type>const std::string &amp;</type>
          <declname>string</declname>
        </param>
        <param>
          <type>const char</type>
          <declname>delimiter</declname>
        </param>
        <param>
          <type>const bool</type>
          <declname>trim</declname>
          <defval>true</defval>
        </param>
        <briefdescription>
<para>Get a vector containing the parts resulting from splitting <computeroutput>string</computeroutput> using <computeroutput>delimiter</computeroutput>. </para>
        </briefdescription>
        <detaileddescription>
<para>Get a vector containing the parts resulting from splitting <computeroutput>string</computeroutput> using <computeroutput>delimiter</computeroutput>. <parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>string</parametername>
</parameternamelist>
<parameterdescription>
<para>The string to be splitted. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>delimiter</parametername>
</parameternamelist>
<parameterdescription>
<para>The delimiter to be used. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>trim</parametername>
</parameternamelist>
<parameterdescription>
<para>Whether to remove leading and trailing spaces from the returned strings. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Vector containing the parts resulting from splitting <computeroutput>string</computeroutput> using <computeroutput>delimiter</computeroutput>. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/Users/jonashener/tudatpy_dev/tudat-bundle/tudat/include/tudat/interface/json/support/utilities.h" line="54" column="20" bodyfile="/Users/jonashener/tudatpy_dev/tudat-bundle/tudat/include/tudat/interface/json/support/utilities.h" bodystart="54" bodyend="59"/>
      </memberdef>
      <memberdef kind="function" id="interface_2json_2support_2utilities_8h_1a2cf15b64313a8412626ea05de11d804d" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename K</type>
          </param>
          <param>
            <type>typename V</type>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void tudat::json_interface::reduceToLast</definition>
        <argsstring>(std::map&lt; K, V &gt; map)</argsstring>
        <name>reduceToLast</name>
        <param>
          <type>std::map&lt; K, V &gt;</type>
          <declname>map</declname>
        </param>
        <briefdescription>
<para>Remove all entries of <computeroutput>map</computeroutput> except the last one. </para>
        </briefdescription>
        <detaileddescription>
<para>If <computeroutput>map</computeroutput> is empty, this function does nothing. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/Users/jonashener/tudatpy_dev/tudat-bundle/tudat/include/tudat/interface/json/support/utilities.h" line="66" column="6" bodyfile="/Users/jonashener/tudatpy_dev/tudat-bundle/tudat/include/tudat/interface/json/support/utilities.h" bodystart="66" bodyend="72"/>
      </memberdef>
      <memberdef kind="function" id="interface_2json_2support_2utilities_8h_1aeeb2819f37ea14ead5baa55d33163965" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename K</type>
          </param>
          <param>
            <type>typename V</type>
          </param>
        </templateparamlist>
        <type>K</type>
        <definition>K tudat::json_interface::getKeyWithValue</definition>
        <argsstring>(const std::map&lt; K, V &gt; &amp;map, const V &amp;value)</argsstring>
        <name>getKeyWithValue</name>
        <param>
          <type>const std::map&lt; K, V &gt; &amp;</type>
          <declname>map</declname>
        </param>
        <param>
          <type>const V &amp;</type>
          <declname>value</declname>
        </param>
        <briefdescription>
<para>The key of <computeroutput>map</computeroutput> containing <computeroutput>value</computeroutput>. </para>
        </briefdescription>
        <detaileddescription>
<para><simplesect kind="return"><para></para>
</simplesect>
<parameterlist kind="exception"><parameteritem>
<parameternamelist>
<parametername>std::runtime_error</parametername>
</parameternamelist>
<parameterdescription>
<para>If <computeroutput>map</computeroutput> does not contain <computeroutput>value</computeroutput>. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/Users/jonashener/tudatpy_dev/tudat-bundle/tudat/include/tudat/interface/json/support/utilities.h" line="80" column="3" bodyfile="/Users/jonashener/tudatpy_dev/tudat-bundle/tudat/include/tudat/interface/json/support/utilities.h" bodystart="80" bodyend="90"/>
      </memberdef>
      <memberdef kind="function" id="interface_2json_2support_2utilities_8h_1a935041833385b3c1c2e3305bcfa763d9" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename T</type>
          </param>
        </templateparamlist>
        <type>bool</type>
        <definition>bool tudat::json_interface::isNaN</definition>
        <argsstring>(const T &amp;value)</argsstring>
        <name>isNaN</name>
        <param>
          <type>const T &amp;</type>
          <declname>value</declname>
        </param>
        <briefdescription>
<para>Whether <computeroutput>value</computeroutput> is NaN. </para>
        </briefdescription>
        <detaileddescription>
<para><simplesect kind="return"><para></para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/Users/jonashener/tudatpy_dev/tudat-bundle/tudat/include/tudat/interface/json/support/utilities.h" line="97" column="6" bodyfile="/Users/jonashener/tudatpy_dev/tudat-bundle/tudat/include/tudat/interface/json/support/utilities.h" bodystart="97" bodyend="100"/>
      </memberdef>
      <memberdef kind="function" id="interface_2json_2support_2utilities_8h_1a2afea15c166ba4270c6b0ff52b381080" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename T</type>
          </param>
        </templateparamlist>
        <type>bool</type>
        <definition>bool tudat::json_interface::contains</definition>
        <argsstring>(const std::vector&lt; T &gt; &amp;vector, const T &amp;value)</argsstring>
        <name>contains</name>
        <param>
          <type>const std::vector&lt; T &gt; &amp;</type>
          <declname>vector</declname>
        </param>
        <param>
          <type>const T &amp;</type>
          <declname>value</declname>
        </param>
        <briefdescription>
<para>Whether <computeroutput>vector</computeroutput> contains <computeroutput>value</computeroutput>. </para>
        </briefdescription>
        <detaileddescription>
<para><simplesect kind="return"><para></para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/Users/jonashener/tudatpy_dev/tudat-bundle/tudat/include/tudat/interface/json/support/utilities.h" line="107" column="6" bodyfile="/Users/jonashener/tudatpy_dev/tudat-bundle/tudat/include/tudat/interface/json/support/utilities.h" bodystart="107" bodyend="110"/>
      </memberdef>
      <memberdef kind="function" id="interface_2json_2support_2utilities_8h_1a6befde0a41351b9cab51191455021cd9" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename T</type>
          </param>
        </templateparamlist>
        <type>bool</type>
        <definition>bool tudat::json_interface::containsAnyOf</definition>
        <argsstring>(const std::vector&lt; T &gt; &amp;vector, std::vector&lt; T &gt; values)</argsstring>
        <name>containsAnyOf</name>
        <param>
          <type>const std::vector&lt; T &gt; &amp;</type>
          <declname>vector</declname>
        </param>
        <param>
          <type>std::vector&lt; T &gt;</type>
          <declname>values</declname>
        </param>
        <briefdescription>
<para>Whether <computeroutput>vector</computeroutput> contains any of <computeroutput>values</computeroutput>. </para>
        </briefdescription>
        <detaileddescription>
<para><simplesect kind="return"><para></para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/Users/jonashener/tudatpy_dev/tudat-bundle/tudat/include/tudat/interface/json/support/utilities.h" line="117" column="6" bodyfile="/Users/jonashener/tudatpy_dev/tudat-bundle/tudat/include/tudat/interface/json/support/utilities.h" bodystart="117" bodyend="127"/>
      </memberdef>
      <memberdef kind="function" id="interface_2json_2support_2utilities_8h_1ace3ce4cd907ae9bb0520fb40404bb36b" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename T</type>
          </param>
        </templateparamlist>
        <type>bool</type>
        <definition>bool tudat::json_interface::containsAllOf</definition>
        <argsstring>(const std::vector&lt; T &gt; &amp;vector, std::vector&lt; T &gt; values)</argsstring>
        <name>containsAllOf</name>
        <param>
          <type>const std::vector&lt; T &gt; &amp;</type>
          <declname>vector</declname>
        </param>
        <param>
          <type>std::vector&lt; T &gt;</type>
          <declname>values</declname>
        </param>
        <briefdescription>
<para>Whether <computeroutput>vector</computeroutput> contains all of <computeroutput>values</computeroutput>. </para>
        </briefdescription>
        <detaileddescription>
<para><simplesect kind="return"><para></para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/Users/jonashener/tudatpy_dev/tudat-bundle/tudat/include/tudat/interface/json/support/utilities.h" line="134" column="6" bodyfile="/Users/jonashener/tudatpy_dev/tudat-bundle/tudat/include/tudat/interface/json/support/utilities.h" bodystart="134" bodyend="144"/>
      </memberdef>
      <memberdef kind="function" id="interface_2json_2support_2utilities_8h_1a03bcbba4073a60379d36d130de4553db" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>template&lt; typename ... &gt; class</type>
            <declname>MapType</declname>
            <defname>MapType</defname>
          </param>
          <param>
            <type>typename KeyType</type>
          </param>
          <param>
            <type>typename ValueType</type>
          </param>
        </templateparamlist>
        <type>std::vector&lt; KeyType &gt;</type>
        <definition>std::vector&lt; KeyType &gt; tudat::json_interface::getMapKeys</definition>
        <argsstring>(const MapType&lt; KeyType, ValueType &gt; &amp;map)</argsstring>
        <name>getMapKeys</name>
        <param>
          <type>const MapType&lt; KeyType, ValueType &gt; &amp;</type>
          <declname>map</declname>
        </param>
        <briefdescription>
<para>Get a vector containing the keys of an (un)ordered map. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/Users/jonashener/tudatpy_dev/tudat-bundle/tudat/include/tudat/interface/json/support/utilities.h" line="151" column="13" bodyfile="/Users/jonashener/tudatpy_dev/tudat-bundle/tudat/include/tudat/interface/json/support/utilities.h" bodystart="151" bodyend="159"/>
      </memberdef>
      <memberdef kind="function" id="interface_2json_2support_2utilities_8h_1ab393ba2534bf9ef1b10c5d547290a0df" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>template&lt; typename ... &gt; class</type>
            <declname>MapType</declname>
            <defname>MapType</defname>
          </param>
          <param>
            <type>typename KeyType</type>
          </param>
          <param>
            <type>typename ValueType</type>
          </param>
        </templateparamlist>
        <type>std::vector&lt; ValueType &gt;</type>
        <definition>std::vector&lt; ValueType &gt; tudat::json_interface::getMapValues</definition>
        <argsstring>(const MapType&lt; KeyType, ValueType &gt; &amp;map)</argsstring>
        <name>getMapValues</name>
        <param>
          <type>const MapType&lt; KeyType, ValueType &gt; &amp;</type>
          <declname>map</declname>
        </param>
        <briefdescription>
<para>Get a vector containing the values of an (un)ordered map. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/Users/jonashener/tudatpy_dev/tudat-bundle/tudat/include/tudat/interface/json/support/utilities.h" line="166" column="13" bodyfile="/Users/jonashener/tudatpy_dev/tudat-bundle/tudat/include/tudat/interface/json/support/utilities.h" bodystart="166" bodyend="174"/>
      </memberdef>
      <memberdef kind="function" id="interface_2json_2support_2utilities_8h_1a4aa0c70640bd46f2025062b9e5b0564b" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>template&lt; typename ... &gt; class</type>
            <declname>MapType</declname>
            <defname>MapType</defname>
          </param>
          <param>
            <type>typename KeyType</type>
          </param>
          <param>
            <type>typename ValueType</type>
          </param>
        </templateparamlist>
        <type>std::vector&lt; ValueType &gt;</type>
        <definition>std::vector&lt; ValueType &gt; tudat::json_interface::getFlattenedMapValues</definition>
        <argsstring>(const MapType&lt; KeyType, std::vector&lt; ValueType &gt; &gt; &amp;map)</argsstring>
        <name>getFlattenedMapValues</name>
        <param>
          <type>const MapType&lt; KeyType, std::vector&lt; ValueType &gt; &gt; &amp;</type>
          <declname>map</declname>
        </param>
        <briefdescription>
<para>Get a vector containing the concatenated values of the vectors of an (un)ordered map. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/Users/jonashener/tudatpy_dev/tudat-bundle/tudat/include/tudat/interface/json/support/utilities.h" line="181" column="13" bodyfile="/Users/jonashener/tudatpy_dev/tudat-bundle/tudat/include/tudat/interface/json/support/utilities.h" bodystart="181" bodyend="192"/>
      </memberdef>
      <memberdef kind="function" id="interface_2json_2support_2utilities_8h_1a7a0d47e3c538af548dc158c997b59570" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>std::string</type>
        <definition>std::string tudat::json_interface::url_encode</definition>
        <argsstring>(const std::string &amp;value)</argsstring>
        <name>url_encode</name>
        <param>
          <type>const std::string &amp;</type>
          <declname>value</declname>
        </param>
        <briefdescription>
<para>Encode a string for use in an URL. </para>
        </briefdescription>
        <detaileddescription>
<para>Reference: <ulink url="https://stackoverflow.com/questions/154536/encode-decode-urls-in-c">https://stackoverflow.com/questions/154536/encode-decode-urls-in-c</ulink> </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/Users/jonashener/tudatpy_dev/tudat-bundle/tudat/include/tudat/interface/json/support/utilities.h" line="198" column="20" bodyfile="/Users/jonashener/tudatpy_dev/tudat-bundle/tudat/include/tudat/interface/json/support/utilities.h" bodystart="198" bodyend="223"/>
      </memberdef>
      <memberdef kind="function" id="valueAccess_8h_1ade3a887c70ba6522d037604e01c27d96" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>nlohmann::json &amp;</type>
        <definition>nlohmann::json &amp; tudat::json_interface::valueAt</definition>
        <argsstring>(nlohmann::json &amp;jsonObject, const std::string &amp;key, const bool mutator=false)</argsstring>
        <name>valueAt</name>
        <param>
          <type>nlohmann::json &amp;</type>
          <declname>jsonObject</declname>
        </param>
        <param>
          <type>const std::string &amp;</type>
          <declname>key</declname>
        </param>
        <param>
          <type>const bool</type>
          <declname>mutator</declname>
          <defval>false</defval>
        </param>
        <briefdescription>
<para>Access/mutate a key of a <computeroutput>json</computeroutput> object or array. </para>
        </briefdescription>
        <detaileddescription>
<para>Access/mutate a key of a <computeroutput>json</computeroutput> object or array. <computeroutput>jsonObject</computeroutput> is passed by reference and the returned value is a reference, so this method can be used to mutate a <computeroutput>jsonObject</computeroutput> (e.g. <computeroutput>valueAt( jsonObject, myKey, true ) = newValue</computeroutput>). This only works if the third argument is <computeroutput>true</computeroutput>. If it isn&apos;t, and the key does not exist, an error will be thrown. Supports json arrays. If the field &quot;key&quot; does not exist, this function will try to convert it to integer and access <computeroutput>jsonObject</computeroutput> at that index. <parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>jsonObject</parametername>
</parameternamelist>
<parameterdescription>
<para>The <computeroutput>json</computeroutput> object. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>key</parametername>
</parameternamelist>
<parameterdescription>
<para>The key to access. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>mutator</parametername>
</parameternamelist>
<parameterdescription>
<para>Whether to use mutator or accessor methods. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>A reference to the value of the accessed key (will be a nullptr <computeroutput>json</computeroutput> if the key did not exist). </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/Users/jonashener/tudatpy_dev/tudat-bundle/tudat/src/interface/json/support/valueAccess.cpp" line="25" column="16" bodyfile="/Users/jonashener/tudatpy_dev/tudat-bundle/tudat/src/interface/json/support/valueAccess.cpp" bodystart="25" bodyend="50" declfile="/Users/jonashener/tudatpy_dev/tudat-bundle/tudat/include/tudat/interface/json/support/valueAccess.h" declline="48" declcolumn="16"/>
      </memberdef>
      <memberdef kind="function" id="valueAccess_8h_1a68873f27b13b0432f4f66b892fec49fb" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>nlohmann::json</type>
        <definition>nlohmann::json tudat::json_interface::valueAt</definition>
        <argsstring>(nlohmann::json jsonObject, const KeyPath &amp;keyPath)</argsstring>
        <name>valueAt</name>
        <param>
          <type>nlohmann::json</type>
          <declname>jsonObject</declname>
        </param>
        <param>
          <type>const <ref refid="classtudat_1_1json__interface_1_1KeyPath" kindref="compound">KeyPath</ref> &amp;</type>
          <declname>keyPath</declname>
        </param>
        <briefdescription>
<para>Access a key path of a <computeroutput>json</computeroutput> object or array. </para>
        </briefdescription>
        <detaileddescription>
<para>Access a key path of a <computeroutput>json</computeroutput> object or array. <computeroutput>jsonObject</computeroutput> is constant, so the returned value cannot be modified. Supports json arrays. If the any key in <computeroutput>keyPath</computeroutput> does not exist, this function will try to convert it to integer and access <computeroutput>jsonObject</computeroutput> at that index. <parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>jsonObject</parametername>
</parameternamelist>
<parameterdescription>
<para>The constant <computeroutput>json</computeroutput> object. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>keyPath</parametername>
</parameternamelist>
<parameterdescription>
<para>The key path to access. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>The value at the accessed key path. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/Users/jonashener/tudatpy_dev/tudat-bundle/tudat/src/interface/json/support/valueAccess.cpp" line="53" column="16" bodyfile="/Users/jonashener/tudatpy_dev/tudat-bundle/tudat/src/interface/json/support/valueAccess.cpp" bodystart="53" bodyend="60" declfile="/Users/jonashener/tudatpy_dev/tudat-bundle/tudat/include/tudat/interface/json/support/valueAccess.h" declline="59" declcolumn="16"/>
      </memberdef>
      <memberdef kind="function" id="valueAccess_8h_1aefd945fa26bf0d9e947dd5b5aae9274c" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>bool</type>
        <definition>bool tudat::json_interface::isDefined</definition>
        <argsstring>(const nlohmann::json &amp;jsonObject, const KeyPath &amp;keyPath)</argsstring>
        <name>isDefined</name>
        <param>
          <type>const nlohmann::json &amp;</type>
          <declname>jsonObject</declname>
        </param>
        <param>
          <type>const <ref refid="classtudat_1_1json__interface_1_1KeyPath" kindref="compound">KeyPath</ref> &amp;</type>
          <declname>keyPath</declname>
        </param>
        <briefdescription>
<para>Whether the key at <computeroutput>keyPath</computeroutput> is defined for <computeroutput>jsonObject</computeroutput>. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>jsonObject</parametername>
</parameternamelist>
<parameterdescription>
<para>The <computeroutput>json</computeroutput> object. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>keyPath</parametername>
</parameternamelist>
<parameterdescription>
<para>The key path specifying to key to be checked. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para></para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/Users/jonashener/tudatpy_dev/tudat-bundle/tudat/src/interface/json/support/valueAccess.cpp" line="63" column="6" bodyfile="/Users/jonashener/tudatpy_dev/tudat-bundle/tudat/src/interface/json/support/valueAccess.cpp" bodystart="63" bodyend="74" declfile="/Users/jonashener/tudatpy_dev/tudat-bundle/tudat/include/tudat/interface/json/support/valueAccess.h" declline="68" declcolumn="6"/>
      </memberdef>
      <memberdef kind="function" id="valueAccess_8h_1ac720ad24ad1bbfa3418a8707fa25d81d" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>nlohmann::json</type>
        <definition>nlohmann::json tudat::json_interface::getRootObject</definition>
        <argsstring>(const nlohmann::json &amp;jsonObject)</argsstring>
        <name>getRootObject</name>
        <param>
          <type>const nlohmann::json &amp;</type>
          <declname>jsonObject</declname>
        </param>
        <briefdescription>
<para>Get the <computeroutput>jsonObject</computeroutput> at key SpecialKeys::rootObject. </para>
        </briefdescription>
        <detaileddescription>
<para>Get the a shared pointer to <computeroutput>jsonObject</computeroutput> at key SpecialKeys::rootObject.</para>
<para>copybrief getRootObject <parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>jsonObject</parametername>
</parameternamelist>
<parameterdescription>
<para>The <computeroutput>json</computeroutput> object. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>JSON representation of the root object of <computeroutput>jsonObject</computeroutput>. </para>
</simplesect>
<parameterlist kind="exception"><parameteritem>
<parameternamelist>
<parametername><ref refid="classtudat_1_1json__interface_1_1UndefinedKeyError" kindref="compound">UndefinedKeyError</ref></parametername>
</parameternamelist>
<parameterdescription>
<para>If the key SpecialKeys::rootObject is not defined for <computeroutput>jsonObject</computeroutput>. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/Users/jonashener/tudatpy_dev/tudat-bundle/tudat/src/interface/json/support/valueAccess.cpp" line="80" column="16" bodyfile="/Users/jonashener/tudatpy_dev/tudat-bundle/tudat/src/interface/json/support/valueAccess.cpp" bodystart="80" bodyend="83" declfile="/Users/jonashener/tudatpy_dev/tudat-bundle/tudat/include/tudat/interface/json/support/valueAccess.h" declline="80" declcolumn="16"/>
      </memberdef>
      <memberdef kind="function" id="valueAccess_8h_1af95758d3acd3049fa311888333715883" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classtudat_1_1json__interface_1_1KeyPath" kindref="compound">KeyPath</ref></type>
        <definition>KeyPath tudat::json_interface::getKeyPath</definition>
        <argsstring>(const nlohmann::json &amp;jsonObject)</argsstring>
        <name>getKeyPath</name>
        <param>
          <type>const nlohmann::json &amp;</type>
          <declname>jsonObject</declname>
        </param>
        <briefdescription>
<para>Get the absolute key path from which <computeroutput>jsonObject</computeroutput> was retrieved. </para>
        </briefdescription>
        <detaileddescription>
<para>copybrief getKeyPath <parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>jsonObject</parametername>
</parameternamelist>
<parameterdescription>
<para>The <computeroutput>json</computeroutput> object. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Absolute key path from which <computeroutput>jsonObject</computeroutput> was retrieved. </para>
</simplesect>
<parameterlist kind="exception"><parameteritem>
<parameternamelist>
<parametername><ref refid="classtudat_1_1json__interface_1_1UndefinedKeyError" kindref="compound">UndefinedKeyError</ref></parametername>
</parameternamelist>
<parameterdescription>
<para>If the key SpecialKeys::keyPath is not defined for <computeroutput>jsonObject</computeroutput>. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/Users/jonashener/tudatpy_dev/tudat-bundle/tudat/src/interface/json/support/valueAccess.cpp" line="86" column="9" bodyfile="/Users/jonashener/tudatpy_dev/tudat-bundle/tudat/src/interface/json/support/valueAccess.cpp" bodystart="86" bodyend="89" declfile="/Users/jonashener/tudatpy_dev/tudat-bundle/tudat/include/tudat/interface/json/support/valueAccess.h" declline="89" declcolumn="9"/>
      </memberdef>
      <memberdef kind="function" id="valueAccess_8h_1a858fde11c329ab47223ee3e7a90e36e4" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>std::string</type>
        <definition>std::string tudat::json_interface::getParentKey</definition>
        <argsstring>(const nlohmann::json &amp;jsonObject, const std::string &amp;errorMessage=&quot;Could not determine parent key: context is missing.&quot;)</argsstring>
        <name>getParentKey</name>
        <param>
          <type>const nlohmann::json &amp;</type>
          <declname>jsonObject</declname>
        </param>
        <param>
          <type>const std::string &amp;</type>
          <declname>errorMessage</declname>
          <defval>&quot;Could not determine parent key: context is missing.&quot;</defval>
        </param>
        <briefdescription>
<para>Get the key at which <computeroutput>jsonObject</computeroutput> was obtained. </para>
        </briefdescription>
        <detaileddescription>
<para>copybrief getParentKey <parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>jsonObject</parametername>
</parameternamelist>
<parameterdescription>
<para>The <computeroutput>json</computeroutput> object. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>errorMessage</parametername>
</parameternamelist>
<parameterdescription>
<para>Error message to be printed if <computeroutput>jsonObject</computeroutput> has no key SpecialKeys::keyPath. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Key at which <computeroutput>jsonObject</computeroutput> was obtained. </para>
</simplesect>
<parameterlist kind="exception"><parameteritem>
<parameternamelist>
<parametername><ref refid="classtudat_1_1json__interface_1_1UndefinedKeyError" kindref="compound">UndefinedKeyError</ref></parametername>
</parameternamelist>
<parameterdescription>
<para>If the key SpecialKeys::keyPath is not defined for <computeroutput>jsonObject</computeroutput>. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/Users/jonashener/tudatpy_dev/tudat-bundle/tudat/src/interface/json/support/valueAccess.cpp" line="92" column="13" bodyfile="/Users/jonashener/tudatpy_dev/tudat-bundle/tudat/src/interface/json/support/valueAccess.cpp" bodystart="92" bodyend="103" declfile="/Users/jonashener/tudatpy_dev/tudat-bundle/tudat/include/tudat/interface/json/support/valueAccess.h" declline="99" declcolumn="13"/>
      </memberdef>
      <memberdef kind="function" id="valueAccess_8h_1a93f94e6a4868538b5e6c6a23a6acd0ad" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>ExceptionResponseType</type>
        <definition>ExceptionResponseType tudat::json_interface::getResponseToEvent</definition>
        <argsstring>(const nlohmann::json &amp;jsonObject, const std::string &amp;eventName, const ExceptionResponseType defaultResponse=continueSilently)</argsstring>
        <name>getResponseToEvent</name>
        <param>
          <type>const nlohmann::json &amp;</type>
          <declname>jsonObject</declname>
        </param>
        <param>
          <type>const std::string &amp;</type>
          <declname>eventName</declname>
        </param>
        <param>
          <type>const ExceptionResponseType</type>
          <declname>defaultResponse</declname>
          <defval>continueSilently</defval>
        </param>
        <briefdescription>
<para>Get the response type to an event for a <computeroutput>json</computeroutput> object. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>jsonObject</parametername>
</parameternamelist>
<parameterdescription>
<para>The <computeroutput>json</computeroutput> object in which the type of response to the event is defined, or a <computeroutput>json</computeroutput> object with a root object containing this information. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>eventName</parametername>
</parameternamelist>
<parameterdescription>
<para>The name of the event. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>defaultResponse</parametername>
</parameternamelist>
<parameterdescription>
<para>Default response if the response to the event is not defined. By default, continueSilently. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Response type to the event. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/Users/jonashener/tudatpy_dev/tudat-bundle/tudat/src/interface/json/support/valueAccess.cpp" line="106" column="23" bodyfile="/Users/jonashener/tudatpy_dev/tudat-bundle/tudat/src/interface/json/support/valueAccess.cpp" bodystart="106" bodyend="122" declfile="/Users/jonashener/tudatpy_dev/tudat-bundle/tudat/include/tudat/interface/json/support/valueAccess.h" declline="111" declcolumn="23"/>
      </memberdef>
      <memberdef kind="function" id="valueAccess_8h_1aca83f96284dc056f3242318470351acf" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>void</type>
        <definition>void tudat::json_interface::clearAccessHistory</definition>
        <argsstring>()</argsstring>
        <name>clearAccessHistory</name>
        <briefdescription>
<para>Clear the global variable accessedKeyPaths. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/Users/jonashener/tudatpy_dev/tudat-bundle/tudat/include/tudat/interface/json/support/valueAccess.h" line="125" column="13" bodyfile="/Users/jonashener/tudatpy_dev/tudat-bundle/tudat/include/tudat/interface/json/support/valueAccess.h" bodystart="125" bodyend="128"/>
      </memberdef>
      <memberdef kind="function" id="valueAccess_8h_1aaf7bf5bca1e6b879867a1e857d6ce25f" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void tudat::json_interface::checkUnusedKeys</definition>
        <argsstring>(const nlohmann::json &amp;jsonObject, const ExceptionResponseType response)</argsstring>
        <name>checkUnusedKeys</name>
        <param>
          <type>const nlohmann::json &amp;</type>
          <declname>jsonObject</declname>
        </param>
        <param>
          <type>const ExceptionResponseType</type>
          <declname>response</declname>
        </param>
        <briefdescription>
<para>Check for key paths that are defined in <computeroutput>jsonObject</computeroutput> but not contained by the global variable accessedKeyPaths. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>jsonObject</parametername>
</parameternamelist>
<parameterdescription>
<para>The <computeroutput>json</computeroutput> object. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>response</parametername>
</parameternamelist>
<parameterdescription>
<para>Response type when finding unused keys in <computeroutput>jsonObject</computeroutput>. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="exception"><parameteritem>
<parameternamelist>
<parametername>std::runtime_error</parametername>
</parameternamelist>
<parameterdescription>
<para>If <computeroutput>response</computeroutput> is set to ExceptionResponseType::throwError and at least one unsued key was found in <computeroutput>jsonObject</computeroutput>. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/Users/jonashener/tudatpy_dev/tudat-bundle/tudat/src/interface/json/support/valueAccess.cpp" line="162" column="6" bodyfile="/Users/jonashener/tudatpy_dev/tudat-bundle/tudat/src/interface/json/support/valueAccess.cpp" bodystart="162" bodyend="181" declfile="/Users/jonashener/tudatpy_dev/tudat-bundle/tudat/include/tudat/interface/json/support/valueAccess.h" declline="138" declcolumn="6"/>
      </memberdef>
      <memberdef kind="function" id="valueAccess_8h_1a73cd37db5b9dd920c5c1e1863c8a6e7a" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void tudat::json_interface::convertToObjectIfContainsObjects</definition>
        <argsstring>(nlohmann::json &amp;j)</argsstring>
        <name>convertToObjectIfContainsObjects</name>
        <param>
          <type>nlohmann::json &amp;</type>
          <declname>j</declname>
        </param>
        <briefdescription>
<para>Convert <computeroutput>j</computeroutput> to object if <computeroutput>j</computeroutput> is an array containing objects. </para>
        </briefdescription>
        <detaileddescription>
<para>This method does nothing if <computeroutput>j</computeroutput> is not an array, if <computeroutput>j</computeroutput> is empty, or if the elements (and subelements) of <computeroutput>j</computeroutput> are not of type object. <parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>j</parametername>
</parameternamelist>
<parameterdescription>
<para><computeroutput>json</computeroutput> object to be converted, or the original <computeroutput>j</computeroutput>. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/Users/jonashener/tudatpy_dev/tudat-bundle/tudat/src/interface/json/support/valueAccess.cpp" line="208" column="6" bodyfile="/Users/jonashener/tudatpy_dev/tudat-bundle/tudat/src/interface/json/support/valueAccess.cpp" bodystart="208" bodyend="225" declfile="/Users/jonashener/tudatpy_dev/tudat-bundle/tudat/include/tudat/interface/json/support/valueAccess.h" declline="149" declcolumn="6"/>
      </memberdef>
      <memberdef kind="function" id="valueAccess_8h_1a6cf2b3531b1a80775c4e9fa0e3c6b05f" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>nlohmann::json</type>
        <definition>nlohmann::json tudat::json_interface::getAsArray</definition>
        <argsstring>(const nlohmann::json &amp;jsonObject)</argsstring>
        <name>getAsArray</name>
        <param>
          <type>const nlohmann::json &amp;</type>
          <declname>jsonObject</declname>
        </param>
        <briefdescription>
<para>Convert <computeroutput>jsonObject</computeroutput> to a json array. </para>
        </briefdescription>
        <detaileddescription>
<para>Convert <computeroutput>jsonObject</computeroutput> to a json array. Does nothing if <computeroutput>jsonObject</computeroutput> is already an array. If <computeroutput>jsonObject</computeroutput> is an object whose (non-special) keys are all convertible to unsigned int, the equivalent <computeroutput>json</computeroutput> array will be returned. Otherise, the original <computeroutput>jsonObject</computeroutput> is returned. <parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>jsonObject</parametername>
</parameternamelist>
<parameterdescription>
<para>The <computeroutput>json</computeroutput> object to be converted. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para><computeroutput>jsonObject</computeroutput> as a json array, or the original <computeroutput>jsonObject</computeroutput> if it is not convertible to array. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/Users/jonashener/tudatpy_dev/tudat-bundle/tudat/src/interface/json/support/valueAccess.cpp" line="228" column="16" bodyfile="/Users/jonashener/tudatpy_dev/tudat-bundle/tudat/src/interface/json/support/valueAccess.cpp" bodystart="228" bodyend="275" declfile="/Users/jonashener/tudatpy_dev/tudat-bundle/tudat/include/tudat/interface/json/support/valueAccess.h" declline="159" declcolumn="16"/>
      </memberdef>
      <memberdef kind="function" id="valueAccess_8h_1ac1e109e36d77f50e3047b17d5f9aa24e" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>bool</type>
        <definition>bool tudat::json_interface::isConvertibleToArray</definition>
        <argsstring>(const nlohmann::json &amp;j)</argsstring>
        <name>isConvertibleToArray</name>
        <param>
          <type>const nlohmann::json &amp;</type>
          <declname>j</declname>
        </param>
        <briefdescription>
<para>Whether <computeroutput>j</computeroutput> is convertible to a json array. </para>
        </briefdescription>
        <detaileddescription>
<para>Whether <computeroutput>j</computeroutput> is convertible to a json array. True if <computeroutput>j</computeroutput> is an array or an object whose (non-special) keys are all convertible to unsigned int. <parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>j</parametername>
</parameternamelist>
<parameterdescription>
<para>The <computeroutput>json</computeroutput> object to be checked. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Whether <computeroutput>j</computeroutput> is convertible to a json array. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/Users/jonashener/tudatpy_dev/tudat-bundle/tudat/src/interface/json/support/valueAccess.cpp" line="278" column="6" bodyfile="/Users/jonashener/tudatpy_dev/tudat-bundle/tudat/src/interface/json/support/valueAccess.cpp" bodystart="278" bodyend="281" declfile="/Users/jonashener/tudatpy_dev/tudat-bundle/tudat/include/tudat/interface/json/support/valueAccess.h" declline="168" declcolumn="6"/>
      </memberdef>
      <memberdef kind="function" id="valueAccess_8h_1aaee9fc9743be3764577bb97a95b4ff37" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename ValueType</type>
          </param>
        </templateparamlist>
        <type>ValueType</type>
        <definition>ValueType tudat::json_interface::getValue</definition>
        <argsstring>(const nlohmann::json &amp;jsonObject, const KeyPath &amp;keyPath)</argsstring>
        <name>getValue</name>
        <param>
          <type>const nlohmann::json &amp;</type>
          <declname>jsonObject</declname>
        </param>
        <param>
          <type>const <ref refid="classtudat_1_1json__interface_1_1KeyPath" kindref="compound">KeyPath</ref> &amp;</type>
          <declname>keyPath</declname>
        </param>
        <briefdescription>
<para>Get the value of <computeroutput>jsonObject</computeroutput> at <computeroutput>keyPath</computeroutput>. </para>
        </briefdescription>
        <detaileddescription>
<para>Get the value of <computeroutput>jsonObject</computeroutput> at <computeroutput>keyPath</computeroutput>. <parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>jsonObject</parametername>
</parameternamelist>
<parameterdescription>
<para>The <computeroutput>json</computeroutput> object. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>keyPath</parametername>
</parameternamelist>
<parameterdescription>
<para>Key path from which to retrieve the value. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Value at the requested key path. </para>
</simplesect>
<parameterlist kind="exception"><parameteritem>
<parameternamelist>
<parametername><ref refid="classtudat_1_1json__interface_1_1UndefinedKeyError" kindref="compound">UndefinedKeyError</ref></parametername>
</parameternamelist>
<parameterdescription>
<para>If the requested key path is not defined. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername><ref refid="classtudat_1_1json__interface_1_1UndefinedKeyError" kindref="compound">UndefinedKeyError</ref></parametername>
</parameternamelist>
<parameterdescription>
<para>If some of the subkeys needed to create the shared pointer of <computeroutput>ValueType</computeroutput> are missing (only when <computeroutput>jsonObject</computeroutput> at <computeroutput>keyPath</computeroutput> is of type object). </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>IllegalValueError&lt;ValueType&gt;</parametername>
</parameternamelist>
<parameterdescription>
<para>If the obtained value for the requested key path is not convertible to <computeroutput>ValueType</computeroutput>. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>IllegalValueError&lt;SubvalueType&gt;</parametername>
</parameternamelist>
<parameterdescription>
<para>If some of the subkeys needed to create the shared pointer of <computeroutput>ValueType</computeroutput> are not convertible to <computeroutput>SubvalueType</computeroutput> (only when <computeroutput>jsonObject</computeroutput> at <computeroutput>keyPath</computeroutput> is of type object). </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/Users/jonashener/tudatpy_dev/tudat-bundle/tudat/include/tudat/interface/json/support/valueAccess.h" line="188" column="11" bodyfile="/Users/jonashener/tudatpy_dev/tudat-bundle/tudat/include/tudat/interface/json/support/valueAccess.h" bodystart="188" bodyend="284"/>
      </memberdef>
      <memberdef kind="function" id="valueAccess_8h_1a312e908961ce91177e639d6f3bd805de" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename ValueType</type>
          </param>
        </templateparamlist>
        <type>ValueType</type>
        <definition>ValueType tudat::json_interface::getAs</definition>
        <argsstring>(const nlohmann::json &amp;jsonObject)</argsstring>
        <name>getAs</name>
        <param>
          <type>const nlohmann::json &amp;</type>
          <declname>jsonObject</declname>
        </param>
        <briefdescription>
<para>Convert <computeroutput>jsonObject</computeroutput> to <computeroutput>ValueType</computeroutput>. </para>
        </briefdescription>
        <detaileddescription>
<para>Convert <computeroutput>jsonObject</computeroutput> to <computeroutput>ValueType</computeroutput>. <parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>jsonObject</parametername>
</parameternamelist>
<parameterdescription>
<para>The <computeroutput>json</computeroutput> object. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para><computeroutput>jsonObject</computeroutput> as <computeroutput>ValueType</computeroutput>. </para>
</simplesect>
<parameterlist kind="exception"><parameteritem>
<parameternamelist>
<parametername>IllegalValueError&lt;ValueType&gt;</parametername>
</parameternamelist>
<parameterdescription>
<para>If <computeroutput>jsonObject</computeroutput> is not convertible to <computeroutput>ValueType</computeroutput>. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>IllegalValueError&lt;SubvalueType&gt;</parametername>
</parameternamelist>
<parameterdescription>
<para>If some of the subkeys needed to create the shared pointer of <computeroutput>ValueType</computeroutput> are not convertible to <computeroutput>SubvalueType</computeroutput> (only when <computeroutput>jsonObject</computeroutput> at <computeroutput>keyPath</computeroutput> is of type object). </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/Users/jonashener/tudatpy_dev/tudat-bundle/tudat/include/tudat/interface/json/support/valueAccess.h" line="296" column="11" bodyfile="/Users/jonashener/tudatpy_dev/tudat-bundle/tudat/include/tudat/interface/json/support/valueAccess.h" bodystart="296" bodyend="299"/>
      </memberdef>
      <memberdef kind="function" id="valueAccess_8h_1a53004b395d3a756033ba929091ce92d1" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename ValueType</type>
          </param>
        </templateparamlist>
        <type>ValueType</type>
        <definition>ValueType tudat::json_interface::getValue</definition>
        <argsstring>(const nlohmann::json &amp;jsonObject, const KeyPath &amp;keyPath, const ValueType &amp;defaultValue)</argsstring>
        <name>getValue</name>
        <param>
          <type>const nlohmann::json &amp;</type>
          <declname>jsonObject</declname>
        </param>
        <param>
          <type>const <ref refid="classtudat_1_1json__interface_1_1KeyPath" kindref="compound">KeyPath</ref> &amp;</type>
          <declname>keyPath</declname>
        </param>
        <param>
          <type>const ValueType &amp;</type>
          <declname>defaultValue</declname>
        </param>
        <briefdescription>
<para>Get the value of <computeroutput>jsonObject</computeroutput> at <computeroutput>keyPath</computeroutput>, or return <computeroutput>optionalValue</computeroutput> if not defined. </para>
        </briefdescription>
        <detaileddescription>
<para>Get the value of <computeroutput>jsonObject</computeroutput> at <computeroutput>keyPath</computeroutput>, or return <computeroutput>optionalValue</computeroutput> if not defined. <parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>jsonObject</parametername>
</parameternamelist>
<parameterdescription>
<para>The <computeroutput>json</computeroutput> object. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>keyPath</parametername>
</parameternamelist>
<parameterdescription>
<para>Key path from which to retrieve the value. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>defaultValue</parametername>
</parameternamelist>
<parameterdescription>
<para>The default value to be returned if the key is not defined. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Value at the requested key path, or <computeroutput>optionalValue</computeroutput> if not defined. </para>
</simplesect>
<parameterlist kind="exception"><parameteritem>
<parameternamelist>
<parametername><ref refid="classtudat_1_1json__interface_1_1UndefinedKeyError" kindref="compound">UndefinedKeyError</ref></parametername>
</parameternamelist>
<parameterdescription>
<para>If some of the subkeys needed to create the shared pointer of <computeroutput>ValueType</computeroutput> are missing (only when <computeroutput>jsonObject</computeroutput> at <computeroutput>keyPath</computeroutput> is of type object). </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>IllegalValueError&lt;ValueType&gt;</parametername>
</parameternamelist>
<parameterdescription>
<para>If the obtained value for the requested key path is not convertible to <computeroutput>ValueType</computeroutput>. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>IllegalValueError&lt;SubvalueType&gt;</parametername>
</parameternamelist>
<parameterdescription>
<para>If some of the subkeys needed to create the shared pointer of <computeroutput>ValueType</computeroutput> are not convertible to <computeroutput>SubvalueType</computeroutput> (only when <computeroutput>jsonObject</computeroutput> at <computeroutput>keyPath</computeroutput> is of type object). </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/Users/jonashener/tudatpy_dev/tudat-bundle/tudat/include/tudat/interface/json/support/valueAccess.h" line="316" column="11" bodyfile="/Users/jonashener/tudatpy_dev/tudat-bundle/tudat/include/tudat/interface/json/support/valueAccess.h" bodystart="316" bodyend="329"/>
      </memberdef>
      <memberdef kind="function" id="valueAccess_8h_1a8e235468a203aeb862b60545c81e3017" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename ValueType</type>
          </param>
        </templateparamlist>
        <type>ValueType</type>
        <definition>ValueType tudat::json_interface::getValue</definition>
        <argsstring>(const nlohmann::json &amp;jsonObject, const std::vector&lt; KeyPath &gt; &amp;keyPaths)</argsstring>
        <name>getValue</name>
        <param>
          <type>const nlohmann::json &amp;</type>
          <declname>jsonObject</declname>
        </param>
        <param>
          <type>const std::vector&lt; <ref refid="classtudat_1_1json__interface_1_1KeyPath" kindref="compound">KeyPath</ref> &gt; &amp;</type>
          <declname>keyPaths</declname>
        </param>
        <briefdescription>
<para>Get the value of <computeroutput>jsonObject</computeroutput> at the first defined key path in <computeroutput>keyPaths</computeroutput>. </para>
        </briefdescription>
        <detaileddescription>
<para>Get the value of <computeroutput>jsonObject</computeroutput> at the first defined key path in <computeroutput>keyPaths</computeroutput>. <parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>jsonObject</parametername>
</parameternamelist>
<parameterdescription>
<para>The <computeroutput>json</computeroutput> object. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>keyPaths</parametername>
</parameternamelist>
<parameterdescription>
<para>Vector of key paths from which the value can be retrieved. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Value at the first defined key path in <computeroutput>keyPaths</computeroutput>. </para>
</simplesect>
<parameterlist kind="exception"><parameteritem>
<parameternamelist>
<parametername><ref refid="classtudat_1_1json__interface_1_1UndefinedKeyError" kindref="compound">UndefinedKeyError</ref></parametername>
</parameternamelist>
<parameterdescription>
<para>If all the key paths in <computeroutput>keyPaths</computeroutput> are not defined for <computeroutput>jsonObject</computeroutput>. The printed message will indicate the key path corresponding to the last of <computeroutput>keyPaths</computeroutput>. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername><ref refid="classtudat_1_1json__interface_1_1UndefinedKeyError" kindref="compound">UndefinedKeyError</ref></parametername>
</parameternamelist>
<parameterdescription>
<para>If some of the subkeys needed to create the shared pointer of <computeroutput>ValueType</computeroutput> are missing (only when <computeroutput>jsonObject</computeroutput> at <computeroutput>keyPaths</computeroutput> is of type object). </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>IllegalValueError&lt;ValueType&gt;</parametername>
</parameternamelist>
<parameterdescription>
<para>If the obtained value for the requested key path is not convertible to <computeroutput>ValueType</computeroutput>. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>IllegalValueError&lt;SubvalueType&gt;</parametername>
</parameternamelist>
<parameterdescription>
<para>If some of the subkeys needed to create the shared pointer of <computeroutput>ValueType</computeroutput> are not convertible to <computeroutput>SubvalueType</computeroutput> (only when <computeroutput>jsonObject</computeroutput> at <computeroutput>keyPaths</computeroutput> is of type object). </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/Users/jonashener/tudatpy_dev/tudat-bundle/tudat/include/tudat/interface/json/support/valueAccess.h" line="347" column="11" bodyfile="/Users/jonashener/tudatpy_dev/tudat-bundle/tudat/include/tudat/interface/json/support/valueAccess.h" bodystart="347" bodyend="365"/>
      </memberdef>
      <memberdef kind="function" id="valueAccess_8h_1a45d301d5f3591bc064df9cd3f81b7308" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename T</type>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void tudat::json_interface::updateFromJSON</definition>
        <argsstring>(T &amp;value, const nlohmann::json &amp;jsonObject, const KeyPath &amp;keyPath={ })</argsstring>
        <name>updateFromJSON</name>
        <param>
          <type>T &amp;</type>
          <declname>value</declname>
        </param>
        <param>
          <type>const nlohmann::json &amp;</type>
          <declname>jsonObject</declname>
        </param>
        <param>
          <type>const <ref refid="classtudat_1_1json__interface_1_1KeyPath" kindref="compound">KeyPath</ref> &amp;</type>
          <declname>keyPath</declname>
          <defval>{ }</defval>
        </param>
        <briefdescription>
<para>Set <computeroutput>value</computeroutput> to be the value of <computeroutput>jsonObject</computeroutput> at <computeroutput>keyPath</computeroutput>. </para>
        </briefdescription>
        <detaileddescription>
<para>Set <computeroutput>value</computeroutput> to be the value of <computeroutput>jsonObject</computeroutput> at <computeroutput>keyPath</computeroutput>. <parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>value</parametername>
</parameternamelist>
<parameterdescription>
<para>The value to be updated (i.e. re-initialized). </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>jsonObject</parametername>
</parameternamelist>
<parameterdescription>
<para>The <computeroutput>json</computeroutput> object. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>keyPath</parametername>
</parameternamelist>
<parameterdescription>
<para>Key path from which to retrieve the value. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="exception"><parameteritem>
<parameternamelist>
<parametername><ref refid="classtudat_1_1json__interface_1_1UndefinedKeyError" kindref="compound">UndefinedKeyError</ref></parametername>
</parameternamelist>
<parameterdescription>
<para>If the requested key path is not defined. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername><ref refid="classtudat_1_1json__interface_1_1UndefinedKeyError" kindref="compound">UndefinedKeyError</ref></parametername>
</parameternamelist>
<parameterdescription>
<para>If some of the subkeys needed to create the shared pointer of <computeroutput>ValueType</computeroutput> are missing (only when <computeroutput>jsonObject</computeroutput> at <computeroutput>keyPath</computeroutput> is of type object). </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>IllegalValueError&lt;ValueType&gt;</parametername>
</parameternamelist>
<parameterdescription>
<para>If the obtained value for the requested key path is not convertible to <computeroutput>ValueType</computeroutput>. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>IllegalValueError&lt;SubvalueType&gt;</parametername>
</parameternamelist>
<parameterdescription>
<para>If some of the subkeys needed to create the shared pointer of <computeroutput>ValueType</computeroutput> are not convertible to <computeroutput>SubvalueType</computeroutput> (only when <computeroutput>jsonObject</computeroutput> at <computeroutput>keyPath</computeroutput> is of type object). </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/Users/jonashener/tudatpy_dev/tudat-bundle/tudat/include/tudat/interface/json/support/valueAccess.h" line="385" column="6" bodyfile="/Users/jonashener/tudatpy_dev/tudat-bundle/tudat/include/tudat/interface/json/support/valueAccess.h" bodystart="385" bodyend="388"/>
      </memberdef>
      <memberdef kind="function" id="valueAccess_8h_1a5e0ffe276fdb38a96e8e2b70016614f2" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename T</type>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void tudat::json_interface::updateFromJSONIfDefined</definition>
        <argsstring>(T &amp;value, const nlohmann::json &amp;jsonObject, const KeyPath &amp;keyPath={ })</argsstring>
        <name>updateFromJSONIfDefined</name>
        <param>
          <type>T &amp;</type>
          <declname>value</declname>
        </param>
        <param>
          <type>const nlohmann::json &amp;</type>
          <declname>jsonObject</declname>
        </param>
        <param>
          <type>const <ref refid="classtudat_1_1json__interface_1_1KeyPath" kindref="compound">KeyPath</ref> &amp;</type>
          <declname>keyPath</declname>
          <defval>{ }</defval>
        </param>
        <briefdescription>
<para>Set <computeroutput>value</computeroutput> to be the value of <computeroutput>jsonObject</computeroutput> at <computeroutput>keyPath</computeroutput> if defined. </para>
        </briefdescription>
        <detaileddescription>
<para>Set <computeroutput>value</computeroutput> to be the value of <computeroutput>jsonObject</computeroutput> at <computeroutput>keyPath</computeroutput> if defined. <simplesect kind="remark"><para>This function does nothing if <computeroutput>jsonObject</computeroutput> is not defined at <computeroutput>keyPath</computeroutput>. </para>
</simplesect>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>value</parametername>
</parameternamelist>
<parameterdescription>
<para>The value to be updated (i.e. re-initialized). </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>jsonObject</parametername>
</parameternamelist>
<parameterdescription>
<para>The <computeroutput>json</computeroutput> object. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>keyPath</parametername>
</parameternamelist>
<parameterdescription>
<para>Key path from which to retrieve the value. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="exception"><parameteritem>
<parameternamelist>
<parametername><ref refid="classtudat_1_1json__interface_1_1UndefinedKeyError" kindref="compound">UndefinedKeyError</ref></parametername>
</parameternamelist>
<parameterdescription>
<para>If some of the subkeys needed to create the shared pointer of <computeroutput>ValueType</computeroutput> are missing (only when <computeroutput>jsonObject</computeroutput> at <computeroutput>keyPath</computeroutput> is of type object). </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>IllegalValueError&lt;ValueType&gt;</parametername>
</parameternamelist>
<parameterdescription>
<para>If the obtained value for the requested key path is not convertible to <computeroutput>ValueType</computeroutput>. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>IllegalValueError&lt;SubvalueType&gt;</parametername>
</parameternamelist>
<parameterdescription>
<para>If some of the subkeys needed to create the shared pointer of <computeroutput>ValueType</computeroutput> are not convertible to <computeroutput>SubvalueType</computeroutput> (only when <computeroutput>jsonObject</computeroutput> at <computeroutput>keyPath</computeroutput> is of type object). </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/Users/jonashener/tudatpy_dev/tudat-bundle/tudat/include/tudat/interface/json/support/valueAccess.h" line="405" column="6" bodyfile="/Users/jonashener/tudatpy_dev/tudat-bundle/tudat/include/tudat/interface/json/support/valueAccess.h" bodystart="405" bodyend="415"/>
      </memberdef>
      <memberdef kind="function" id="valueAccess_8h_1a3c32fe47d8d9bc559d527aba84490843" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename EquatableType</type>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void tudat::json_interface::assignIfNotNaN</definition>
        <argsstring>(nlohmann::json &amp;jsonObject, const std::string &amp;key, const EquatableType &amp;value)</argsstring>
        <name>assignIfNotNaN</name>
        <param>
          <type>nlohmann::json &amp;</type>
          <declname>jsonObject</declname>
        </param>
        <param>
          <type>const std::string &amp;</type>
          <declname>key</declname>
        </param>
        <param>
          <type>const EquatableType &amp;</type>
          <declname>value</declname>
        </param>
        <briefdescription>
<para>Assign <computeroutput>value</computeroutput> to <computeroutput>jsonObject[ key ]</computeroutput> if <computeroutput>value</computeroutput> is not NaN. </para>
        </briefdescription>
        <detaileddescription>
<para><simplesect kind="remark"><para>This function does nothing if <computeroutput>value</computeroutput> is NaN. </para>
</simplesect>
<simplesect kind="remark"><para>The comparison operator must be defined for <computeroutput>EquatableType</computeroutput>. </para>
</simplesect>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>jsonObject</parametername>
</parameternamelist>
<parameterdescription>
<para>The <computeroutput>json</computeroutput> object being updated. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>key</parametername>
</parameternamelist>
<parameterdescription>
<para>The key of <computeroutput>jsonObject</computeroutput> being updated. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>value</parametername>
</parameternamelist>
<parameterdescription>
<para>The value to be used for updating <computeroutput>jsonObject[ key ]</computeroutput>. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/Users/jonashener/tudatpy_dev/tudat-bundle/tudat/include/tudat/interface/json/support/valueAccess.h" line="430" column="6" bodyfile="/Users/jonashener/tudatpy_dev/tudat-bundle/tudat/include/tudat/interface/json/support/valueAccess.h" bodystart="430" bodyend="436"/>
      </memberdef>
      <memberdef kind="function" id="valueAccess_8h_1a7de0470509c1fa5e9b23cc7434a94c70" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename T</type>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void tudat::json_interface::assignIfNotnullptr</definition>
        <argsstring>(nlohmann::json &amp;jsonObject, const std::string &amp;key, const std::shared_ptr&lt; T &gt; &amp;object)</argsstring>
        <name>assignIfNotnullptr</name>
        <param>
          <type>nlohmann::json &amp;</type>
          <declname>jsonObject</declname>
        </param>
        <param>
          <type>const std::string &amp;</type>
          <declname>key</declname>
        </param>
        <param>
          <type>const std::shared_ptr&lt; T &gt; &amp;</type>
          <declname>object</declname>
        </param>
        <briefdescription>
<para>Assign <computeroutput>object</computeroutput> to <computeroutput>jsonObject[ key ]</computeroutput> if <computeroutput>object</computeroutput> is not nullptr. </para>
        </briefdescription>
        <detaileddescription>
<para><simplesect kind="remark"><para>This function does nothing if <computeroutput>object</computeroutput> is <computeroutput>nullptr</computeroutput>. </para>
</simplesect>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>jsonObject</parametername>
</parameternamelist>
<parameterdescription>
<para>The <computeroutput>json</computeroutput> object being updated. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>key</parametername>
</parameternamelist>
<parameterdescription>
<para>The key of <computeroutput>jsonObject</computeroutput> being updated. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>object</parametername>
</parameternamelist>
<parameterdescription>
<para>Shared pointer to the object that is being to be used to update <computeroutput>jsonObject[ key ]</computeroutput>. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/Users/jonashener/tudatpy_dev/tudat-bundle/tudat/include/tudat/interface/json/support/valueAccess.h" line="447" column="6" bodyfile="/Users/jonashener/tudatpy_dev/tudat-bundle/tudat/include/tudat/interface/json/support/valueAccess.h" bodystart="447" bodyend="453"/>
      </memberdef>
      <memberdef kind="function" id="valueAccess_8h_1ae449adfbc7bf07f1dd6edb57daea34c8" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename ContainerType</type>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void tudat::json_interface::assignIfNotEmpty</definition>
        <argsstring>(nlohmann::json &amp;jsonObject, const std::string &amp;key, const ContainerType &amp;container)</argsstring>
        <name>assignIfNotEmpty</name>
        <param>
          <type>nlohmann::json &amp;</type>
          <declname>jsonObject</declname>
        </param>
        <param>
          <type>const std::string &amp;</type>
          <declname>key</declname>
        </param>
        <param>
          <type>const ContainerType &amp;</type>
          <declname>container</declname>
        </param>
        <briefdescription>
<para>Assign <computeroutput>object</computeroutput> to <computeroutput>jsonObject[ key ]</computeroutput> if <computeroutput>container</computeroutput> is not empty. </para>
        </briefdescription>
        <detaileddescription>
<para><simplesect kind="remark"><para>This function does nothing if <computeroutput>container</computeroutput> is empty. </para>
</simplesect>
<simplesect kind="remark"><para>The method <computeroutput>empty()</computeroutput> must be defined for <computeroutput>ContainerType</computeroutput>. </para>
</simplesect>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>jsonObject</parametername>
</parameternamelist>
<parameterdescription>
<para>The <computeroutput>json</computeroutput> object being updated. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>key</parametername>
</parameternamelist>
<parameterdescription>
<para>The key of <computeroutput>jsonObject</computeroutput> being updated. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>container</parametername>
</parameternamelist>
<parameterdescription>
<para>Container (e.g. <computeroutput>std::vector</computeroutput>, <computeroutput>std::set</computeroutput>, <computeroutput>std::map</computeroutput> or <computeroutput>std::unordered_map</computeroutput>) that is being to be used to update <computeroutput>jsonObject[ key ]</computeroutput>. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/Users/jonashener/tudatpy_dev/tudat-bundle/tudat/include/tudat/interface/json/support/valueAccess.h" line="466" column="6" bodyfile="/Users/jonashener/tudatpy_dev/tudat-bundle/tudat/include/tudat/interface/json/support/valueAccess.h" bodystart="466" bodyend="472"/>
      </memberdef>
      <memberdef kind="function" id="valueConversions_8h_1af96f1fb9252424a733d7e8dd1e260174" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>template&lt; typename ... &gt; class</type>
            <declname>MapType</declname>
            <defname>MapType</defname>
          </param>
          <param>
            <type>typename KeyType</type>
          </param>
          <param>
            <type>typename ValueType</type>
          </param>
        </templateparamlist>
        <type>nlohmann::json</type>
        <definition>nlohmann::json tudat::json_interface::jsonFromMap</definition>
        <argsstring>(const MapType&lt; KeyType, ValueType &gt; &amp;map)</argsstring>
        <name>jsonFromMap</name>
        <param>
          <type>const MapType&lt; KeyType, ValueType &gt; &amp;</type>
          <declname>map</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Template used by to_json methods for std::unodered_map and std::map. Use of this function outside those methods is discouraged. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/Users/jonashener/tudatpy_dev/tudat-bundle/tudat/include/tudat/interface/json/support/valueConversions.h" line="32" column="16" bodyfile="/Users/jonashener/tudatpy_dev/tudat-bundle/tudat/include/tudat/interface/json/support/valueConversions.h" bodystart="32" bodyend="40"/>
      </memberdef>
      <memberdef kind="function" id="valueConversions_8h_1accda62b9b0dec814ebf4ffa529775906" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>template&lt; typename ... &gt; class</type>
            <declname>VectorType</declname>
            <defname>VectorType</defname>
          </param>
          <param>
            <type>typename ValueType</type>
          </param>
        </templateparamlist>
        <type>nlohmann::json</type>
        <definition>nlohmann::json tudat::json_interface::jsonFromVector</definition>
        <argsstring>(const VectorType&lt; ValueType &gt; &amp;vector)</argsstring>
        <name>jsonFromVector</name>
        <param>
          <type>const VectorType&lt; ValueType &gt; &amp;</type>
          <declname>vector</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/Users/jonashener/tudatpy_dev/tudat-bundle/tudat/include/tudat/interface/json/support/valueConversions.h" line="43" column="16" bodyfile="/Users/jonashener/tudatpy_dev/tudat-bundle/tudat/include/tudat/interface/json/support/valueConversions.h" bodystart="43" bodyend="52"/>
      </memberdef>
      <memberdef kind="function" id="valueConversions_8h_1a904fe5a287153ca6c78065c38d5b21d4" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>template&lt; typename ... &gt; class</type>
            <declname>MapType</declname>
            <defname>MapType</defname>
          </param>
          <param>
            <type>typename KeyType</type>
          </param>
          <param>
            <type>typename ValueType</type>
          </param>
        </templateparamlist>
        <type>MapType&lt; KeyType, ValueType &gt;</type>
        <definition>MapType&lt; KeyType, ValueType &gt; tudat::json_interface::mapFromJson</definition>
        <argsstring>(const nlohmann::json &amp;jsonObject)</argsstring>
        <name>mapFromJson</name>
        <param>
          <type>const nlohmann::json &amp;</type>
          <declname>jsonObject</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Template used by from_json methods for std::unodered_map and std::map. Use of this function outside those methods is discouraged. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/Users/jonashener/tudatpy_dev/tudat-bundle/tudat/include/tudat/interface/json/support/valueConversions.h" line="60" column="9" bodyfile="/Users/jonashener/tudatpy_dev/tudat-bundle/tudat/include/tudat/interface/json/support/valueConversions.h" bodystart="60" bodyend="72"/>
      </memberdef>
      <memberdef kind="function" id="unitTestSupport_8h_1aa5ae4d74577ff3fba0dc030401c1dbac" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>boost::filesystem::path</type>
        <definition>boost::filesystem::path tudat::json_interface::currentDirectory</definition>
        <argsstring>()</argsstring>
        <name>currentDirectory</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/Users/jonashener/tudatpy_dev/tudat-bundle/tudat/include/tudat/interface/json/unitTestSupport.h" line="27" column="32" bodyfile="/Users/jonashener/tudatpy_dev/tudat-bundle/tudat/include/tudat/interface/json/unitTestSupport.h" bodystart="27" bodyend="30"/>
      </memberdef>
      <memberdef kind="function" id="unitTestSupport_8h_1a46f731394b578c7dc6c2eb0003276b7e" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>boost::filesystem::path</type>
        <definition>boost::filesystem::path tudat::json_interface::inputDirectory</definition>
        <argsstring>()</argsstring>
        <name>inputDirectory</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/Users/jonashener/tudatpy_dev/tudat-bundle/tudat/include/tudat/interface/json/unitTestSupport.h" line="32" column="32" bodyfile="/Users/jonashener/tudatpy_dev/tudat-bundle/tudat/include/tudat/interface/json/unitTestSupport.h" bodystart="32" bodyend="44"/>
      </memberdef>
      <memberdef kind="function" id="unitTestSupport_8h_1a10b7c1265c1cf461fbc9a3322cb4cc41" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename T</type>
            <defval>nlohmann::json</defval>
          </param>
        </templateparamlist>
        <type>T</type>
        <definition>T tudat::json_interface::parseJSONFile</definition>
        <argsstring>(std::string file)</argsstring>
        <name>parseJSONFile</name>
        <param>
          <type>std::string</type>
          <declname>file</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/Users/jonashener/tudatpy_dev/tudat-bundle/tudat/include/tudat/interface/json/unitTestSupport.h" line="47" column="3" bodyfile="/Users/jonashener/tudatpy_dev/tudat-bundle/tudat/include/tudat/interface/json/unitTestSupport.h" bodystart="47" bodyend="55"/>
      </memberdef>
      <memberdef kind="function" id="unitTestSupport_8h_1a25342ef68e65ff6b3c5440aae1c2be77" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename T</type>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void tudat::json_interface::checkJsonEquivalent</definition>
        <argsstring>(const T &amp;left, const T &amp;right)</argsstring>
        <name>checkJsonEquivalent</name>
        <param>
          <type>const T &amp;</type>
          <declname>left</declname>
        </param>
        <param>
          <type>const T &amp;</type>
          <declname>right</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/Users/jonashener/tudatpy_dev/tudat-bundle/tudat/include/tudat/interface/json/unitTestSupport.h" line="59" column="6" bodyfile="/Users/jonashener/tudatpy_dev/tudat-bundle/tudat/include/tudat/interface/json/unitTestSupport.h" bodystart="59" bodyend="64"/>
      </memberdef>
      <memberdef kind="function" id="unitTestSupport_8h_1a506c0c9c29e70ee48ba91618f6eef833" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename Enum</type>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void tudat::json_interface::checkConsistentEnum</definition>
        <argsstring>(const std::string &amp;filename, const std::map&lt; Enum, std::string &gt; &amp;stringValues, const std::vector&lt; Enum &gt; &amp;usupportedValues)</argsstring>
        <name>checkConsistentEnum</name>
        <param>
          <type>const std::string &amp;</type>
          <declname>filename</declname>
        </param>
        <param>
          <type>const std::map&lt; Enum, std::string &gt; &amp;</type>
          <declname>stringValues</declname>
        </param>
        <param>
          <type>const std::vector&lt; Enum &gt; &amp;</type>
          <declname>usupportedValues</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/Users/jonashener/tudatpy_dev/tudat-bundle/tudat/include/tudat/interface/json/unitTestSupport.h" line="70" column="6" bodyfile="/Users/jonashener/tudatpy_dev/tudat-bundle/tudat/include/tudat/interface/json/unitTestSupport.h" bodystart="70" bodyend="90"/>
      </memberdef>
      <memberdef kind="function" id="unitTestSupport_8h_1aafd5e0de6563cb28518b8dee694fa936" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename ContainerType</type>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void tudat::json_interface::checkCloseIntegrationResultsMatrix</definition>
        <argsstring>(const std::map&lt; double, ContainerType &gt; &amp;results1, const std::map&lt; double, ContainerType &gt; &amp;results2, const std::vector&lt; std::pair&lt; unsigned int, unsigned int &gt; &gt; indices, const std::vector&lt; std::pair&lt; unsigned int, unsigned int &gt; &gt; sizes, const std::vector&lt; double &gt; absoluteTolerances)</argsstring>
        <name>checkCloseIntegrationResultsMatrix</name>
        <param>
          <type>const std::map&lt; double, ContainerType &gt; &amp;</type>
          <declname>results1</declname>
        </param>
        <param>
          <type>const std::map&lt; double, ContainerType &gt; &amp;</type>
          <declname>results2</declname>
        </param>
        <param>
          <type>const std::vector&lt; std::pair&lt; unsigned int, unsigned int &gt; &gt;</type>
          <declname>indices</declname>
        </param>
        <param>
          <type>const std::vector&lt; std::pair&lt; unsigned int, unsigned int &gt; &gt;</type>
          <declname>sizes</declname>
        </param>
        <param>
          <type>const std::vector&lt; double &gt;</type>
          <declname>absoluteTolerances</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/Users/jonashener/tudatpy_dev/tudat-bundle/tudat/include/tudat/interface/json/unitTestSupport.h" line="96" column="6" bodyfile="/Users/jonashener/tudatpy_dev/tudat-bundle/tudat/include/tudat/interface/json/unitTestSupport.h" bodystart="96" bodyend="130"/>
      </memberdef>
      <memberdef kind="function" id="unitTestSupport_8h_1a170c0b53838c581ef2b76e92091a037c" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>void</type>
        <definition>void tudat::json_interface::checkCloseIntegrationResults</definition>
        <argsstring>(const std::map&lt; double, Eigen::VectorXd &gt; &amp;results1, const std::map&lt; double, Eigen::VectorXd &gt; &amp;results2, const std::vector&lt; unsigned int &gt; indices, const std::vector&lt; unsigned int &gt; sizes, const double tolerance)</argsstring>
        <name>checkCloseIntegrationResults</name>
        <param>
          <type>const std::map&lt; double, Eigen::VectorXd &gt; &amp;</type>
          <declname>results1</declname>
        </param>
        <param>
          <type>const std::map&lt; double, Eigen::VectorXd &gt; &amp;</type>
          <declname>results2</declname>
        </param>
        <param>
          <type>const std::vector&lt; unsigned int &gt;</type>
          <declname>indices</declname>
        </param>
        <param>
          <type>const std::vector&lt; unsigned int &gt;</type>
          <declname>sizes</declname>
        </param>
        <param>
          <type>const double</type>
          <declname>tolerance</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/Users/jonashener/tudatpy_dev/tudat-bundle/tudat/include/tudat/interface/json/unitTestSupport.h" line="132" column="13" bodyfile="/Users/jonashener/tudatpy_dev/tudat-bundle/tudat/include/tudat/interface/json/unitTestSupport.h" bodystart="132" bodyend="149"/>
      </memberdef>
      <memberdef kind="function" id="deserialization_8cpp_1ac691bb2f5a694f534a5eb5a030233854" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>std::pair&lt; unsigned int, unsigned int &gt;</type>
        <definition>std::pair&lt; unsigned int, unsigned int &gt; tudat::json_interface::getLineAndCol</definition>
        <argsstring>(std::ifstream &amp;stream, const std::streampos position)</argsstring>
        <name>getLineAndCol</name>
        <param>
          <type>std::ifstream &amp;</type>
          <declname>stream</declname>
        </param>
        <param>
          <type>const std::streampos</type>
          <declname>position</declname>
        </param>
        <briefdescription>
<para>Get the corresponding line and column for a certain (byte) position in a <computeroutput>std::ifstream</computeroutput>. </para>
        </briefdescription>
        <detaileddescription>
<para>Get the corresponding line and column for a certain (byte) position in a <computeroutput>std::ifstream</computeroutput>. <parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>stream</parametername>
</parameternamelist>
<parameterdescription>
<para>The stream (passed by reference, its current byte position will be set to zero and then reset to the original one before returning, so effectively this function does not modify the stream). </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>position</parametername>
</parameternamelist>
<parameterdescription>
<para>The byte position (or character index) of interest. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Line and column for the character at <computeroutput>position</computeroutput> in <computeroutput>stream</computeroutput>. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/Users/jonashener/tudatpy_dev/tudat-bundle/tudat/src/interface/json/support/deserialization.cpp" line="72" column="11" bodyfile="/Users/jonashener/tudatpy_dev/tudat-bundle/tudat/src/interface/json/support/deserialization.cpp" bodystart="72" bodyend="95"/>
      </memberdef>
      <memberdef kind="function" id="deserialization_8cpp_1a85776215d4288b6b38a7c41d7aa03485" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void tudat::json_interface::updatePaths</definition>
        <argsstring>(nlohmann::json &amp;jsonObject, const boost::filesystem::path &amp;filePath, const boost::filesystem::path &amp;parentFilePath, const boost::filesystem::path &amp;rootFilePath)</argsstring>
        <name>updatePaths</name>
        <param>
          <type>nlohmann::json &amp;</type>
          <declname>jsonObject</declname>
        </param>
        <param>
          <type>const boost::filesystem::path &amp;</type>
          <declname>filePath</declname>
        </param>
        <param>
          <type>const boost::filesystem::path &amp;</type>
          <declname>parentFilePath</declname>
        </param>
        <param>
          <type>const boost::filesystem::path &amp;</type>
          <declname>rootFilePath</declname>
        </param>
        <briefdescription>
<para>Update paths for a JSON object. </para>
        </briefdescription>
        <detaileddescription>
<para><linebreak/>
 Looks for expressions ${FILE_STEM}, ${FILE_NAME}, ${PARENT_FILE_STEM}, ${PARENT_FILE_NAME}, ${ROOT_FILE_STEM} and ${ROOT_FILE_NAME} in all the strings of <computeroutput>jsonObject</computeroutput>, replacing them, respetively, bu the stem of filename of the file in which it is defined, in which it was included, or in the root input file (the one provided to the command line app as argument). <linebreak/>
 Then, it fixes paths in included files by searching string matching the expressions &quot;@path(myPath)&quot;, only when myPath is a relative path. This is necessary because myPath must be relative to the root file, but in input files the user provides paths relative to the directory in which the definition file is located. <linebreak/>
 This feature can be &quot;turned off&quot; by providing paths directly without the &quot;@path&quot; keyword (e.g. &quot;myPath&quot;). This is safe when no modular files are included, but can result in problems otherwise. If paths are provided directly without the &quot;@path&quot; keyword, then the user is responsible for defining them always relative to the root file in which they are going to be included (and not relative to the file in which they are defined). <parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>jsonObject</parametername>
</parameternamelist>
<parameterdescription>
<para>The <computeroutput>json</computeroutput> object containing / being a string. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>filePath</parametername>
</parameternamelist>
<parameterdescription>
<para>Path to the file in which the path is defined. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>parentFilePath</parametername>
</parameternamelist>
<parameterdescription>
<para>Path to the file in which the file in which the path is defined was included (equal to <computeroutput>filePath</computeroutput> if <computeroutput>jsonObject</computeroutput> was defined at <computeroutput>parentFilePath</computeroutput>). </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>rootFilePath</parametername>
</parameternamelist>
<parameterdescription>
<para>Path to the root file that was passed as command-line argument to the application. (equal to <computeroutput>filePath</computeroutput> if <computeroutput>jsonObject</computeroutput> was defined at <computeroutput>rootFilePath</computeroutput>). </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/Users/jonashener/tudatpy_dev/tudat-bundle/tudat/src/interface/json/support/deserialization.cpp" line="121" column="6" bodyfile="/Users/jonashener/tudatpy_dev/tudat-bundle/tudat/src/interface/json/support/deserialization.cpp" bodystart="121" bodyend="166"/>
      </memberdef>
      <memberdef kind="function" id="deserialization_8cpp_1ac8fdbc56927925a178557c4eb40276fb" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void tudat::json_interface::mergeJSON</definition>
        <argsstring>(nlohmann::json &amp;jsonObject, const boost::filesystem::path &amp;filePath)</argsstring>
        <name>mergeJSON</name>
        <param>
          <type>nlohmann::json &amp;</type>
          <declname>jsonObject</declname>
        </param>
        <param>
          <type>const boost::filesystem::path &amp;</type>
          <declname>filePath</declname>
        </param>
        <briefdescription>
<para>Merge an array of JSON input objects. </para>
        </briefdescription>
        <detaileddescription>
<para><linebreak/>
 If <computeroutput>jsonObject</computeroutput> is not an array, this function will do nothing. <linebreak/>
 If <computeroutput>jsonObject</computeroutput> is an array of objects, the first object will be used to create the initial <computeroutput>json</computeroutput> object. Then, the subsequent objects will be used to create this initial object, by updating (or settings) the keys defined in these subsequent objects with the provided objects. <parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>jsonObject</parametername>
</parameternamelist>
<parameterdescription>
<para>The <computeroutput>json</computeroutput> containing an object (no merging will be applied) or an array of objects (the elements will be merged). </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>filePath</parametername>
</parameternamelist>
<parameterdescription>
<para>The file from which <computeroutput>jsonObject</computeroutput> was retrieved. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/Users/jonashener/tudatpy_dev/tudat-bundle/tudat/src/interface/json/support/deserialization.cpp" line="202" column="6" bodyfile="/Users/jonashener/tudatpy_dev/tudat-bundle/tudat/src/interface/json/support/deserialization.cpp" bodystart="202" bodyend="252"/>
      </memberdef>
      <memberdef kind="function" id="deserialization_8cpp_1a8483207580fc0f48526af73dc39bc2d7" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void tudat::json_interface::parseModularJSON</definition>
        <argsstring>(nlohmann::json &amp;jsonObject, const boost::filesystem::path &amp;filePath, nlohmann::json parentObject=nlohmann::json(), boost::filesystem::path rootFilePath=boost::filesystem::path())</argsstring>
        <name>parseModularJSON</name>
        <param>
          <type>nlohmann::json &amp;</type>
          <declname>jsonObject</declname>
        </param>
        <param>
          <type>const boost::filesystem::path &amp;</type>
          <declname>filePath</declname>
        </param>
        <param>
          <type>nlohmann::json</type>
          <declname>parentObject</declname>
          <defval>nlohmann::json()</defval>
        </param>
        <param>
          <type>boost::filesystem::path</type>
          <declname>rootFilePath</declname>
          <defval>boost::filesystem::path()</defval>
        </param>
        <briefdescription>
<para>Parse a modular <computeroutput>json</computeroutput> object. </para>
        </briefdescription>
        <detaileddescription>
<para>Parse a modular <computeroutput>json</computeroutput> object containing strings (or being equal to a string) of matching the expression <computeroutput>&quot;$(path){key}&quot;</computeroutput>, which will be replaced with the value for the key &quot;key&quot; in the file at &quot;path&quot;. <linebreak/>
 &quot;path&quot; can be absolute or relative (to the parent directory of <computeroutput>filePath</computeroutput>). <linebreak/>
 If the part &quot;(path)&quot; is not provided, the key &quot;key&quot; will be searched in <computeroutput>parentObject</computeroutput> (or in <computeroutput>jsonObject</computeroutput> if <computeroutput>parentObject</computeroutput> is not defined). <linebreak/>
 If the part &quot;{key}&quot; is not provided, the whole <computeroutput>json</computeroutput> object contained in the file at &quot;path&quot; will be used. <linebreak/>
 &quot;key&quot; can be a single key, or a key path separated by dots (e.g. &quot;key.subkey.subsubkey&quot;). Elements of arrays can be accessed by indicating their index, starting from 0 (e.g. &quot;key[2].subkey[0]&quot;). <linebreak/>
 &quot;key&quot; can contain a single key (path) or many, separated by commas (e.g. &quot;key1,key2.subkey&quot;). If the character &quot;,&quot; is found in &quot;key&quot;, <computeroutput>jsonObject</computeroutput> will be converted to an array. The key &quot;key1,&quot; creates an array with one element. <linebreak/>
 &quot;key&quot; can contain colons, in which case <computeroutput>jsonObject</computeroutput> will be converted to an object/map (e.g. &quot;a:keyA,b:keyB[0]&quot;). <linebreak/>
 Illegal characters in referenced file paths: (){} <linebreak/>
 Illegal characters in referenced keys: (){}.:, <simplesect kind="remark"><para>This function results in a recursive loop when a key value references itself, making the app terminate without providing an informative error message. </para>
</simplesect>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>jsonObject</parametername>
</parameternamelist>
<parameterdescription>
<para>The <computeroutput>json</computeroutput> object to be parsed (passed by reference). </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>filePath</parametername>
</parameternamelist>
<parameterdescription>
<para>Path of the file from which <computeroutput>jsonObject</computeroutput> was retrieved. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>parentObject</parametername>
</parameternamelist>
<parameterdescription>
<para>The <computeroutput>json</computeroutput> object form which <computeroutput>jsonObject</computeroutput> was retrieved, if any (default is nullptr <computeroutput>json</computeroutput>). </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>rootFilePath</parametername>
</parameternamelist>
<parameterdescription>
<para>Path to the root file that was passed as command-line argument to the application (empty if <computeroutput>filePath</computeroutput> is equal to <computeroutput>rootFilePath</computeroutput>). </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/Users/jonashener/tudatpy_dev/tudat-bundle/tudat/src/interface/json/support/deserialization.cpp" line="285" column="6" bodyfile="/Users/jonashener/tudatpy_dev/tudat-bundle/tudat/src/interface/json/support/deserialization.cpp" bodystart="285" bodyend="462"/>
      </memberdef>
      <memberdef kind="function" id="valueAccess_8cpp_1a5a946e1979b288292073f5f9bb626393" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>std::set&lt; <ref refid="classtudat_1_1json__interface_1_1KeyPath" kindref="compound">KeyPath</ref> &gt;</type>
        <definition>std::set&lt; KeyPath &gt; tudat::json_interface::getKeyPaths</definition>
        <argsstring>(const nlohmann::json &amp;jsonObject, const KeyPath &amp;baseKeyPath=SpecialKeys::root)</argsstring>
        <name>getKeyPaths</name>
        <param>
          <type>const nlohmann::json &amp;</type>
          <declname>jsonObject</declname>
        </param>
        <param>
          <type>const <ref refid="classtudat_1_1json__interface_1_1KeyPath" kindref="compound">KeyPath</ref> &amp;</type>
          <declname>baseKeyPath</declname>
          <defval>SpecialKeys::root</defval>
        </param>
        <briefdescription>
<para>Get all the key paths defined for <computeroutput>jsonObject</computeroutput>. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>jsonObject</parametername>
</parameternamelist>
<parameterdescription>
<para>The <computeroutput>json</computeroutput> object. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>baseKeyPath</parametername>
</parameternamelist>
<parameterdescription>
<para>The key path in which to look for sub-key paths. Default is SpecialKeys::root, i.e. a key path will be added to the returned <computeroutput>std::set</computeroutput> for each key defined in <computeroutput>jsonObject</computeroutput>. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>A set containing a key path for each key defined in <computeroutput>jsonObject</computeroutput> at <computeroutput>baseKeyPath</computeroutput>. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/Users/jonashener/tudatpy_dev/tudat-bundle/tudat/src/interface/json/support/valueAccess.cpp" line="139" column="10" bodyfile="/Users/jonashener/tudatpy_dev/tudat-bundle/tudat/src/interface/json/support/valueAccess.cpp" bodystart="139" bodyend="159"/>
      </memberdef>
      <memberdef kind="function" id="valueAccess_8cpp_1a76ff5f9b580807afd07e3ef011dae604" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>bool</type>
        <definition>bool tudat::json_interface::arrayContainsObjects</definition>
        <argsstring>(nlohmann::json &amp;jsonArray)</argsstring>
        <name>arrayContainsObjects</name>
        <param>
          <type>nlohmann::json &amp;</type>
          <declname>jsonArray</declname>
        </param>
        <briefdescription>
<para>Returns whether any of the elements in <computeroutput>jsonArray</computeroutput> (and their subelements) are of type object. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/Users/jonashener/tudatpy_dev/tudat-bundle/tudat/src/interface/json/support/valueAccess.cpp" line="187" column="6" bodyfile="/Users/jonashener/tudatpy_dev/tudat-bundle/tudat/src/interface/json/support/valueAccess.cpp" bodystart="187" bodyend="205"/>
      </memberdef>
      </sectiondef>
    <briefdescription>
    </briefdescription>
    <detaileddescription>
    </detaileddescription>
    <location file="/Users/jonashener/tudatpy_dev/tudat-bundle/tudat/include/tudat/interface/json/environment/body.h" line="33" column="1"/>
  </compounddef>
</doxygen>
