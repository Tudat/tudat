<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.9.1" xml:lang="en-US">
  <compounddef id="namespacetudat_1_1input__output_1_1parsed__data__vector__utilities" kind="namespace" language="C++">
    <compoundname>tudat::input_output::parsed_data_vector_utilities</compoundname>
      <sectiondef kind="typedef">
      <memberdef kind="typedef" id="parsedDataVectorUtilities_8h_1a9cd5e29c908251664f86e05265872003" prot="public" static="no">
        <type>std::shared_ptr&lt; <ref refid="classtudat_1_1input__output_1_1FieldValue" kindref="compound">FieldValue</ref> &gt;</type>
        <definition>typedef std::shared_ptr&lt; FieldValue &gt; tudat::input_output::parsed_data_vector_utilities::FieldValuePtr</definition>
        <argsstring></argsstring>
        <name>FieldValuePtr</name>
        <briefdescription>
<para>Pointer to a field value (string). </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/Users/jonashener/tudatpy_dev/tudat-bundle/tudat/include/tudat/io/parsedDataVectorUtilities.h" line="34" column="33" bodyfile="/Users/jonashener/tudatpy_dev/tudat-bundle/tudat/include/tudat/io/parsedDataVectorUtilities.h" bodystart="34" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="parsedDataVectorUtilities_8h_1a1e7b76cfc1332dc48ee305553f1e6f55" prot="public" static="no">
        <type>std::map&lt; FieldType, FieldValuePtr &gt;</type>
        <definition>typedef std::map&lt; FieldType, FieldValuePtr &gt; tudat::input_output::parsed_data_vector_utilities::ParsedDataLineMap</definition>
        <argsstring></argsstring>
        <name>ParsedDataLineMap</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Map containing field value pointers (mapped value), identified by their field type (key value). Such maps contain the information from one parsed line. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/Users/jonashener/tudatpy_dev/tudat-bundle/tudat/include/tudat/io/parsedDataVectorUtilities.h" line="38" column="21" bodyfile="/Users/jonashener/tudatpy_dev/tudat-bundle/tudat/include/tudat/io/parsedDataVectorUtilities.h" bodystart="38" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="parsedDataVectorUtilities_8h_1ab94ba85c4e693297ad395fde9c077909" prot="public" static="no">
        <type>std::shared_ptr&lt; ParsedDataLineMap &gt;</type>
        <definition>typedef std::shared_ptr&lt; ParsedDataLineMap &gt; tudat::input_output::parsed_data_vector_utilities::ParsedDataLineMapPtr</definition>
        <argsstring></argsstring>
        <name>ParsedDataLineMapPtr</name>
        <briefdescription>
<para>Pointer to a parsed data line (see ParsedDataLineMap). </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/Users/jonashener/tudatpy_dev/tudat-bundle/tudat/include/tudat/io/parsedDataVectorUtilities.h" line="41" column="26" bodyfile="/Users/jonashener/tudatpy_dev/tudat-bundle/tudat/include/tudat/io/parsedDataVectorUtilities.h" bodystart="41" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="parsedDataVectorUtilities_8h_1a784e31e1b75e646ef060ba0f25a472c6" prot="public" static="no">
        <type>std::vector&lt; ParsedDataLineMapPtr &gt;</type>
        <definition>typedef std::vector&lt; ParsedDataLineMapPtr &gt; tudat::input_output::parsed_data_vector_utilities::ParsedDataVector</definition>
        <argsstring></argsstring>
        <name>ParsedDataVector</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Vector of data map pointers (see ParsedDataLineMapPtr). Each entry of the vector points to parsed data line. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/Users/jonashener/tudatpy_dev/tudat-bundle/tudat/include/tudat/io/parsedDataVectorUtilities.h" line="45" column="25" bodyfile="/Users/jonashener/tudatpy_dev/tudat-bundle/tudat/include/tudat/io/parsedDataVectorUtilities.h" bodystart="45" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="parsedDataVectorUtilities_8h_1aa1a94fd2bb329c9ad50312c86c430a92" prot="public" static="no">
        <type>std::shared_ptr&lt; ParsedDataVector &gt;</type>
        <definition>typedef std::shared_ptr&lt; ParsedDataVector &gt; tudat::input_output::parsed_data_vector_utilities::ParsedDataVectorPtr</definition>
        <argsstring></argsstring>
        <name>ParsedDataVectorPtr</name>
        <briefdescription>
<para>Pointer to the data map pointer vectors (see ParsedDataVector). </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/Users/jonashener/tudatpy_dev/tudat-bundle/tudat/include/tudat/io/parsedDataVectorUtilities.h" line="48" column="27" bodyfile="/Users/jonashener/tudatpy_dev/tudat-bundle/tudat/include/tudat/io/parsedDataVectorUtilities.h" bodystart="48" bodyend="-1"/>
      </memberdef>
      </sectiondef>
      <sectiondef kind="func">
      <memberdef kind="function" id="parsedDataVectorUtilities_8h_1a122e40be9f1fbbf0fd46b20bbcb1c104" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename T</type>
          </param>
        </templateparamlist>
        <type>T</type>
        <definition>T tudat::input_output::parsed_data_vector_utilities::getField</definition>
        <argsstring>(ParsedDataLineMapPtr data, FieldType field)</argsstring>
        <name>getField</name>
        <param>
          <type>ParsedDataLineMapPtr</type>
          <declname>data</declname>
        </param>
        <param>
          <type>FieldType</type>
          <declname>field</declname>
        </param>
        <briefdescription>
<para>Get the value of a given field from the map containing data. </para>
        </briefdescription>
        <detaileddescription>
<para>Returns the transformed ( calls <ref refid="classtudat_1_1input__output_1_1FieldValue_1a2b0c0ef1510cfe80cf5bd2644c802921" kindref="member">FieldValue::get()</ref> ) value of a field in a data map.</para>
<para>Note: You must be sure that that the key exists in the data map or otherwise, segfaults will occur.</para>
<para>Example usage: ParsedDataLineMapPtr datamap; string planetName = getField&lt;string&gt;(datamap, fieldtypes::general::name); int planetID = getField&lt; int  &gt;(datamap, fieldtypes::general::id); double planetEccentricity = getField&lt;double&gt;(datamap, fieldtypes::state::eccentricity);</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>data</parametername>
</parameternamelist>
<parameterdescription>
<para>Check this datamap for all the requested FieldTypes. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>field</parametername>
</parameternamelist>
<parameterdescription>
<para>Fieldtype to search for. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para><ref refid="classtudat_1_1input__output_1_1FieldValue" kindref="compound">FieldValue</ref> The <ref refid="classtudat_1_1input__output_1_1FieldValue" kindref="compound">FieldValue</ref> string converted to the given type. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/Users/jonashener/tudatpy_dev/tudat-bundle/tudat/include/tudat/io/parsedDataVectorUtilities.h" line="68" column="10" bodyfile="/Users/jonashener/tudatpy_dev/tudat-bundle/tudat/include/tudat/io/parsedDataVectorUtilities.h" bodystart="68" bodyend="72"/>
      </memberdef>
      <memberdef kind="function" id="parsedDataVectorUtilities_8h_1ad620e238e526b3cf5983fde8c13ec1ce" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename T</type>
          </param>
        </templateparamlist>
        <type>std::shared_ptr&lt; T &gt;</type>
        <definition>std::shared_ptr&lt; T &gt; tudat::input_output::parsed_data_vector_utilities::getFieldPointer</definition>
        <argsstring>(ParsedDataLineMapPtr data, FieldType field)</argsstring>
        <name>getFieldPointer</name>
        <param>
          <type>ParsedDataLineMapPtr</type>
          <declname>data</declname>
        </param>
        <param>
          <type>FieldType</type>
          <declname>field</declname>
        </param>
        <briefdescription>
<para>Get a shared-pointer to the value of a given field from the map containing data. </para>
        </briefdescription>
        <detaileddescription>
<para>Returns the transformed ( calls <ref refid="classtudat_1_1input__output_1_1FieldValue_1a9cd70b9234dfba471b11242218d23c63" kindref="member">FieldValue::getPointer()</ref> ) value of a field in a data map.</para>
<para>Note: You must be sure that that the key exists in the data map or otherwise, segfaults will occur.</para>
<para>Example usage: ParsedDataLineMapPtr datamap; std::shared_ptr&lt;string&gt; planetName = getField&lt;string&gt;(datamap, fieldtypes::general::name); std::shared_ptr&lt;int&gt; planetID = getField&lt; int  &gt;(datamap, fieldtypes::general::id); std::shared_ptr&lt;double&gt; planetEccentricity = getField&lt;double&gt;(datamap, fieldtypes::state::eccentricity);</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>data</parametername>
</parameternamelist>
<parameterdescription>
<para>Check this datamap for all the requested FieldTypes. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>field</parametername>
</parameternamelist>
<parameterdescription>
<para>Fieldtype to search for. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para><ref refid="classtudat_1_1input__output_1_1FieldValue" kindref="compound">FieldValue</ref> The <ref refid="classtudat_1_1input__output_1_1FieldValue" kindref="compound">FieldValue</ref> string converted to the given type. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/Users/jonashener/tudatpy_dev/tudat-bundle/tudat/include/tudat/io/parsedDataVectorUtilities.h" line="95" column="24" bodyfile="/Users/jonashener/tudatpy_dev/tudat-bundle/tudat/include/tudat/io/parsedDataVectorUtilities.h" bodystart="95" bodyend="99"/>
      </memberdef>
      <memberdef kind="function" id="parsedDataVectorUtilities_8h_1ae762ded78e979c1f63aa6c208c848a1f" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>ParsedDataVectorPtr</type>
        <definition>ParsedDataVectorPtr tudat::input_output::parsed_data_vector_utilities::filterMapKey</definition>
        <argsstring>(ParsedDataVectorPtr datavector, int nrFields,...)</argsstring>
        <name>filterMapKey</name>
        <param>
          <type>ParsedDataVectorPtr</type>
          <declname>datavector</declname>
        </param>
        <param>
          <type>int</type>
          <declname>nrFields</declname>
        </param>
        <param>
          <type>...</type>
        </param>
        <briefdescription>
<para>Filter the data vector for entries containing a given FieldType. </para>
        </briefdescription>
        <detaileddescription>
<para>This allows for filtering of a parsed data vector, based on the requirement that each of the datamaps MUST include each passed FieldTypes.</para>
<para>Example usage: ParsedDataVectorPtr datavector; filterMapKey(datavector, 2, fieldtypes::general::name, fieldtypes::time::epoch);</para>
<para>This return a new data vector that contains data maps only with the name FieldType and the epoch FieldType.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>datavector</parametername>
</parameternamelist>
<parameterdescription>
<para>Data vector to be checked for all the requested FieldTypes. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>nrFields</parametername>
</parameternamelist>
<parameterdescription>
<para>Number of field that each entry must contain </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>...</parametername>
</parameternamelist>
<parameterdescription>
<para>Fieldtypes that each entry must contain. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>newdatavector A copy of the data vector with only the entries that contain the passed FieldTypes. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/Users/jonashener/tudatpy_dev/tudat-bundle/tudat/src/io/parsedDataVectorUtilities.cpp" line="27" column="21" bodyfile="/Users/jonashener/tudatpy_dev/tudat-bundle/tudat/src/io/parsedDataVectorUtilities.cpp" bodystart="27" bodyend="82" declfile="/Users/jonashener/tudatpy_dev/tudat-bundle/tudat/include/tudat/io/parsedDataVectorUtilities.h" declline="119" declcolumn="21"/>
      </memberdef>
      <memberdef kind="function" id="parsedDataVectorUtilities_8h_1a542665e603dfdb2cf6064ce615212386" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>ParsedDataVectorPtr</type>
        <definition>ParsedDataVectorPtr tudat::input_output::parsed_data_vector_utilities::filterMapKeyValue</definition>
        <argsstring>(ParsedDataVectorPtr datavector, int nrFields,...)</argsstring>
        <name>filterMapKeyValue</name>
        <param>
          <type>ParsedDataVectorPtr</type>
          <declname>datavector</declname>
        </param>
        <param>
          <type>int</type>
          <declname>nrFields</declname>
        </param>
        <param>
          <type>...</type>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Filter the data vector vector for entries containing a given FieldType and a matching <ref refid="classtudat_1_1input__output_1_1FieldValue" kindref="compound">FieldValue</ref> regex.</para>
<para>This allows for filtering of a parsed data vector, based on the requirement that each of the datamaps MUST include each passed FieldType and its value MUST have at least one match for the passed regex for each respective field.</para>
<para>Example usage: ParsedDataVectorPtr datavector; filterMapKeyValue(datavector, 2, fieldtypes::general::name, &quot;Venus&quot;, fieldtypes::time::epoch, &quot;2451545[\.0-9]*&quot;);</para>
<para>This filter would create a new vector, where each data line is about Venus, and the epoch for that dataline is on the date of 2000-1-1 (J2000). This means epoch can range from 2000-1-1 00h to 2000-1-1 23h59m59.999...</para>
<para>Note: the regular expression is in the form of char* and not boost::regex because that yields the followong stdargs incompatibility: error: cannot receive objects of non-trivially-copyable type &apos;boost::regex {aka struct boost::basic_regex&lt;char, boost::regex_traits&lt;char&gt; &gt;}&apos; through &apos;...&apos;;</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>datavector</parametername>
</parameternamelist>
<parameterdescription>
<para>Data vector to be checked for all the requested FieldTypes. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>nrFields</parametername>
</parameternamelist>
<parameterdescription>
<para>Number of field that each entry must contain. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>...</parametername>
</parameternamelist>
<parameterdescription>
<para>List of FieltType and Regex (char*) entries that must match to be addmited in the filtered vector. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>newdatavector A copy of the data vector with only the entries that contain the passed FieldTypes.</para>
</simplesect>
Filter the data vector vector for entries containing a given FieldType and a matching <ref refid="classtudat_1_1input__output_1_1FieldValue" kindref="compound">FieldValue</ref> regex. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/Users/jonashener/tudatpy_dev/tudat-bundle/tudat/src/io/parsedDataVectorUtilities.cpp" line="86" column="21" bodyfile="/Users/jonashener/tudatpy_dev/tudat-bundle/tudat/src/io/parsedDataVectorUtilities.cpp" bodystart="86" bodyend="157" declfile="/Users/jonashener/tudatpy_dev/tudat-bundle/tudat/include/tudat/io/parsedDataVectorUtilities.h" declline="149" declcolumn="21"/>
      </memberdef>
      <memberdef kind="function" id="parsedDataVectorUtilities_8h_1a532460fb0666ec6da0460bfe74b9e254" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>std::ostream &amp;</type>
        <definition>std::ostream &amp; tudat::input_output::parsed_data_vector_utilities::dump</definition>
        <argsstring>(std::ostream &amp;stream, ParsedDataLineMapPtr data, bool showTransformed)</argsstring>
        <name>dump</name>
        <param>
          <type>std::ostream &amp;</type>
          <declname>stream</declname>
        </param>
        <param>
          <type>ParsedDataLineMapPtr</type>
          <declname>data</declname>
        </param>
        <param>
          <type>bool</type>
          <declname>showTransformed</declname>
        </param>
        <briefdescription>
<para>Dump the content of a data map to an ostream. </para>
        </briefdescription>
        <detaileddescription>
<para>This method allows users to quickly visualize the content of a datamap (single line) by dumping its raw or transformed content to a given output stream (eg std::cout).</para>
<para>Example usage: ParsedDataLineMapPtr datamap; dump(std::cout, datamap, false);</para>
<para>This dumps untransformed content of datamap to std::cout</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>stream</parametername>
</parameternamelist>
<parameterdescription>
<para>Stream to dump the content to. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>data</parametername>
</parameternamelist>
<parameterdescription>
<para>Datamap content to dump. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>showTransformed</parametername>
</parameternamelist>
<parameterdescription>
<para>Flag to show if it should dump raw values (false) or transformed values (true). </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>stream A reference to the ostream. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/Users/jonashener/tudatpy_dev/tudat-bundle/tudat/src/io/parsedDataVectorUtilities.cpp" line="160" column="14" bodyfile="/Users/jonashener/tudatpy_dev/tudat-bundle/tudat/src/io/parsedDataVectorUtilities.cpp" bodystart="160" bodyend="187" declfile="/Users/jonashener/tudatpy_dev/tudat-bundle/tudat/include/tudat/io/parsedDataVectorUtilities.h" declline="168" declcolumn="14"/>
      </memberdef>
      <memberdef kind="function" id="parsedDataVectorUtilities_8h_1aafbdceda8da81668f7a16508e9471650" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>std::ostream &amp;</type>
        <definition>std::ostream &amp; tudat::input_output::parsed_data_vector_utilities::dump</definition>
        <argsstring>(std::ostream &amp;stream, ParsedDataVectorPtr data, bool showTransformed)</argsstring>
        <name>dump</name>
        <param>
          <type>std::ostream &amp;</type>
          <declname>stream</declname>
        </param>
        <param>
          <type>ParsedDataVectorPtr</type>
          <declname>data</declname>
        </param>
        <param>
          <type>bool</type>
          <declname>showTransformed</declname>
        </param>
        <briefdescription>
<para>Dump the content of a data vector to an ostream (eg std::cout) </para>
        </briefdescription>
        <detaileddescription>
<para>Dump the content of a data vector to an ostream (eg std::cout).</para>
<para>This method allows users to quickly visualize the content of a data vector by dumping its raw or transformed content to a given output stream.</para>
<para>Example usage: ParsedDataVectorPtr datavector; dump(std::cout, datavector, false);</para>
<para>This dump untransformed content of datavector to std::cout.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>stream</parametername>
</parameternamelist>
<parameterdescription>
<para>Stream to dump the content to. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>data</parametername>
</parameternamelist>
<parameterdescription>
<para>Datavector content to dump. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>showTransformed</parametername>
</parameternamelist>
<parameterdescription>
<para>Flag to show if it should dump raw values (false) or transformed values (true) </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>A reference to the ostream </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/Users/jonashener/tudatpy_dev/tudat-bundle/tudat/src/io/parsedDataVectorUtilities.cpp" line="190" column="14" bodyfile="/Users/jonashener/tudatpy_dev/tudat-bundle/tudat/src/io/parsedDataVectorUtilities.cpp" bodystart="190" bodyend="203" declfile="/Users/jonashener/tudatpy_dev/tudat-bundle/tudat/include/tudat/io/parsedDataVectorUtilities.h" declline="187" declcolumn="14"/>
      </memberdef>
      </sectiondef>
    <briefdescription>
    </briefdescription>
    <detaileddescription>
    </detaileddescription>
    <location file="/Users/jonashener/tudatpy_dev/tudat-bundle/tudat/include/tudat/io/parsedDataVectorUtilities.h" line="30" column="1"/>
  </compounddef>
</doxygen>
