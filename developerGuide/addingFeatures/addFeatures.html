

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Adding Features to Tudat &mdash; TU Delft Astrodynamic Toolbox  documentation</title>
  

  
  
  
  

  

  
  
    

  

  
  
    <link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
  

  
    <link rel="stylesheet" href="../../_static/custom.css" type="text/css" />
  

  
        <link rel="index" title="Index"
              href="../../genindex.html"/>
        <link rel="search" title="Search" href="../../search.html"/>
    <link rel="top" title="TU Delft Astrodynamic Toolbox  documentation" href="../../index.html"/>
        <link rel="up" title="Developer Guide" href="../index.html"/>
        <link rel="next" title="Qt Basics" href="../qtBasics/qtBasics.html"/>
        <link rel="prev" title="Updating Tudat" href="../updatingTudat/updatingTudat.html"/> 

  
  <script src="../../_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav" role="document">

   
  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="../../index.html" class="icon icon-home"> TU Delft Astrodynamic Toolbox
          

          
          </a>

          
            
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">Contents</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../../index.html">Start Page</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../started/index.html">Getting Started</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../installation/index.html">Installation Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../tutorials/index.html">Tutorials and Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../FAQ/index.html">FAQ</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="../index.html">Developer Guide</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="../githubBasics/githubBasics.html">Github Basics</a></li>
<li class="toctree-l2"><a class="reference internal" href="../updatingTudat/updatingTudat.html">Updating Tudat</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">Adding Features to Tudat</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#adding-dependent-variables-to-save">Adding Dependent Variables to Save</a></li>
<li class="toctree-l3"><a class="reference internal" href="#adding-a-new-environment-model">Adding a New Environment Model</a></li>
<li class="toctree-l3"><a class="reference internal" href="#adding-a-new-acceleration-model">Adding a New Acceleration Model</a></li>
<li class="toctree-l3"><a class="reference internal" href="#adding-a-new-state-derivative-model">Adding a New State Derivative Model</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../qtBasics/qtBasics.html">Qt Basics</a></li>
<li class="toctree-l2"><a class="reference internal" href="../applicationCMakeLists/applicationCMakeLists.html">Application CMakelists</a></li>
<li class="toctree-l2"><a class="reference internal" href="../extendingJSON/index.html">Extending the JSON Interface</a></li>
<li class="toctree-l2"><a class="reference internal" href="../extendingMATLAB/index.html">Extending the MATLAB Interface</a></li>
<li class="toctree-l2"><a class="reference internal" href="../howToWriteTheWiki/howToWriteTheWiki.html">How to Write the Wiki</a></li>
</ul>
</li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">TU Delft Astrodynamic Toolbox</a>
        
      </nav>


      
      <div class="wy-nav-content">
        <div class="rst-content">
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../index.html">Docs</a> &raquo;</li>
        
          <li><a href="../index.html">Developer Guide</a> &raquo;</li>
        
      <li>Adding Features to Tudat</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="../../_sources/developerGuide/addingFeatures/addFeatures.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <blockquote>
<div></div></blockquote>
<div class="section" id="adding-features-to-tudat">
<span id="addingfeatures"></span><h1>Adding Features to Tudat<a class="headerlink" href="#adding-features-to-tudat" title="Permalink to this headline">¶</a></h1>
<p>In some cases, the various features of Tudat do not contain the tool(s) to solve a specific problem. As Tudat is written in C++ and all the source code is readily available to the user, it is possible to add features to the Tudat software. This does require a good understanding of the C++ language and of how Tudat works, thus it is only recommended to users who have been working with Tudat before.</p>
<div class="section" id="adding-dependent-variables-to-save">
<h2>Adding Dependent Variables to Save<a class="headerlink" href="#adding-dependent-variables-to-save" title="Permalink to this headline">¶</a></h2>
<p>As the execution of the simulator happens “behind closed doors” in the <code class="docutils literal"><span class="pre">DynamicsSimulator</span></code> function, it can be non-trivial to retrieve the history of dependent variables. Luckily, as explained in <a class="reference internal" href="../../tutorials/tudatFeatures/propagationSetup/propagatorSettingsDependentVariables.html#tudatfeaturespropagatorsettingsdependentvariables"><span class="std std-ref">Propagator Settings: Dependent Variables</span></a>, it is possible to create a list of dependent variables and use it as an input to the propagation settings to be able to retrieve a history of these dependent variables after the simulation is done. A list of the available dependent variables is given in: <a class="reference internal" href="../../tutorials/tudatFeatures/propagationSetup/propagatorSettingsDependentVariables.html#tudatfeaturespropagatorsettingsdependentvariables"><span class="std std-ref">Propagator Settings: Dependent Variables</span></a>. It is possible that another dependent variable is needed by the user, which is not given in this list. This guide will show how a new dependent variable can be added to the code.</p>
<p>To add a new dependent variable, four files will need to be changed, these are all located in the following directory:</p>
<blockquote>
<div>…/tudatBundle/tudat/Tudat/SimulationSetup/PropagationSetup/</div></blockquote>
<p>For this guide, the <code class="docutils literal"><span class="pre">mach_number_dependent_variable</span></code> will be used as an example of how a dependent variable is implemented. Be aware that there are some slight differences between the implementation of the <code class="docutils literal"><span class="pre">mach_number_dependent_variable</span></code> and other variables, but this will be explained in the guide.</p>
<p>The first addition needs to be made in the <code class="docutils literal"><span class="pre">propagationOutputSettings.h</span></code> file. Here, an <code class="docutils literal"><span class="pre">enum</span></code> called <code class="docutils literal"><span class="pre">PropagationDependentVariables</span></code> is given which shows the names of all the available dependent variables that can be saved. The list looks as follows;</p>
<div class="highlight-cpp"><div class="highlight"><pre><span></span><span class="k">enum</span> <span class="n">PropagationDependentVariables</span>
<span class="p">{</span>
    <span class="n">mach_number_dependent_variable</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
    <span class="n">altitude_dependent_variable</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
    <span class="n">airspeed_dependent_variable</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span>
    <span class="p">...</span>
    <span class="p">...</span>
    <span class="p">...</span>
    <span class="n">body_fixed_groundspeed_based_velocity_variable</span> <span class="o">=</span> <span class="mi">31</span><span class="p">,</span>
    <span class="n">keplerian_state_dependent_variable</span> <span class="o">=</span> <span class="mi">32</span><span class="p">,</span>
    <span class="n">modified_equinocial_state_dependent_variable</span> <span class="o">=</span> <span class="mi">33</span>
<span class="p">};</span>
</pre></div>
</div>
<p>The name of the new variable can thus be added to the end of the list, with a number assigned to it.</p>
<p>The next addition needs to be made in the <code class="docutils literal"><span class="pre">propagationOutputSettings.cpp</span></code> file. In this file, a method is present called: <code class="docutils literal"><span class="pre">getDependentVariableName</span></code>. This method contains a switch statement which contains cases for all the different dependent variables. For a new variable, a new case must be made with the name that was added to the <code class="docutils literal"><span class="pre">PropagationDependentVariables</span></code> list. Inside the case, a string called <code class="docutils literal"><span class="pre">variableName</span></code> must be assigned with the name of the to be added variable. In the case of the mach number, it looks as follows:</p>
<div class="highlight-cpp"><div class="highlight"><pre><span></span><span class="k">case</span> <span class="nl">mach_number_dependent_variable</span><span class="p">:</span>
    <span class="n">variableName</span> <span class="o">=</span> <span class="s">&quot;Mach number &quot;</span><span class="p">;</span>
    <span class="k">break</span><span class="p">;</span>
</pre></div>
</div>
<p>It is important to remember that the case should be the same as the name given in <code class="docutils literal"><span class="pre">PropagationDependentVariables</span></code>, but the <code class="docutils literal"><span class="pre">variableName</span></code> can be chosen to the preference of the user.</p>
<p>The third addition needs to be made in <code class="docutils literal"><span class="pre">propagationOutput.cpp</span></code>. Here a method called <code class="docutils literal"><span class="pre">getDependentVariableSize</span></code> is located. In this function, another switch statement is made with the same cases as before. Again a new case should be made for the new variable, but now, inside the case, another variable called <code class="docutils literal"><span class="pre">variableSize</span></code> should be changed to the size of the added variable. Thus this could be 1 for a <code class="docutils literal"><span class="pre">double</span></code>, or 3 for an <code class="docutils literal"><span class="pre">Eigen::Vector3d</span></code>. In the case of the mach number, it looks as follows:</p>
<div class="highlight-cpp"><div class="highlight"><pre><span></span><span class="k">case</span> <span class="nl">mach_number_dependent_variable</span><span class="p">:</span>
    <span class="n">variableSize</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="k">break</span><span class="p">;</span>
</pre></div>
</div>
<p>The final change should then be made to the <code class="docutils literal"><span class="pre">propagationOutput.h</span></code> file. In a method called <code class="docutils literal"><span class="pre">getDoubleDependentVariableFunction</span></code>, the actual calculation of the variable is done. Again, a switch stamentent in the same manner as before is made, with in every case the calculation of the variable. This method gets the <code class="docutils literal"><span class="pre">bodyMap</span></code> as input, thus methods available inside the <code class="docutils literal"><span class="pre">FlightConditions</span></code> could, for example, be used to calculate the dependent variable. For the new variable, a new case needs to be made in which a <code class="docutils literal"><span class="pre">std::function&lt;</span> <span class="pre">double(</span> <span class="pre">)&gt;</span></code> is returned. This function can take several variables as input and should return the dependent variable. The implementation for the mach number is given here:</p>
<div class="highlight-cpp"><div class="highlight"><pre><span></span>  <span class="k">case</span> <span class="nl">mach_number_dependent_variable</span><span class="p">:</span>
  <span class="p">{</span>
      <span class="k">if</span><span class="p">(</span> <span class="n">bodyMap</span><span class="p">.</span><span class="n">at</span><span class="p">(</span> <span class="n">bodyWithProperty</span> <span class="p">)</span><span class="o">-&gt;</span><span class="n">getFlightConditions</span><span class="p">(</span> <span class="p">)</span> <span class="o">==</span> <span class="nb">NULL</span> <span class="p">)</span>
      <span class="p">{</span>
          <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">errorMessage</span> <span class="o">=</span> <span class="s">&quot;Error, no flight conditions available when requesting Mach number output of &quot;</span> <span class="o">+</span>
                  <span class="n">bodyWithProperty</span> <span class="o">+</span> <span class="s">&quot;w.r.t.&quot;</span> <span class="o">+</span> <span class="n">secondaryBody</span><span class="p">;</span>
          <span class="k">throw</span> <span class="n">std</span><span class="o">::</span><span class="n">runtime_error</span><span class="p">(</span> <span class="n">errorMessage</span> <span class="p">);</span>
      <span class="p">}</span>

      <span class="n">std</span><span class="o">::</span><span class="n">function</span><span class="o">&lt;</span> <span class="kt">double</span><span class="p">(</span> <span class="k">const</span> <span class="kt">double</span><span class="p">,</span> <span class="k">const</span> <span class="kt">double</span> <span class="p">)</span> <span class="o">&gt;</span> <span class="n">functionToEvaluate</span> <span class="o">=</span>
              <span class="n">std</span><span class="o">::</span><span class="n">bind</span><span class="p">(</span> <span class="o">&amp;</span><span class="n">aerodynamics</span><span class="o">::</span><span class="n">computeMachNumber</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">placeholders</span><span class="o">::</span><span class="n">_1</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">placeholders</span><span class="o">::</span><span class="n">_2</span> <span class="p">);</span>

      <span class="c1">// Retrieve functions for airspeed and speed of sound.</span>
      <span class="n">std</span><span class="o">::</span><span class="n">function</span><span class="o">&lt;</span> <span class="kt">double</span><span class="p">(</span> <span class="p">)</span> <span class="o">&gt;</span> <span class="n">firstInput</span> <span class="o">=</span>
              <span class="n">std</span><span class="o">::</span><span class="n">bind</span><span class="p">(</span> <span class="o">&amp;</span><span class="n">aerodynamics</span><span class="o">::</span><span class="n">FlightConditions</span><span class="o">::</span><span class="n">getCurrentAirspeed</span><span class="p">,</span>
                           <span class="n">bodyMap</span><span class="p">.</span><span class="n">at</span><span class="p">(</span> <span class="n">bodyWithProperty</span> <span class="p">)</span><span class="o">-&gt;</span><span class="n">getFlightConditions</span><span class="p">(</span> <span class="p">)</span> <span class="p">);</span>
      <span class="n">std</span><span class="o">::</span><span class="n">function</span><span class="o">&lt;</span> <span class="kt">double</span><span class="p">(</span> <span class="p">)</span> <span class="o">&gt;</span> <span class="n">secondInput</span> <span class="o">=</span>
              <span class="n">std</span><span class="o">::</span><span class="n">bind</span><span class="p">(</span> <span class="o">&amp;</span><span class="n">aerodynamics</span><span class="o">::</span><span class="n">FlightConditions</span><span class="o">::</span><span class="n">getCurrentSpeedOfSound</span><span class="p">,</span>
                           <span class="n">bodyMap</span><span class="p">.</span><span class="n">at</span><span class="p">(</span> <span class="n">bodyWithProperty</span> <span class="p">)</span><span class="o">-&gt;</span><span class="n">getFlightConditions</span><span class="p">(</span> <span class="p">)</span> <span class="p">);</span>


      <span class="n">variableFunction</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">bind</span><span class="p">(</span> <span class="o">&amp;</span><span class="n">evaluateBivariateFunction</span><span class="o">&lt;</span> <span class="kt">double</span><span class="p">,</span> <span class="kt">double</span> <span class="o">&gt;</span><span class="p">,</span>
                                      <span class="n">functionToEvaluate</span><span class="p">,</span> <span class="n">firstInput</span><span class="p">,</span> <span class="n">secondInput</span> <span class="p">);</span>
      <span class="k">break</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>If the variable is a vector (or matrix) and not a double, the case should not be added to <code class="docutils literal"><span class="pre">getDoubleDependentVariableFunction</span></code>, but to: <code class="docutils literal"><span class="pre">getVectorDependentVariableFunction</span></code></p>
<p>If this is all done, the dependent variable name can be added to the dependent variables save list.</p>
</div>
<div class="section" id="adding-a-new-environment-model">
<h2>Adding a New Environment Model<a class="headerlink" href="#adding-a-new-environment-model" title="Permalink to this headline">¶</a></h2>
<p>Tudat contains various pre-built environment models that users are able to implement in their simulations. However, for some applications, it might be necesarry to alter an exisiting environment model, or add a completely new one. This section will describe how a new environment model can be added to Tudat.</p>
<p>First, it is important to understand how environment models are used in Tudat, this will give some insight in what needs to be added/changed if a new environment model is integrated into Tudat. For this tutorial, an existing environment model will be used as an example: the tabulated atmosphere model.</p>
<p>A user will define a list of bodies to be used in the simulation, an example is given here:</p>
<div class="highlight-cpp"><div class="highlight"><pre><span></span><span class="c1">// Define simulation body settings.</span>
<span class="n">std</span><span class="o">::</span><span class="n">map</span><span class="o">&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span> <span class="n">BodySettings</span> <span class="o">&gt;</span> <span class="o">&gt;</span> <span class="n">bodySettings</span> <span class="o">=</span>
        <span class="n">getDefaultBodySettings</span><span class="p">(</span> <span class="p">{</span> <span class="s">&quot;Mars&quot;</span> <span class="p">},</span> <span class="n">simulationStartEpoch</span> <span class="o">-</span> <span class="mf">10.0</span> <span class="o">*</span> <span class="n">fixedStepSize</span><span class="p">,</span>
                                <span class="n">simulationEndEpoch</span> <span class="o">+</span> <span class="mf">10.0</span> <span class="o">*</span> <span class="n">fixedStepSize</span> <span class="p">);</span>
<span class="n">bodySettings</span><span class="p">[</span> <span class="s">&quot;Mars&quot;</span> <span class="p">]</span><span class="o">-&gt;</span><span class="n">ephemerisSettings</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">make_shared</span><span class="o">&lt;</span> <span class="n">simulation_setup</span><span class="o">::</span><span class="n">ConstantEphemerisSettings</span> <span class="o">&gt;</span><span class="p">(</span>
            <span class="n">Eigen</span><span class="o">::</span><span class="n">Vector6d</span><span class="o">::</span><span class="n">Zero</span><span class="p">(</span> <span class="p">),</span> <span class="s">&quot;SSB&quot;</span><span class="p">,</span> <span class="s">&quot;J2000&quot;</span> <span class="p">);</span>
<span class="n">bodySettings</span><span class="p">[</span> <span class="s">&quot;Mars&quot;</span> <span class="p">]</span><span class="o">-&gt;</span><span class="n">rotationModelSettings</span><span class="o">-&gt;</span><span class="n">resetOriginalFrame</span><span class="p">(</span> <span class="s">&quot;J2000&quot;</span> <span class="p">);</span>
<span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">atmosphereFile</span> <span class="o">=</span> <span class="p">...</span> <span class="p">;</span>
<span class="n">bodySettings</span><span class="p">[</span> <span class="s">&quot;Mars&quot;</span> <span class="p">]</span><span class="o">-&gt;</span><span class="n">atmosphereSettings</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">make_shared</span><span class="o">&lt;</span> <span class="n">TabulatedAtmosphereSettings</span> <span class="o">&gt;</span><span class="p">(</span> <span class="n">atmosphereFile</span> <span class="p">);</span>
</pre></div>
</div>
<p>The <code class="docutils literal"><span class="pre">BodySettings</span></code> class contains a member variable called <code class="docutils literal"><span class="pre">atmosphereSettings</span></code> of type <code class="docutils literal"><span class="pre">AtmosphereSettings</span></code>. As can be seen in the last line of the example code above, this member variable is set to a <code class="docutils literal"><span class="pre">TabulatedAtmosphereSettings</span></code> by the user. This is a valid statement (eventhough <code class="docutils literal"><span class="pre">atmosphereSettings</span></code> is not of type <code class="docutils literal"><span class="pre">TabulatedAtmosphereSettings</span></code>) because <code class="docutils literal"><span class="pre">TabulatedAtmosphereSettings</span></code> is derived from the base class <code class="docutils literal"><span class="pre">AtmosphereSettings</span></code>. These concepts are called polymorphism and inheritance, and should be understood by the reader before continuing.</p>
<p>When all the <code class="docutils literal"><span class="pre">bodySettings</span></code> are defined by the user, the following command will be executed:</p>
<div class="highlight-cpp"><div class="highlight"><pre><span></span><span class="n">simulation_setup</span><span class="o">::</span><span class="n">NamedBodyMap</span> <span class="n">bodyMap</span> <span class="o">=</span> <span class="n">simulation_setup</span><span class="o">::</span><span class="n">createBodies</span><span class="p">(</span> <span class="n">bodySettings</span> <span class="p">);</span>
</pre></div>
</div>
<p>The <code class="docutils literal"><span class="pre">simulation_setup::createBodies()</span></code> will set all the environment models up to be used later in the simulation, and stores them in the variable <code class="docutils literal"><span class="pre">bodyMap</span></code>. If the <code class="docutils literal"><span class="pre">simulation_setup::createBodies()</span></code> is looked at, the following can be seen:</p>
<div class="highlight-cpp"><div class="highlight"><pre><span></span><span class="c1">// Create atmosphere model objects for each body (if required).</span>
<span class="k">for</span><span class="p">(</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">orderedBodySettings</span><span class="p">.</span><span class="n">size</span><span class="p">(</span> <span class="p">);</span> <span class="n">i</span><span class="o">++</span> <span class="p">)</span>
<span class="p">{</span>
    <span class="k">if</span><span class="p">(</span> <span class="n">orderedBodySettings</span><span class="p">.</span><span class="n">at</span><span class="p">(</span> <span class="n">i</span> <span class="p">).</span><span class="n">second</span><span class="o">-&gt;</span><span class="n">atmosphereSettings</span> <span class="o">!=</span> <span class="nb">NULL</span> <span class="p">)</span>
    <span class="p">{</span>
        <span class="n">bodyMap</span><span class="p">[</span> <span class="n">orderedBodySettings</span><span class="p">.</span><span class="n">at</span><span class="p">(</span> <span class="n">i</span> <span class="p">).</span><span class="n">first</span> <span class="p">]</span><span class="o">-&gt;</span><span class="n">setAtmosphereModel</span><span class="p">(</span>
                    <span class="n">createAtmosphereModel</span><span class="p">(</span> <span class="n">orderedBodySettings</span><span class="p">.</span><span class="n">at</span><span class="p">(</span> <span class="n">i</span> <span class="p">).</span><span class="n">second</span><span class="o">-&gt;</span><span class="n">atmosphereSettings</span><span class="p">,</span>
                                           <span class="n">orderedBodySettings</span><span class="p">.</span><span class="n">at</span><span class="p">(</span> <span class="n">i</span> <span class="p">).</span><span class="n">first</span> <span class="p">)</span> <span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Where <code class="docutils literal"><span class="pre">orderedBodySettings</span></code> is an ordered map of all the bodies. This code goes through all the bodies and checks if the bodies have an atmosphere model set or not. If not, the atmosphere model is set by the <code class="docutils literal"><span class="pre">setAtmosphereModel()</span></code> function, which takes as input a pointer to the atmosphereModel of the body. This pointer is returned by the function: <code class="docutils literal"><span class="pre">createAtmosphereModel()</span></code>, which creates the atmosphere model using the settings defined by the user in the variable <code class="docutils literal"><span class="pre">atmosphereSettings</span></code>. The <code class="docutils literal"><span class="pre">createAtmosphereModel()</span></code> looks as follows:</p>
<div class="highlight-cpp"><div class="highlight"><pre><span></span><span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span> <span class="n">aerodynamics</span><span class="o">::</span><span class="n">AtmosphereModel</span> <span class="o">&gt;</span> <span class="n">createAtmosphereModel</span><span class="p">(</span>
   <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span> <span class="n">AtmosphereSettings</span> <span class="o">&gt;</span> <span class="n">atmosphereSettings</span><span class="p">,</span>
   <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">body</span> <span class="p">)</span>
<span class="p">{</span>
    <span class="k">using</span> <span class="k">namespace</span> <span class="n">tudat</span><span class="o">::</span><span class="n">aerodynamics</span><span class="p">;</span>

    <span class="c1">// Declare return object.</span>
    <span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span> <span class="n">AtmosphereModel</span> <span class="o">&gt;</span> <span class="n">atmosphereModel</span><span class="p">;</span>

    <span class="c1">// Check which type of atmosphere model is to be created.</span>
    <span class="k">switch</span><span class="p">(</span> <span class="n">atmosphereSettings</span><span class="o">-&gt;</span><span class="n">getAtmosphereType</span><span class="p">(</span> <span class="p">)</span> <span class="p">)</span>
    <span class="p">{</span>
    <span class="k">case</span> <span class="nl">exponential_atmosphere</span><span class="p">:</span>
    <span class="p">{</span>
        <span class="p">...</span>
        <span class="p">...</span>
        <span class="p">...</span>
    <span class="p">}</span>
    <span class="k">case</span> <span class="nl">tabulated_atmosphere</span><span class="p">:</span>
    <span class="p">{</span>
        <span class="c1">// Check whether settings for atmosphere are consistent with its type</span>
        <span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span> <span class="n">TabulatedAtmosphereSettings</span> <span class="o">&gt;</span> <span class="n">tabulatedAtmosphereSettings</span> <span class="o">=</span>
                <span class="n">std</span><span class="o">::</span><span class="n">dynamic_pointer_cast</span><span class="o">&lt;</span> <span class="n">TabulatedAtmosphereSettings</span> <span class="o">&gt;</span><span class="p">(</span> <span class="n">atmosphereSettings</span> <span class="p">);</span>
        <span class="k">if</span><span class="p">(</span> <span class="n">tabulatedAtmosphereSettings</span> <span class="o">==</span> <span class="nb">NULL</span> <span class="p">)</span>
        <span class="p">{</span>
            <span class="k">throw</span> <span class="n">std</span><span class="o">::</span><span class="n">runtime_error</span><span class="p">(</span>
                        <span class="s">&quot;Error, expected tabulated atmosphere settings for body &quot;</span> <span class="o">+</span> <span class="n">body</span> <span class="p">);</span>
        <span class="p">}</span>
        <span class="k">else</span>
        <span class="p">{</span>
            <span class="c1">// Create and initialize tabulatedl atmosphere model.</span>
            <span class="n">atmosphereModel</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">make_shared</span><span class="o">&lt;</span> <span class="n">TabulatedAtmosphere</span> <span class="o">&gt;</span><span class="p">(</span>
                        <span class="n">tabulatedAtmosphereSettings</span><span class="o">-&gt;</span><span class="n">getAtmosphereFile</span><span class="p">(</span> <span class="p">)</span> <span class="p">);</span>
        <span class="p">}</span>
        <span class="k">break</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">case</span> <span class="nl">nrlmsise00</span><span class="p">:</span>
    <span class="p">{</span>
        <span class="p">...</span>
        <span class="p">...</span>
        <span class="p">...</span>
    <span class="p">}</span>
    <span class="k">default</span><span class="o">:</span>
        <span class="k">throw</span> <span class="n">std</span><span class="o">::</span><span class="n">runtime_error</span><span class="p">(</span>
                    <span class="s">&quot;Error, did not recognize atmosphere model settings type &quot;</span> <span class="o">+</span>
                    <span class="n">std</span><span class="o">::</span><span class="n">to_string</span><span class="p">(</span> <span class="n">atmosphereSettings</span><span class="o">-&gt;</span><span class="n">getAtmosphereType</span><span class="p">(</span> <span class="p">)</span> <span class="p">)</span> <span class="p">);</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="n">atmosphereModel</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>This function checks which atmosphere model is used by using a switch statement with the <code class="docutils literal"><span class="pre">atmosphereSettings-&gt;getAtmosphereType(</span> <span class="pre">)</span></code>. The three cases are defined using the enum <code class="docutils literal"><span class="pre">AtmosphereTypes</span></code> (located in <code class="docutils literal"><span class="pre">createAtmosphereModel.h</span></code>). In the case of the tabulated atmosphere, first a check is made if tabulated atmosphere setting are actually initialized. If they are, the <code class="docutils literal"><span class="pre">atmosphereModel</span></code> is set to a tabulated atmosphere using the settings from <code class="docutils literal"><span class="pre">atmosphereSettings</span></code>. It can be seen in the example code above that the variable <code class="docutils literal"><span class="pre">atmosphereModel</span></code> is of type <code class="docutils literal"><span class="pre">AtmosphereModel</span></code>, but it is set to a variable of type <code class="docutils literal"><span class="pre">TabulatedAtmosphere</span></code> in the tabulated atmosphere case. This is again valid due to the fact that the class <code class="docutils literal"><span class="pre">TabulatedAtmosphere</span></code> is derived from the base class <code class="docutils literal"><span class="pre">AtmosphereModel</span></code>.</p>
<p>After the atmosphere model is set in the body map, it can be used whenever a certain quantity, e.g. the density or temperature, is needed by another part of the simulation. How these quantities are calculated is defined in the <code class="docutils literal"><span class="pre">TabulatedAtmosphere</span></code> class.</p>
<p>Now that the creation of an environment model is understood, it can be discussed what should change in the Tudat code when something is added. There are two options when changing the code: the user can modify an existing environment model, or they can add a new model to an existing type of environment model. These type of modifications require different amount of changes made to Tudat and are thus explained seperately here:</p>
<ul class="simple">
<li><strong>Modify existing environment model:</strong> this option is the easiest as it only requires changes in the specific environment type files. If a function is added to an environment model, it is important to also include this function in the base class file of that specific environment model, with the virtual statement. For example, take the <code class="docutils literal"><span class="pre">getDensity()</span></code> function. This function is put in the file <code class="docutils literal"><span class="pre">AtmosphereModel.h</span></code> as a pure virtual function (don’t need a function definition), by putting a <code class="docutils literal"><span class="pre">=0</span></code> after the function definition and including the virtual statement. Now, in every derived class, this function should return something, depending on the implementation. If only something inside an already existing function needs to be changed, it (most of the time) shouldn’t be changed in all the derived classes. If a variable is added to the constructor of the class, it is important that all the cases that this class is called should be changed in the entire Tudat code to prevent errors (use the <code class="docutils literal"><span class="pre">find</span> <span class="pre">usages</span></code> option in Qt to find them).</li>
<li><strong>Add a new environment model:</strong> this modification requires some extra changes to the framework of the environment model implementation. First, when the new model is made, make sure that it is derived from the base class, and that it contains some of the basic functions. Once the new model is made, a <code class="docutils literal"><span class="pre">Settings</span></code> class should be made in the same way as <code class="docutils literal"><span class="pre">TabulatedAtmosphereSettings</span></code>. This class should be added to the <code class="docutils literal"><span class="pre">create...</span></code> files, and should contain functions that store variables that are used to call the constructor of the corresponding class (again, make sure it is derived from the proper base class). Then, in the corresponding <code class="docutils literal"><span class="pre">.cpp</span></code> file, a new case for the new environment model should be added to the <code class="docutils literal"><span class="pre">create...</span></code> function, just as in the tabulated atmosphere example. Make sure that in the <code class="docutils literal"><span class="pre">getAtmosphereType(</span> <span class="pre">)</span></code> function, the name of the new model is also included. In the case statement, make sure to add checks, and throw runtime errors if they are violated. Another step that needs to be taken is to update the <code class="docutils literal"><span class="pre">createEnvironmentUpdater.cpp</span></code> file. This file includes several switch statements that need to have the new acceleration model in it. Use the existing code to determine how the new case should be made.</li>
</ul>
</div>
<div class="section" id="adding-a-new-acceleration-model">
<h2>Adding a New Acceleration Model<a class="headerlink" href="#adding-a-new-acceleration-model" title="Permalink to this headline">¶</a></h2>
<p>For some applications, the various acceleration models in Tudat might not be sufficient. This guide will explain how acceleration models are set-up within Tudat, and how these models can be modified, or how to add a completely new model.</p>
<p>Just as before, it is important to understand the framework of the acceleration models. This will be explained using an example, namely the aerodynamic acceleration model. The first time the acceleration models will be needed is in the user’s own code. An example of how this can be done is shown below:</p>
<div class="highlight-cpp"><div class="highlight"><pre><span></span><span class="c1">// Define propagator settings variables.</span>
<span class="n">SelectedAccelerationMap</span> <span class="n">accelerationMap</span><span class="p">;</span>
<span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="o">&gt;</span> <span class="n">bodiesToPropagate</span><span class="p">;</span>
<span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="o">&gt;</span> <span class="n">centralBodies</span><span class="p">;</span>

<span class="c1">// Define acceleration model settings.</span>
<span class="n">std</span><span class="o">::</span><span class="n">map</span><span class="o">&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span> <span class="n">AccelerationSettings</span> <span class="o">&gt;</span> <span class="o">&gt;</span> <span class="o">&gt;</span> <span class="n">accelerationsOfWaverider</span><span class="p">;</span>
<span class="n">accelerationsOfWaverider</span><span class="p">[</span> <span class="s">&quot;Mars&quot;</span> <span class="p">].</span><span class="n">push_back</span><span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="n">make_shared</span><span class="o">&lt;</span> <span class="n">AccelerationSettings</span> <span class="o">&gt;</span><span class="p">(</span> <span class="n">aerodynamic</span> <span class="p">)</span> <span class="p">);</span>
<span class="n">accelerationMap</span><span class="p">[</span>  <span class="s">&quot;Vehicle&quot;</span> <span class="p">]</span> <span class="o">=</span> <span class="n">accelerationsOfWaverider</span><span class="p">;</span>

<span class="n">bodiesToPropagate</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span> <span class="s">&quot;Vehicle&quot;</span> <span class="p">);</span>
<span class="n">centralBodies</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span> <span class="s">&quot;Mars&quot;</span> <span class="p">);</span>

<span class="c1">// Create acceleration models</span>
<span class="n">basic_astrodynamics</span><span class="o">::</span><span class="n">AccelerationMap</span> <span class="n">accelerationModelMap</span> <span class="o">=</span> <span class="n">createAccelerationModelsMap</span><span class="p">(</span>
<span class="n">bodyMap</span><span class="p">,</span> <span class="n">accelerationMap</span><span class="p">,</span> <span class="n">bodiesToPropagate</span><span class="p">,</span> <span class="n">centralBodies</span> <span class="p">);</span>
</pre></div>
</div>
<p>The user will define a special map, with type <code class="docutils literal"><span class="pre">SelectedAccelerationMap</span></code> that works as follows: the first key defines the body exerting the acceleration, the second key the body undergoing the acceleration, and the value in the map is a vector of pointers to a type class called <code class="docutils literal"><span class="pre">AccelerationSettings</span></code>, which takes as input an <code class="docutils literal"><span class="pre">enum</span></code> called <code class="docutils literal"><span class="pre">AvailableAcceleration</span></code>, which lists all the available acceleration models. This map is then used as an input for the <code class="docutils literal"><span class="pre">createAccelerationModelsMap</span></code> function, which is a function that creates a special acceleration map that can be used as an input to the propagator settings.</p>
<p>There are two functions, located in <code class="docutils literal"><span class="pre">CreateAccelerationModels.cpp</span></code>, called <code class="docutils literal"><span class="pre">createAccelerationModelsMap</span></code>. The function that is called will first order the map, and then return the value of the other function, which takes as input the ordered map, made in the first <code class="docutils literal"><span class="pre">createAccelerationModelsMap</span></code>. The second function looks as follows:</p>
<div class="highlight-cpp"><div class="highlight"><pre><span></span><span class="c1">//! Function to create a set of acceleration models from a map of bodies and acceleration model types.</span>
<span class="n">basic_astrodynamics</span><span class="o">::</span><span class="n">AccelerationMap</span> <span class="n">createAccelerationModelsMap</span><span class="p">(</span>
       <span class="k">const</span> <span class="n">NamedBodyMap</span><span class="o">&amp;</span> <span class="n">bodyMap</span><span class="p">,</span>
       <span class="k">const</span> <span class="n">SelectedAccelerationMap</span><span class="o">&amp;</span> <span class="n">selectedAccelerationPerBody</span><span class="p">,</span>
       <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">map</span><span class="o">&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="o">&gt;&amp;</span> <span class="n">centralBodies</span> <span class="p">)</span>
<span class="p">{</span>
    <span class="p">...</span>
    <span class="p">...</span>
    <span class="p">...</span>
        <span class="n">currentAcceleration</span> <span class="o">=</span> <span class="n">createAccelerationModel</span><span class="p">(</span> <span class="n">bodyMap</span><span class="p">.</span><span class="n">at</span><span class="p">(</span> <span class="n">bodyUndergoingAcceleration</span> <span class="p">),</span>
                                                           <span class="n">bodyMap</span><span class="p">.</span><span class="n">at</span><span class="p">(</span> <span class="n">bodyExertingAcceleration</span> <span class="p">),</span>
                                                           <span class="n">accelerationsForBody</span><span class="p">.</span><span class="n">at</span><span class="p">(</span> <span class="n">i</span> <span class="p">).</span><span class="n">second</span><span class="p">,</span>
                                                           <span class="n">bodyUndergoingAcceleration</span><span class="p">,</span>
                                                           <span class="n">bodyExertingAcceleration</span><span class="p">,</span>
                                                           <span class="n">currentCentralBody</span><span class="p">,</span>
                                                           <span class="n">currentCentralBodyName</span><span class="p">,</span>
                                                           <span class="n">bodyMap</span> <span class="p">);</span>


        <span class="c1">// Create acceleration model.</span>
        <span class="n">mapOfAccelerationsForBody</span><span class="p">[</span> <span class="n">bodyExertingAcceleration</span> <span class="p">].</span><span class="n">push_back</span><span class="p">(</span>
                     <span class="n">currentAcceleration</span> <span class="p">);</span>

    <span class="p">...</span>
    <span class="p">...</span>
    <span class="p">...</span>
        <span class="c1">// Put acceleration models on current body in return map.</span>
        <span class="n">accelerationModelMap</span><span class="p">[</span> <span class="n">bodyUndergoingAcceleration</span> <span class="p">]</span> <span class="o">=</span> <span class="n">mapOfAccelerationsForBody</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">accelerationModelMap</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>This function does several checks if the right models are present, and then calls the <code class="docutils literal"><span class="pre">createAccelerationModel(</span> <span class="pre">)</span></code> function. This function is where the acceleration models are called and looks as follows:</p>
<div class="highlight-cpp"><div class="highlight"><pre><span></span><span class="c1">//! Function to create acceleration model object.</span>
<span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span> <span class="n">AccelerationModel</span><span class="o">&lt;</span> <span class="n">Eigen</span><span class="o">::</span><span class="n">Vector3d</span> <span class="o">&gt;</span> <span class="o">&gt;</span> <span class="n">createAccelerationModel</span><span class="p">(</span>
        <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span> <span class="n">Body</span> <span class="o">&gt;</span> <span class="n">bodyUndergoingAcceleration</span><span class="p">,</span>
        <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span> <span class="n">Body</span> <span class="o">&gt;</span> <span class="n">bodyExertingAcceleration</span><span class="p">,</span>
        <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span> <span class="n">AccelerationSettings</span> <span class="o">&gt;</span> <span class="n">accelerationSettings</span><span class="p">,</span>
        <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">nameOfBodyUndergoingAcceleration</span><span class="p">,</span>
        <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">nameOfBodyExertingAcceleration</span><span class="p">,</span>
        <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span> <span class="n">Body</span> <span class="o">&gt;</span> <span class="n">centralBody</span><span class="p">,</span>
        <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">nameOfCentralBody</span><span class="p">,</span>
        <span class="k">const</span> <span class="n">NamedBodyMap</span><span class="o">&amp;</span> <span class="n">bodyMap</span> <span class="p">)</span>
<span class="p">{</span>
    <span class="c1">// Declare pointer to return object.</span>
    <span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span> <span class="n">AccelerationModel</span><span class="o">&lt;</span> <span class="n">Eigen</span><span class="o">::</span><span class="n">Vector3d</span> <span class="o">&gt;</span> <span class="o">&gt;</span> <span class="n">accelerationModelPointer</span><span class="p">;</span>

    <span class="c1">// Switch to call correct acceleration model type factory function.</span>
    <span class="k">switch</span><span class="p">(</span> <span class="n">accelerationSettings</span><span class="o">-&gt;</span><span class="n">accelerationType_</span> <span class="p">)</span>
    <span class="p">{</span>
    <span class="p">...</span>
    <span class="p">...</span>
    <span class="p">...</span>
    <span class="k">case</span> <span class="nl">aerodynamic</span><span class="p">:</span>
        <span class="n">accelerationModelPointer</span> <span class="o">=</span> <span class="n">createAerodynamicAcceleratioModel</span><span class="p">(</span>
                    <span class="n">bodyUndergoingAcceleration</span><span class="p">,</span>
                    <span class="n">bodyExertingAcceleration</span><span class="p">,</span>
                    <span class="n">nameOfBodyUndergoingAcceleration</span><span class="p">,</span>
                    <span class="n">nameOfBodyExertingAcceleration</span> <span class="p">);</span>
        <span class="k">break</span><span class="p">;</span>
    <span class="p">...</span>
    <span class="p">...</span>
    <span class="p">...</span>
    <span class="k">default</span><span class="o">:</span>
        <span class="k">throw</span> <span class="n">std</span><span class="o">::</span><span class="n">runtime_error</span><span class="p">(</span>
                    <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">(</span> <span class="s">&quot;Error, acceleration model &quot;</span><span class="p">)</span> <span class="o">+</span>
                    <span class="n">std</span><span class="o">::</span><span class="n">to_string</span><span class="p">(</span> <span class="n">accelerationSettings</span><span class="o">-&gt;</span><span class="n">accelerationType_</span> <span class="p">)</span> <span class="o">+</span>
                    <span class="s">&quot; not recognized when making acceleration model of&quot;</span> <span class="o">+</span>
                    <span class="n">nameOfBodyExertingAcceleration</span> <span class="o">+</span> <span class="s">&quot; on &quot;</span> <span class="o">+</span>
                   <span class="n">nameOfBodyUndergoingAcceleration</span> <span class="p">);</span>
        <span class="k">break</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">accelerationModelPointer</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Ths function uses a switch statement on the <code class="docutils literal"><span class="pre">accelerationSettings-&gt;accelerationType_</span></code> (which was set by the user in the beginning), to determine which acceleration model needs to be called. The <code class="docutils literal"><span class="pre">createAerodynamicAcceleratioModel(</span> <span class="pre">)</span></code> then does several checks to determine if all the models that are used to calculate the aerodynamic force are present, after which it calls the constructor of the <code class="docutils literal"><span class="pre">AerodynamicAcceleration</span></code> class using the input values created in <code class="docutils literal"><span class="pre">createAerodynamicAcceleratioModel(</span> <span class="pre">)</span></code>. The structure of the <code class="docutils literal"><span class="pre">AerodynamicAcceleration</span></code> class, and how one can make a new acceleration model will be discussed in the next section.</p>
<p>When making a new acceleration model, there are two things that need to be added first. The first one is a new class containing functions to calculate the accelerations acting on the respective body. It is important that this class is derived from the base class: <code class="docutils literal"><span class="pre">basic_astrodynamics::AccelerationModel&lt;</span> <span class="pre">dataType</span> <span class="pre">&gt;</span></code>, where <code class="docutils literal"><span class="pre">dataType</span></code> is the type of the acceleration variable. Furthermore, there are two functions that need to be present in the new acceleration model class:</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">void</span> <span class="pre">updateMembers(const</span> <span class="pre">double</span> <span class="pre">currentTime</span> <span class="pre">=</span> <span class="pre">TUDAT_NAN)</span></code>. This function updates all the member variables to the current situation so they can be used by the other necessary function.</li>
<li><code class="docutils literal"><span class="pre">dataType</span> <span class="pre">getAcceleration(</span> <span class="pre">)</span></code>. This function uses the recently updated member variables to calculate the acceleration acting on the body.</li>
</ul>
<p>For the case of the aerodynamic acceleration, these two functions look as follows:</p>
<div class="highlight-cpp"><div class="highlight"><pre><span></span><span class="n">Eigen</span><span class="o">::</span><span class="n">Vector3d</span> <span class="n">getAcceleration</span><span class="p">(</span> <span class="p">)</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">computeAerodynamicAcceleration</span><span class="p">(</span>
                <span class="mf">0.5</span> <span class="o">*</span> <span class="n">currentDensity_</span> <span class="o">*</span> <span class="n">currentAirspeed_</span> <span class="o">*</span> <span class="n">currentAirspeed_</span><span class="p">,</span>
                <span class="n">currentReferenceArea_</span><span class="p">,</span> <span class="n">currentForceCoefficients_</span><span class="p">,</span> <span class="n">currentMass_</span> <span class="p">);</span>
<span class="p">}</span>


<span class="kt">void</span> <span class="n">updateMembers</span><span class="p">(</span> <span class="k">const</span> <span class="kt">double</span> <span class="n">currentTime</span> <span class="o">=</span> <span class="n">TUDAT_NAN</span> <span class="p">)</span>
<span class="p">{</span>
    <span class="k">if</span><span class="p">(</span> <span class="o">!</span><span class="p">(</span> <span class="k">this</span><span class="o">-&gt;</span><span class="n">currentTime_</span> <span class="o">==</span> <span class="n">currentTime</span> <span class="p">)</span> <span class="p">)</span>
    <span class="p">{</span>
        <span class="n">currentForceCoefficients_</span> <span class="o">=</span> <span class="n">coefficientMultiplier_</span> <span class="o">*</span> <span class="k">this</span><span class="o">-&gt;</span><span class="n">coefficientFunction_</span><span class="p">(</span> <span class="p">);</span>
        <span class="n">currentDensity_</span> <span class="o">=</span> <span class="k">this</span><span class="o">-&gt;</span><span class="n">densityFunction_</span><span class="p">(</span> <span class="p">);</span>
        <span class="n">currentMass_</span> <span class="o">=</span> <span class="k">this</span><span class="o">-&gt;</span><span class="n">massFunction_</span><span class="p">(</span> <span class="p">);</span>
        <span class="n">currentAirspeed_</span> <span class="o">=</span> <span class="k">this</span><span class="o">-&gt;</span><span class="n">airSpeedFunction_</span><span class="p">(</span> <span class="p">);</span>
        <span class="n">currentReferenceArea_</span> <span class="o">=</span> <span class="k">this</span><span class="o">-&gt;</span><span class="n">referenceAreaFunction_</span><span class="p">(</span> <span class="p">);</span>

        <span class="n">currentTime_</span> <span class="o">=</span> <span class="n">currentTime</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>where <code class="docutils literal"><span class="pre">computeAcceleration()</span></code> is a function that uses the well known lift, side, and drag acceleration equations to calculate the acceleration vector.</p>
<p>The second piece of code that needs to be added is the new create function inside <code class="docutils literal"><span class="pre">createAccelerationModel.cpp</span></code>. This function should return a pointer to the respective acceleration class, and takes as input the various models needed for the calculation of the acceleration. The main goal of this function is to do some checks if the necessary models are present, and either throw an error, or initialize the model there. When this is done, it uses all the available models as input to the acceleration model, and returns a pointer to this class.</p>
<p>Once the acceleration class is made, and the create function is in place, the acceleration model should be implemented into the acceleration framework. The first step for this is to add the a new model to the <code class="docutils literal"><span class="pre">AvailableAcceleration</span></code> enum. This name could be anything, as long as it relates to the actual acceleration model. Nothing has to be added to the <code class="docutils literal"><span class="pre">createAccelerationModelsMap</span></code>, however, the <code class="docutils literal"><span class="pre">createAccelerationModel</span></code> function has a switch statement that needs to be altered. This switch statement checks the <code class="docutils literal"><span class="pre">accelerationSettings</span></code> of the specific body to see which acceleration is acting on the body. When a new acceleration model is made, a new case should be made for the new model. This case should have the same name as the name added to the <code class="docutils literal"><span class="pre">AvailableAcceleration</span></code> enum. Inside this case, the variable <code class="docutils literal"><span class="pre">accelerationModelPointer</span></code> should be assigned to the create acceleration model function, which was made before. When this is done, the new acceleration model should be incorporated into the acceleration framework of tudat.</p>
</div>
<div class="section" id="adding-a-new-state-derivative-model">
<h2>Adding a New State Derivative Model<a class="headerlink" href="#adding-a-new-state-derivative-model" title="Permalink to this headline">¶</a></h2>
<p>Another type of model which allows the user to add extra features to it, is the state derivative model. These models are used by the dynamics simulator to determine how the state equations are solved. Currently there are several available, e.g. cowell state derivative model, encke state derivate model, and more, but if a special model is needed for a certain application, the user can add this to tudat by following this guide.</p>
<p>As before, this guide will start by looking at the framework of how the state derivative model is implemented. First, the state derivative model is chosen by the user from an enum called <code class="docutils literal"><span class="pre">TranslationalPropagatorType</span></code>, located in <code class="docutils literal"><span class="pre">nBodyStateDerivativeModel.h</span></code>. The model picked from this enum is then used as an input into the constructor of the <code class="docutils literal"><span class="pre">TranslationalPropagatorSettings</span></code>, where it is assigned to a specific member variable called: <code class="docutils literal"><span class="pre">propagator_</span></code>. The <code class="docutils literal"><span class="pre">TranslationalPropagatorSettings</span></code> is used as an input to the <code class="docutils literal"><span class="pre">SingleArcDynamicsSimulator</span></code>, where it will be used further. An example of this is shown below:</p>
<div class="highlight-cpp"><div class="highlight"><pre><span></span> <span class="c1">// Create propagation settings.</span>
 <span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span> <span class="n">TranslationalStatePropagatorSettings</span><span class="o">&lt;</span> <span class="kt">double</span> <span class="o">&gt;</span> <span class="o">&gt;</span> <span class="n">propagatorSettings</span> <span class="o">=</span>
         <span class="n">std</span><span class="o">::</span><span class="n">make_shared</span><span class="o">&lt;</span> <span class="n">TranslationalStatePropagatorSettings</span><span class="o">&lt;</span> <span class="kt">double</span> <span class="o">&gt;</span> <span class="o">&gt;</span>
         <span class="p">(</span> <span class="n">centralBodies</span><span class="p">,</span> <span class="n">accelerationModelMap</span><span class="p">,</span> <span class="n">bodiesToPropagate</span><span class="p">,</span> <span class="n">systemInitialState</span><span class="p">,</span>
           <span class="n">terminationSettings</span><span class="p">,</span> <span class="n">cowell</span><span class="p">,</span> <span class="n">dependentVariablesToSave</span> <span class="p">);</span>

<span class="c1">// Create simulation object and propagate dynamics.</span>
<span class="n">SingleArcDynamicsSimulator</span><span class="o">&lt;</span> <span class="o">&gt;</span> <span class="n">dynamicsSimulator</span><span class="p">(</span>
         <span class="n">bodyMap</span><span class="p">,</span> <span class="n">integratorSettings</span><span class="p">,</span> <span class="n">propagatorSettings</span> <span class="p">);</span>
</pre></div>
</div>
<p>Inside <code class="docutils literal"><span class="pre">SingleArcDynamicsSimulator</span></code>, the propagator settings are passed to various functions, but the state derivative model is only needed in <code class="docutils literal"><span class="pre">createStateDerivativeModels</span></code>. This function returns a vector of <code class="docutils literal"><span class="pre">SingleStateTypeDerivative</span></code>. If a hybrid state derivative model is used, this function will fill the vector with state derivative models. If not, this vector will only contain one state derivative model, created by the function (equally) called <code class="docutils literal"><span class="pre">createStateDerivativeModels</span></code>. This function checks what kind of state is propagated (translational, rotational, etc.) and creates the specific state derivative model. For example, for the translational state it will call the <code class="docutils literal"><span class="pre">createTranslationalStateDerivativeModel</span></code> function. This function looks as follows:</p>
<div class="highlight-cpp"><div class="highlight"><pre><span></span> <span class="k">template</span><span class="o">&lt;</span> <span class="k">typename</span> <span class="n">StateScalarType</span> <span class="o">=</span> <span class="kt">double</span><span class="p">,</span> <span class="k">typename</span> <span class="n">TimeType</span> <span class="o">=</span> <span class="kt">double</span> <span class="o">&gt;</span>
 <span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span> <span class="n">SingleStateTypeDerivative</span><span class="o">&lt;</span> <span class="n">StateScalarType</span><span class="p">,</span> <span class="n">TimeType</span> <span class="o">&gt;</span> <span class="o">&gt;</span>
 <span class="n">createTranslationalStateDerivativeModel</span><span class="p">(</span>
        <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span> <span class="n">TranslationalStatePropagatorSettings</span><span class="o">&lt;</span> <span class="n">StateScalarType</span> <span class="o">&gt;</span> <span class="o">&gt;</span>
        <span class="n">translationPropagatorSettings</span><span class="p">,</span>
        <span class="k">const</span> <span class="n">simulation_setup</span><span class="o">::</span><span class="n">NamedBodyMap</span><span class="o">&amp;</span> <span class="n">bodyMap</span><span class="p">,</span>
        <span class="k">const</span> <span class="n">TimeType</span> <span class="n">propagationStartTime</span> <span class="p">)</span>
<span class="p">{</span>

    <span class="c1">// Create object for frame origin transformations.</span>
    <span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span> <span class="n">CentralBodyData</span><span class="o">&lt;</span> <span class="n">StateScalarType</span><span class="p">,</span> <span class="n">TimeType</span> <span class="o">&gt;</span> <span class="o">&gt;</span> <span class="n">centralBodyData</span> <span class="o">=</span>
            <span class="n">createCentralBodyData</span><span class="o">&lt;</span> <span class="n">StateScalarType</span><span class="p">,</span> <span class="n">TimeType</span> <span class="o">&gt;</span><span class="p">(</span>
                <span class="n">translationPropagatorSettings</span><span class="o">-&gt;</span><span class="n">centralBodies_</span><span class="p">,</span>
                <span class="n">translationPropagatorSettings</span><span class="o">-&gt;</span><span class="n">bodiesToIntegrate_</span><span class="p">,</span>
                <span class="n">bodyMap</span> <span class="p">);</span>

    <span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span> <span class="n">SingleStateTypeDerivative</span><span class="o">&lt;</span> <span class="n">StateScalarType</span><span class="p">,</span> <span class="n">TimeType</span> <span class="o">&gt;</span> <span class="o">&gt;</span> <span class="n">stateDerivativeModel</span><span class="p">;</span>

    <span class="c1">// Check propagator type and create corresponding state derivative object.</span>
    <span class="k">switch</span><span class="p">(</span> <span class="n">translationPropagatorSettings</span><span class="o">-&gt;</span><span class="n">propagator_</span> <span class="p">)</span>
    <span class="p">{</span>
    <span class="k">case</span> <span class="nl">cowell</span><span class="p">:</span>
    <span class="p">{</span>
        <span class="n">stateDerivativeModel</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">make_shared</span><span class="o">&lt;</span>
                <span class="n">NBodyCowellStateDerivative</span><span class="o">&lt;</span> <span class="n">StateScalarType</span><span class="p">,</span> <span class="n">TimeType</span> <span class="o">&gt;</span> <span class="o">&gt;</span>
                <span class="p">(</span> <span class="n">translationPropagatorSettings</span><span class="o">-&gt;</span><span class="n">getAccelerationsMap</span><span class="p">(</span> <span class="p">),</span> <span class="n">centralBodyData</span><span class="p">,</span>
                  <span class="n">translationPropagatorSettings</span><span class="o">-&gt;</span><span class="n">bodiesToIntegrate_</span> <span class="p">);</span>
        <span class="k">break</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="p">...</span>
    <span class="p">...</span>
    <span class="p">...</span>
    <span class="p">}</span>
    <span class="k">default</span><span class="o">:</span>
        <span class="k">throw</span> <span class="n">std</span><span class="o">::</span><span class="n">runtime_error</span><span class="p">(</span>
                    <span class="s">&quot;Error, did not recognize translational state propagation type: &quot;</span> <span class="o">+</span>
                    <span class="n">std</span><span class="o">::</span><span class="n">to_string</span><span class="p">(</span> <span class="n">translationPropagatorSettings</span><span class="o">-&gt;</span><span class="n">propagator_</span> <span class="p">)</span> <span class="p">);</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">stateDerivativeModel</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>This function is responsible for making the state derivate model based on the <code class="docutils literal"><span class="pre">TranslationalPropagatorType</span></code> variable decalred by the user, using a switch statement.</p>
<p>When a new state derivative model is implemented in tudat, two additions need to be made to the framework (besides making the model itself). The first part is to add the name of the model to the enum: <code class="docutils literal"><span class="pre">TranslationalPropagatorType</span></code>. This will allow the user to pick this model and use it as an input to the translational propagator settings. The second step is to add this model to the switch statement in <code class="docutils literal"><span class="pre">createTranslationalStateDerivativeModel</span></code>. A new case should be made for the name added to the enum before, and in it, the variable <code class="docutils literal"><span class="pre">stateDerivativeModel</span></code> should be assigned to the new model.</p>
<p>When building the new model, it is advised to use a state derivative model that is already available as an example for a place to start. The classes which contain these models are derived from the base class <code class="docutils literal"><span class="pre">NBodyStateDerivative</span></code>, and should contain a template for the <code class="docutils literal"><span class="pre">TimeType</span></code> that will be used. The <code class="docutils literal"><span class="pre">NBodyStateDerivative</span></code> class is again derived from another class called the <code class="docutils literal"><span class="pre">SingleStateTypeDerivative</span></code>. This class contains several pure virtual functions, which all should be added to the new model class in order for the new model to work. The specific names and input parameters of these functions can be found in the <code class="docutils literal"><span class="pre">SingleStateTypeDerivative</span></code> class. Once this is done, and the new model is implemented in the state derivative model framework, the new model should be available for the user.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Don’t forget to put the include statement in <code class="docutils literal"><span class="pre">createStateDerivativeModel.h</span></code> if the new class is made in a seperate file.</p>
</div>
</div>
</div>


           </div>
           <div class="articleComments">
            
           </div>
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="../qtBasics/qtBasics.html" class="btn btn-neutral float-right" title="Qt Basics" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="../updatingTudat/updatingTudat.html" class="btn btn-neutral" title="Updating Tudat" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2017, Delft University of Technology.

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'../../',
            VERSION:'',
            LANGUAGE:'None',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true,
            SOURCELINK_SUFFIX: '.txt'
        };
    </script>
      <script type="text/javascript" src="../../_static/jquery.js"></script>
      <script type="text/javascript" src="../../_static/underscore.js"></script>
      <script type="text/javascript" src="../../_static/doctools.js"></script>
      <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

  

  
  
    <script type="text/javascript" src="../../_static/js/theme.js"></script>
  

  
  
  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.StickyNav.enable();
      });
  </script>
  
 <script type="text/javascript">
    $(document).ready(function() {
        $(".toggle > *").hide();
        $(".toggle .header").show();
        $(".toggle .header .arrow").click(function() {
            $(this).closest('.toggle').children().not(".header").toggle(400);
            $(this).toggleClass("open");
            // $(this).html() == "More" ? $(this).html('Less') : $(this).html('More');
        });
        $(".showall").click(function() {
            $(".toggle > *").show(400);
            $(".toggle .header .arrow").addClass("open");
        });
        $(".hideall").click(function() {
            $(".toggle > *").hide(400);
            $(".toggle .header").show(400);
            $(".toggle .header .arrow").removeClass("open");
        });
    });
</script>


</body>
</html>