

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>6.3. Simulating Observations &mdash; TU Delft Astrodynamic Toolbox  documentation</title>
  

  
  
  
  

  

  
  
    

  

  
  
    <link rel="stylesheet" href="../../../_static/css/theme.css" type="text/css" />
  

  
    <link rel="stylesheet" href="../../../_static/custom.css" type="text/css" />
  

  
        <link rel="index" title="Index"
              href="../../../genindex.html"/>
        <link rel="search" title="Search" href="../../../search.html"/>
    <link rel="top" title="TU Delft Astrodynamic Toolbox  documentation" href="../../../index.html"/>
        <link rel="up" title="6. Estimation Set-Up" href="index.html"/>
        <link rel="next" title="6.4. Setting Up Estimated Parameters" href="parameterEstimationSettings.html"/>
        <link rel="prev" title="6.2. Setting up Observation Models" href="observationModelSetup.html"/> 

  
  <script src="../../../_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav" role="document">

   
  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="../../../index.html" class="icon icon-home"> TU Delft Astrodynamic Toolbox
          

          
          </a>

          
            
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">Contents</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../../../index.html">Start Page</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../started/index.html">Getting Started</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../installation/index.html">Installation Guide</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="../../index.html">Tutorials and Documentation</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="../../basics/index.html">Tudat Basics</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../applicationWalkthroughs/index.html">Application Tutorials</a></li>
<li class="toctree-l2 current"><a class="reference internal" href="../index.html">Tudat Libraries</a><ul class="current">
<li class="toctree-l3"><a class="reference internal" href="../astroTools/index.html">1. Basic Astrodynamics Tools</a></li>
<li class="toctree-l3"><a class="reference internal" href="../mathTools/index.html">2. Basic Mathematics Tools</a></li>
<li class="toctree-l3"><a class="reference internal" href="../environmentSetup/index.html">3. Environment Set-up</a></li>
<li class="toctree-l3"><a class="reference internal" href="../accelerationSetup/index.html">4. Setting up State Derivative Models</a></li>
<li class="toctree-l3"><a class="reference internal" href="../propagationSetup/index.html">5. Simulator Set-Up</a></li>
<li class="toctree-l3 current"><a class="reference internal" href="index.html">6. Estimation Set-Up</a><ul class="current">
<li class="toctree-l4"><a class="reference internal" href="linkEndSetup.html">6.1. Setting up the link ends</a></li>
<li class="toctree-l4"><a class="reference internal" href="observationModelSetup.html">6.2. Setting up Observation Models</a></li>
<li class="toctree-l4 current"><a class="current reference internal" href="#">6.3. Simulating Observations</a></li>
<li class="toctree-l4"><a class="reference internal" href="parameterEstimationSettings.html">6.4. Setting Up Estimated Parameters</a></li>
<li class="toctree-l4"><a class="reference internal" href="estimationExecution.html">6.5. Parameter Estimation</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../otherLibraries/index.html">7. Other Libraries</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../jsonInterface/index.html">JSON Interface</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../matlabInterface/index.html">MATLAB Interface</a></li>
<li class="toctree-l2"><a class="reference external" href="http://doxygen.tudat.tudelft.nl">Doxygen</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../troubleshooting/index.html">Troubleshooting</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../../FAQ/index.html">FAQ</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../developerGuide/index.html">Developer Guide</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">TU Delft Astrodynamic Toolbox</a>
        
      </nav>


      
      <div class="wy-nav-content">
        <div class="rst-content">
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../../index.html">Docs</a> &raquo;</li>
        
          <li><a href="../../index.html">Tutorials and Documentation</a> &raquo;</li>
        
          <li><a href="../index.html">Tudat Libraries</a> &raquo;</li>
        
          <li><a href="index.html">6. Estimation Set-Up</a> &raquo;</li>
        
      <li>6.3. Simulating Observations</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="../../../_sources/tutorials/tudatFeatures/estimationSetup/observationSimulation.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="simulating-observations">
<span id="observationsimulation"></span><h1>6.3. Simulating Observations<a class="headerlink" href="#simulating-observations" title="Permalink to this headline">¶</a></h1>
<div class="section" id="creating-the-observation-simulator">
<span id="creatingobservationsimulators"></span><h2>6.3.1. Creating the Observation Simulator<a class="headerlink" href="#creating-the-observation-simulator" title="Permalink to this headline">¶</a></h2>
<p>In Tudat, a set of observations are simulated using the <code class="xref py py-class docutils literal"><span class="pre">ObservationSimulatorBase</span></code> class. An object of this class is used to simulate observations of a single type, for any number of <code class="xref py py-class docutils literal"><span class="pre">LinkEnds</span></code>. The <code class="xref py py-class docutils literal"><span class="pre">ObservationSimulatorBase</span></code> has, like many of the classes in Tudat a number of template arguments, one for the scalar type of the observable and one for the time type. Note that the state scalar used in numerical propagation should be equal to the scalar type of the observable to make full use of the functionality.</p>
<p>There are two ways in which to obtain <code class="xref py py-class docutils literal"><span class="pre">ObservationSimulatorBase</span></code> objects:</p>
<ul>
<li><p class="first">When creating a <a class="reference internal" href="estimationExecution.html#OrbitDeterminationManager" title="OrbitDeterminationManager"><code class="xref py py-class docutils literal"><span class="pre">OrbitDeterminationManager</span></code></a> class, a set of <code class="xref py py-class docutils literal"><span class="pre">ObservationSimulatorBase</span></code> objects are automatically created. Retrieving these is done simply by:</p>
<blockquote>
<div><div class="highlight-cpp"><div class="highlight"><pre><span></span><span class="n">OrbitDeterminationManager</span><span class="o">&lt;</span> <span class="n">ObservationScalarType</span><span class="p">,</span> <span class="n">TimeType</span> <span class="o">&gt;</span> <span class="n">orbitDeterminationManager</span> <span class="o">=</span> <span class="p">.....</span> <span class="c1">//OrbitDeterminationManager object created here.</span>

<span class="n">std</span><span class="o">::</span><span class="n">map</span><span class="o">&lt;</span> <span class="n">ObservableType</span><span class="p">,</span> <span class="n">boost</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span> <span class="n">ObservationSimulatorBase</span><span class="o">&lt;</span> <span class="n">ObservationScalarType</span><span class="p">,</span> <span class="n">TimeType</span> <span class="o">&gt;</span> <span class="o">&gt;</span> <span class="o">&gt;</span> <span class="n">observationSimulators</span> <span class="o">=</span>
   <span class="n">orbitDeterminationManager</span><span class="p">.</span><span class="n">getObservationSimulators</span><span class="p">(</span> <span class="p">);</span>
</pre></div>
</div>
<p>This returns the <code class="docutils literal"><span class="pre">observationSimulators</span></code> list, which contains an observation simulator for each <code class="docutils literal"><span class="pre">ObservableType</span></code> defined in your orbit determination manager.</p>
</div></blockquote>
</li>
<li><p class="first">You can also create an <code class="xref py py-class docutils literal"><span class="pre">ObservationSimulatorBase</span></code> directly, without using an <code class="docutils literal"><span class="pre">OrbitDeterminationManager</span></code> object.</p>
<blockquote>
<div><div class="highlight-cpp"><div class="highlight"><pre><span></span><span class="c1">// Define type of observable</span>
<span class="n">ObservableType</span> <span class="n">observableType</span> <span class="o">=</span> <span class="p">....</span>

<span class="c1">// Define observation settings for each require LinkEnds</span>
<span class="n">std</span><span class="o">::</span><span class="n">map</span><span class="o">&lt;</span> <span class="n">LinkEnds</span><span class="p">,</span> <span class="n">boost</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span> <span class="n">ObservationSettings</span>  <span class="o">&gt;</span> <span class="o">&gt;</span> <span class="n">settingsPerLinkEnds</span> <span class="o">=</span> <span class="p">....</span>

<span class="c1">// Define environment</span>
<span class="n">NamedBodyMap</span> <span class="n">bodyMap</span> <span class="o">=</span> <span class="p">....</span>

<span class="c1">// Create observation simulator</span>
<span class="n">boost</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span> <span class="n">ObservationSimulatorBase</span><span class="o">&lt;</span> <span class="n">ObservationScalarType</span><span class="p">,</span> <span class="n">TimeType</span> <span class="o">&gt;</span> <span class="o">&gt;</span> <span class="n">observationSimulator</span> <span class="o">=</span>
   <span class="n">createObservationSimulator</span><span class="p">(</span> <span class="n">observableType</span><span class="p">,</span> <span class="n">settingsPerLinkEnds</span><span class="p">,</span> <span class="n">bodyMap</span> <span class="p">);</span>
</pre></div>
</div>
</div></blockquote>
</li>
</ul>
<p>In either case, this provides you with an object of type <code class="docutils literal"><span class="pre">ObservationSimulatorBase</span></code>.</p>
</div>
<div class="section" id="observation-simulation-settings">
<h2>6.3.2. Observation Simulation Settings<a class="headerlink" href="#observation-simulation-settings" title="Permalink to this headline">¶</a></h2>
<p>The times at which observations are simulated may be defined directly by the user, or they may depend on some scheduling algorithm, which is then used to determine the observation times. The final observation times are determined by a combination of <code class="xref py py-class docutils literal"><span class="pre">ObservationSimulationTimeSettings</span></code> objects and <code class="docutils literal"><span class="pre">ObservationViabilitySettings</span></code> objects. The former allows you to define observation times directly, or an observation schedule algorithm. The latter defines constraints that must be met for an observation to be possible. The viability settings are discussed on the page <a class="reference internal" href="#observationviability"><span class="std std-ref">Observation Viability Setttings</span></a>.</p>
<p>Each type of observation settings is defined by a dedicated derived class of <code class="xref py py-class docutils literal"><span class="pre">ObservationSimulationTimeSettings</span></code>. This class has a <code class="docutils literal"><span class="pre">TimeType</span></code> argument, which is discussed in more detail <span class="xref std std-ref">tudatTemplatingStateTime</span>. The following classes are presently available:</p>
<dl class="class">
<dt id="TabulatedObservationSimulationTimeSettings">
<em class="property">class </em><code class="descname">TabulatedObservationSimulationTimeSettings</code><a class="headerlink" href="#TabulatedObservationSimulationTimeSettings" title="Permalink to this definition">¶</a></dt>
<dd><p>The <code class="docutils literal"><span class="pre">TabulatedObservationSimulationTimeSettings</span></code> class is used to define a simple list of times at which observations are simulated.</p>
<div class="highlight-cpp"><div class="highlight"><pre><span></span><span class="n">boost</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span> <span class="n">TabulatedObservationSimulationTimeSettings</span><span class="o">&lt;</span> <span class="n">TimeType</span> <span class="o">&gt;</span> <span class="o">&gt;</span> <span class="n">observationSettings</span> <span class="o">=</span>
      <span class="n">boost</span><span class="o">::</span><span class="n">make_shared</span><span class="o">&lt;</span> <span class="n">TabulatedObservationSimulationTimeSettings</span><span class="o">&lt;</span> <span class="n">TimeType</span> <span class="o">&gt;</span> <span class="o">&gt;</span><span class="p">(</span>
          <span class="n">linkEndType</span><span class="p">,</span> <span class="n">simulationTimes</span> <span class="p">);</span>
</pre></div>
</div>
<p>The input is:</p>
<ul>
<li><p class="first"><code class="docutils literal"><span class="pre">linkEndType</span></code></p>
<blockquote>
<div><p>A <code class="docutils literal"><span class="pre">LinkEndType</span></code> variable denoting the reference link end type for the observation times.</p>
</div></blockquote>
</li>
<li><p class="first"><code class="docutils literal"><span class="pre">simulationTimes</span></code></p>
<blockquote>
<div><p>A <code class="docutils literal"><span class="pre">std::vector&lt;</span> <span class="pre">TimeType</span> <span class="pre">&gt;</span></code> variable, containing the list of times at which observations are to be simulated.</p>
</div></blockquote>
</li>
</ul>
</dd></dl>

</div>
<div class="section" id="observation-viability-setttings">
<span id="observationviability"></span><h2>6.3.3. Observation Viability Setttings<a class="headerlink" href="#observation-viability-setttings" title="Permalink to this headline">¶</a></h2>
<p>In many cases, you will not have the list of observation times <em>a priori</em>. Instead, the observation times could be a function of the states of the link ends, and depend on a number of constraints that must be satisfied for an observation to be possible. The constraints defined in Tudat are listed in the <code class="docutils literal"><span class="pre">ObservationViabilityType</span></code> enum, which can take the following values:</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">minimum_elevation_angle</span></code>: Minimum elevation angle at a ground station: target must be at least a certain elevation above the horizon.</li>
<li><code class="docutils literal"><span class="pre">body_avoidance_angle</span></code>: Body avoidance angle: the line-of-sight vector from a link end to a given third body must have an angle w.r.t. the line-of-sight between link ends that is sufficiently large. This constraint is typically used to prevent the Sun from being too close to the field-of-view of the telescope(s).</li>
<li><code class="docutils literal"><span class="pre">body_occultation</span></code>: Body occultation: the link must not be obscured by a given third body.  For instance: the Moon occulting a link between Earth and Mars.</li>
</ul>
<p>In Tudat, such constraints are defined by objects of the <code class="docutils literal"><span class="pre">ObservationViabilitySettings</span></code> class.</p>
<dl class="class">
<dt id="ObservationViabilitySettings">
<em class="property">class </em><code class="descname">ObservationViabilitySettings</code><a class="headerlink" href="#ObservationViabilitySettings" title="Permalink to this definition">¶</a></dt>
<dd><p>The <code class="docutils literal"><span class="pre">ObservationViabilitySettings</span></code> class is used to define a simple list of times at which observations are simulated.</p>
<div class="highlight-cpp"><div class="highlight"><pre><span></span><span class="n">boost</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span> <span class="n">ObservationViabilitySettings</span> <span class="o">&gt;</span> <span class="n">observationViabilitySettings</span> <span class="o">=</span>
      <span class="n">boost</span><span class="o">::</span><span class="n">make_shared</span><span class="o">&lt;</span> <span class="n">ObservationViabilitySettings</span> <span class="o">&gt;</span><span class="p">(</span>
          <span class="n">observationViabilityType</span><span class="p">,</span> <span class="n">associatedLinkEnd</span><span class="p">,</span> <span class="n">stringParameter</span><span class="p">,</span> <span class="n">doubleParameter</span> <span class="p">);</span>
</pre></div>
</div>
<p>The input is:</p>
<ul>
<li><p class="first"><code class="docutils literal"><span class="pre">observationViabilityType</span></code></p>
<blockquote>
<div><p>A <code class="docutils literal"><span class="pre">ObservationViabilityType</span></code> variable denoting the type of constraint that is to be created</p>
</div></blockquote>
</li>
<li><p class="first"><code class="docutils literal"><span class="pre">associatedLinkEnd</span></code></p>
<blockquote>
<div><p>A <code class="docutils literal"><span class="pre">std::pair&lt;</span> <span class="pre">std::string,</span> <span class="pre">std::string</span> <span class="pre">&gt;</span></code> variable, denoting the link end for which the constraint is to be applied</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">When leaving the second entry of the <code class="docutils literal"><span class="pre">associatedLinkEnd</span></code> empty (for instance <code class="docutils literal"><span class="pre">std::make_pair(</span> <span class="pre">&quot;Earth&quot;,</span> <span class="pre">&quot;&quot;</span> <span class="pre">)</span></code>, the constraint will be applied for all ground stations on that body.</p>
</div>
</div></blockquote>
</li>
<li><p class="first"><code class="docutils literal"><span class="pre">stringParameter</span></code></p>
<blockquote>
<div><p>An <code class="docutils literal"><span class="pre">std::string</span></code> input parameter defining a property of the constraint. Its meaning is different for different constraint types:</p>
<blockquote>
<div><ul class="simple">
<li><code class="docutils literal"><span class="pre">minimum_elevation_angle</span></code>: None (stringParameter must be <code class="docutils literal"><span class="pre">&quot;&quot;</span></code>)</li>
<li><code class="docutils literal"><span class="pre">body_avoidance_angle</span></code>: Name of body to which viewing angle should be larger than value defined by <code class="docutils literal"><span class="pre">doubleParameter</span></code></li>
<li><code class="docutils literal"><span class="pre">body_occultation</span></code>: Name of body for which occultation is to be taken into account</li>
</ul>
</div></blockquote>
</div></blockquote>
</li>
<li><p class="first"><code class="docutils literal"><span class="pre">doubleParameter</span></code></p>
<blockquote>
<div><p>A <code class="docutils literal"><span class="pre">double</span></code> input parameter defining a property of the constraint. Its meaning is different for different constraint types:</p>
<blockquote>
<div><ul class="simple">
<li><code class="docutils literal"><span class="pre">minimum_elevation_angle</span></code>: Minimum value of elevation angle (in radians) at ground station</li>
<li><code class="docutils literal"><span class="pre">body_avoidance_angle</span></code>: Minimum value of body viewing angle (in radians) of body that is to be avoided.</li>
<li><code class="docutils literal"><span class="pre">body_occultation</span></code>: None (doubleParameter must be <code class="docutils literal"><span class="pre">TUDAT_NAN</span></code>)</li>
</ul>
</div></blockquote>
</div></blockquote>
</li>
</ul>
</dd></dl>

<p>As is the case for many other Tudat functionalities, the actual objects that perform the viability calculcations (of the <code class="docutils literal"><span class="pre">ObservationViabilityCalculator</span></code> class) are created from the settings objects as follows:</p>
<blockquote>
<div><div class="highlight-cpp"><div class="highlight"><pre><span></span><span class="c1">// Define environment</span>
<span class="n">NamedBodyMap</span> <span class="n">bodyMap</span> <span class="o">=</span> <span class="p">....</span> <span class="p">;</span>

<span class="c1">// Define link ends for each observable</span>
<span class="n">std</span><span class="o">::</span><span class="n">map</span><span class="o">&lt;</span> <span class="n">ObservableType</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span> <span class="n">LinkEnds</span> <span class="o">&gt;</span> <span class="o">&gt;</span> <span class="n">linkEndsList</span> <span class="o">=</span> <span class="p">....</span> <span class="p">;</span>

<span class="c1">// Define observation viability settings</span>
<span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span> <span class="n">boost</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span> <span class="n">ObservationViabilitySettings</span> <span class="o">&gt;</span> <span class="o">&gt;</span> <span class="n">observationViabilitySettings</span> <span class="o">=</span> <span class="p">....</span> <span class="p">;</span>

<span class="c1">//  Create viability calculators</span>
<span class="n">PerObservableObservationViabilityCalculatorList</span> <span class="n">viabilityCalculators</span> <span class="o">=</span> <span class="n">createObservationViabilityCalculators</span><span class="p">(</span>
          <span class="n">bodyMap</span><span class="p">,</span> <span class="n">testLinkEndsList</span><span class="p">,</span> <span class="n">observationViabilitySettings</span> <span class="p">);</span>
</pre></div>
</div>
</div></blockquote>
<p>Where <code class="docutils literal"><span class="pre">PerObservableObservationViabilityCalculatorList</span></code> is a typedef for <code class="docutils literal"><span class="pre">std::map&lt;</span> <span class="pre">ObservableType,</span> <span class="pre">std::map&lt;</span> <span class="pre">LinkEnds,</span> <span class="pre">std::vector&lt;</span> <span class="pre">boost::shared_ptr&lt;</span> <span class="pre">ObservationViabilityCalculator</span> <span class="pre">&gt;</span> <span class="pre">&gt;</span> <span class="pre">&gt;</span> <span class="pre">&gt;</span></code>, which is a list of viability calculators for each set of link ends and observable type.</p>
</div>
<div class="section" id="observation-noise">
<span id="observationnoise"></span><h2>6.3.4. Observation Noise<a class="headerlink" href="#observation-noise" title="Permalink to this headline">¶</a></h2>
<p>In addition to the observation biases (see <a class="reference internal" href="observationModelSetup.html#observationbiases"><span class="std std-ref">Observation Biases</span></a>), which are part of the observation model and typically deterministic, stochastic noise may be added to the observations when simulating them.</p>
<p>The interface for observation noise is made general, allowing both time-correlated and time-uncorrelated noise to be added: a function of type <code class="docutils literal"><span class="pre">boost::function&lt;</span> <span class="pre">double(</span> <span class="pre">const</span> <span class="pre">double</span> <span class="pre">)</span> <span class="pre">&gt;</span></code> must be created. Here, the function input is the current time, and the output the noise value. You are free to define this function in any way you like. Refer to the documentation of <code class="docutils literal"><span class="pre">boost::function</span></code> and <code class="docutils literal"><span class="pre">boost::bind</span></code> (see <a class="reference internal" href="../../basics/externalLibraries/boost.html#externalboost"><span class="std std-ref">Boost: Basic Concepts</span></a>).</p>
<p>In typical basic simulation studies, time-uncorrelated white noise is used. To easily add this type of noise, you can make use of the Tudat interface to boost probability distributions/random number generation (see <a class="reference internal" href="../mathTools/probabilityDistributions.html#tudatfeaturesprobabilitydistributions"><span class="std std-ref">Probability Distributions</span></a>). As an example, the following will generate a function which generates which noise with a mean of 0.005 and a standard deviationof 0.003.</p>
<div class="highlight-cpp"><div class="highlight"><pre><span></span><span class="c1">// Define (arbitrary) noise properties</span>
<span class="kt">double</span> <span class="n">meanValue</span> <span class="o">=</span> <span class="mf">5.0E-3</span>
<span class="kt">double</span> <span class="n">standardDeviation</span> <span class="o">=</span> <span class="mf">3.0E-3</span><span class="p">;</span>

<span class="c1">// Create noise function</span>
<span class="n">boost</span><span class="o">::</span><span class="n">function</span><span class="o">&lt;</span> <span class="kt">double</span><span class="p">(</span> <span class="p">)</span> <span class="o">&gt;</span> <span class="n">inputFreeNoiseFunction</span> <span class="o">=</span> <span class="n">createBoostContinuousRandomVariableGeneratorFunction</span><span class="p">(</span>
    <span class="n">normal_boost_distribution</span><span class="p">,</span> <span class="n">boost</span><span class="o">::</span><span class="n">assign</span><span class="o">::</span><span class="n">list_of</span><span class="p">(</span> <span class="n">meanValue</span> <span class="p">)(</span> <span class="n">standardDeviation</span> <span class="p">),</span> <span class="mf">0.0</span> <span class="p">);</span>
<span class="n">boost</span><span class="o">::</span><span class="n">function</span><span class="o">&lt;</span> <span class="kt">double</span><span class="p">(</span> <span class="k">const</span> <span class="kt">double</span> <span class="p">)</span> <span class="o">&gt;</span> <span class="n">noiseFunction</span> <span class="o">=</span>
    <span class="n">boost</span><span class="o">::</span><span class="n">bind</span><span class="p">(</span> <span class="o">&amp;</span><span class="n">utilities</span><span class="o">::</span><span class="n">evaluateFunctionWithoutInputArgumentDependency</span><span class="o">&lt;</span> <span class="kt">double</span><span class="p">,</span> <span class="k">const</span> <span class="kt">double</span> <span class="o">&gt;</span><span class="p">,</span>
       <span class="n">inputFreeNoiseFunction</span><span class="p">,</span> <span class="n">_1</span> <span class="p">);</span>
</pre></div>
</div>
<p>You may use a similar approach to use any of the boost distrbutions for noise. Note that the second step, in which the <code class="docutils literal"><span class="pre">evaluateFunctionWithoutInputArgumentDependency</span></code> is called, is needed for consistency with the observation noise interface.</p>
</div>
<div class="section" id="generating-the-observations">
<span id="generatingobservations"></span><h2>6.3.5. Generating the observations<a class="headerlink" href="#generating-the-observations" title="Permalink to this headline">¶</a></h2>
<p>Before discussing in detail how to generate simulated observations, we need to define the manner in which these observations are return. Presently, they are stored in the following complicated data type:</p>
<p><code class="docutils literal"><span class="pre">std::map&lt;</span> <span class="pre">ObservableType,</span> <span class="pre">std::map&lt;</span> <span class="pre">LinkEnds,</span> <span class="pre">std::pair&lt;</span> <span class="pre">Eigen::Matrix&lt;</span> <span class="pre">ObservationScalarType,</span> <span class="pre">Eigen::Dynamic,</span> <span class="pre">1</span> <span class="pre">&gt;,</span> <span class="pre">std::pair&lt;</span> <span class="pre">std::vector&lt;</span> <span class="pre">TimeType</span> <span class="pre">&gt;,</span> <span class="pre">LinkEndType</span> <span class="pre">&gt;</span> <span class="pre">&gt;</span> <span class="pre">&gt;</span> <span class="pre">&gt;</span></code></p>
<p>The first part of this type :literal:<a href="#id1"><span class="problematic" id="id2">`</span></a>std::map&lt; ObservableType, std::map&lt; LinkEnds, … ` denotes that a separate set of observations is generated for each requested observable type and set of link ends. For each of these, the simulated data is stored in the following data type:</p>
<p><code class="docutils literal"><span class="pre">std::pair&lt;</span> <span class="pre">Eigen::Matrix&lt;</span> <span class="pre">ObservationScalarType,</span> <span class="pre">Eigen::Dynamic,</span> <span class="pre">1</span> <span class="pre">&gt;,</span> <span class="pre">std::pair&lt;</span> <span class="pre">std::vector&lt;</span> <span class="pre">TimeType</span> <span class="pre">&gt;,</span> <span class="pre">LinkEndType</span> <span class="pre">&gt;</span> <span class="pre">&gt;</span></code></p>
<p>This pair contains:</p>
<blockquote>
<div><ul class="simple">
<li>A vector with the values of the observables, as a <code class="docutils literal"><span class="pre">Eigen::Matrix&lt;</span> <span class="pre">ObservationScalarType,</span> <span class="pre">Eigen::Dynamic,</span> <span class="pre">1</span> <span class="pre">&gt;</span></code> (equal to <code class="docutils literal"><span class="pre">Eigen::VectorXd</span></code> when <code class="docutils literal"><span class="pre">ObservationScalarType</span> <span class="pre">=</span> <span class="pre">double</span></code>).</li>
<li>Another pair, this time: <code class="docutils literal"><span class="pre">std::pair&lt;</span> <span class="pre">std::vector&lt;</span> <span class="pre">TimeType</span> <span class="pre">&gt;,</span> <span class="pre">LinkEndType</span> <span class="pre">&gt;</span></code>, which first contains the observation times, and second the reference link end type of these observations (e.g. is the time valiud at reception or transmission of the signal).</li>
</ul>
</div></blockquote>
<p>For observations of size 1, the <code class="docutils literal"><span class="pre">Eigen::Vector</span></code> of observations and <code class="docutils literal"><span class="pre">std::vector</span></code> of times are the same length. For observations with size larger than 1, however, they are not, with the vector of observations being N times the size of the vector of times (with N the size of a single observable). For instance, for an angular position observable (N=2), entry 0 of the time vector gives the observation time of entry 0 and 1 of the observation vector, entry 1 of the time vector gives the time of entry 2 and 3 of the observation vector, etc.</p>
<p>Using the above, you can create all the required input to generate observations. Note that while the <code class="xref py py-class docutils literal"><span class="pre">ObservationSimulatorBase</span></code> and <code class="xref py py-class docutils literal"><span class="pre">ObservationSimulationTimeSettings</span></code> are required for this, the noise function and viability calculators need not be provided (no noise and no observation constraints are then used). The simplest way to generate observations, without noise or viability checks, is by using the following:</p>
<div class="highlight-cpp"><div class="highlight"><pre><span></span><span class="c1">// Define times at which to simulate the observations</span>
<span class="n">std</span><span class="o">::</span><span class="n">map</span><span class="o">&lt;</span> <span class="n">ObservableType</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">map</span><span class="o">&lt;</span> <span class="n">LinkEnds</span><span class="p">,</span> <span class="n">boost</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span> <span class="n">ObservationSimulationTimeSettings</span><span class="o">&lt;</span> <span class="n">TimeType</span> <span class="o">&gt;</span> <span class="o">&gt;</span> <span class="o">&gt;</span> <span class="o">&gt;</span> <span class="n">observationTimeSettings</span> <span class="o">=</span> <span class="p">....</span> <span class="p">;</span>

<span class="c1">// Define observation simulator objects</span>
<span class="n">std</span><span class="o">::</span><span class="n">map</span><span class="o">&lt;</span> <span class="n">ObservableType</span><span class="p">,</span> <span class="n">boost</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span> <span class="n">ObservationSimulatorBase</span><span class="o">&lt;</span> <span class="n">ObservationScalarType</span><span class="p">,</span> <span class="n">TimeType</span> <span class="o">&gt;</span> <span class="o">&gt;</span> <span class="o">&gt;</span> <span class="n">observationSimulators</span> <span class="o">=</span> <span class="p">....</span> <span class="p">;</span>

<span class="c1">// Define (arbitrary) noise properties</span>
<span class="n">FullSimulatedObservationSet</span> <span class="o">=</span> <span class="n">simulateObservations</span><span class="p">(</span> <span class="n">observationsToSimulate</span><span class="p">,</span> <span class="n">observationSimulators</span> <span class="p">);</span>
</pre></div>
</div>
<p>When including checks on the viability of the observations, this must be extended to:</p>
<div class="highlight-cpp"><div class="highlight"><pre><span></span><span class="c1">// Define times at which to simulate the observations</span>
<span class="n">std</span><span class="o">::</span><span class="n">map</span><span class="o">&lt;</span> <span class="n">ObservableType</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">map</span><span class="o">&lt;</span> <span class="n">LinkEnds</span><span class="p">,</span> <span class="n">boost</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span> <span class="n">ObservationSimulationTimeSettings</span><span class="o">&lt;</span> <span class="n">TimeType</span> <span class="o">&gt;</span> <span class="o">&gt;</span> <span class="o">&gt;</span> <span class="o">&gt;</span> <span class="n">observationTimeSettings</span> <span class="o">=</span> <span class="p">....</span> <span class="p">;</span>

<span class="c1">// Define observation simulator objects</span>
<span class="n">std</span><span class="o">::</span><span class="n">map</span><span class="o">&lt;</span> <span class="n">ObservableType</span><span class="p">,</span> <span class="n">boost</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span> <span class="n">ObservationSimulatorBase</span><span class="o">&lt;</span> <span class="n">ObservationScalarType</span><span class="p">,</span> <span class="n">TimeType</span> <span class="o">&gt;</span> <span class="o">&gt;</span> <span class="o">&gt;</span> <span class="n">observationSimulators</span> <span class="o">=</span> <span class="p">....</span> <span class="p">;</span>

<span class="c1">// Define viability calculators for observations</span>
<span class="n">PerObservableObservationViabilityCalculatorList</span> <span class="n">viabilityCalculatorList</span> <span class="o">=</span> <span class="p">....</span> <span class="p">;</span>

<span class="c1">// Define (arbitrary) noise properties</span>
<span class="n">FullSimulatedObservationSet</span> <span class="o">=</span> <span class="n">simulateObservations</span><span class="p">(</span> <span class="n">observationsToSimulate</span><span class="p">,</span> <span class="n">observationSimulators</span><span class="p">,</span> <span class="n">viabilityCalculatorList</span> <span class="p">);</span>
</pre></div>
</div>
<p>Which will limit the simulated observation set to those that comply with the conditions defined by the <code class="docutils literal"><span class="pre">viabilityCalculatorList</span></code>, see THIS PAGE for more details.</p>
<p>Finally, when including noise on the simulated observations, we provide a number of interfaces of varying levels of generality. The interface that provides the greatest degree of freedom is the following:</p>
<div class="highlight-cpp"><div class="highlight"><pre><span></span><span class="c1">// Define times at which to simulate the observations</span>
<span class="n">std</span><span class="o">::</span><span class="n">map</span><span class="o">&lt;</span> <span class="n">ObservableType</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">map</span><span class="o">&lt;</span> <span class="n">LinkEnds</span><span class="p">,</span> <span class="n">boost</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span> <span class="n">ObservationSimulationTimeSettings</span><span class="o">&lt;</span> <span class="n">TimeType</span> <span class="o">&gt;</span> <span class="o">&gt;</span> <span class="o">&gt;</span> <span class="o">&gt;</span> <span class="n">observationTimeSettings</span> <span class="o">=</span> <span class="p">....</span> <span class="p">;</span>

<span class="c1">// Define observation simulator objects</span>
<span class="n">std</span><span class="o">::</span><span class="n">map</span><span class="o">&lt;</span> <span class="n">ObservableType</span><span class="p">,</span> <span class="n">boost</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span> <span class="n">ObservationSimulatorBase</span><span class="o">&lt;</span> <span class="n">ObservationScalarType</span><span class="p">,</span> <span class="n">TimeType</span> <span class="o">&gt;</span> <span class="o">&gt;</span> <span class="o">&gt;</span> <span class="n">observationSimulators</span> <span class="o">=</span> <span class="p">....</span> <span class="p">;</span>

<span class="c1">// Define viability calculators for observations</span>
<span class="n">PerObservableObservationViabilityCalculatorList</span> <span class="n">viabilityCalculatorList</span> <span class="o">=</span> <span class="p">....</span> <span class="p">;</span>

<span class="c1">// Define observation noise functions</span>
<span class="n">std</span><span class="o">::</span><span class="n">map</span><span class="o">&lt;</span> <span class="n">ObservableType</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">map</span><span class="o">&lt;</span> <span class="n">LinkEnds</span><span class="p">,</span> <span class="n">boost</span><span class="o">::</span><span class="n">function</span><span class="o">&lt;</span> <span class="n">Eigen</span><span class="o">::</span><span class="n">VectorXd</span><span class="p">(</span> <span class="k">const</span> <span class="kt">double</span> <span class="p">)</span> <span class="o">&gt;</span> <span class="o">&gt;</span> <span class="o">&gt;</span> <span class="n">noiseFunctions</span> <span class="o">=</span> <span class="p">....</span> <span class="p">;</span>

<span class="c1">// Define (arbitrary) noise properties</span>
<span class="n">FullSimulatedObservationSet</span> <span class="o">=</span> <span class="n">simulateObservationsWithNoise</span><span class="p">(</span> <span class="n">observationsToSimulate</span><span class="p">,</span> <span class="n">observationSimulators</span><span class="p">,</span> <span class="n">noiseFunctions</span><span class="p">,</span> <span class="n">viabilityCalculatorList</span> <span class="p">);</span>
</pre></div>
</div>
<p>Which requires a noise function defined as a <code class="docutils literal"><span class="pre">Eigen::VectorXd</span></code> as a function of time (<code class="docutils literal"><span class="pre">const</span> <span class="pre">double</span></code>), where we use a vector representation of the observation noise to allow noise models to be applied to multi-valued observables (e.g. angular position). However, The <code class="docutils literal"><span class="pre">noiseFunctions</span></code> may also be of one of the following:</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">std::map&lt;</span> <span class="pre">ObservableType,</span> <span class="pre">std::map&lt;</span> <span class="pre">LinkEnds,</span> <span class="pre">boost::function&lt;</span> <span class="pre">double(</span> <span class="pre">const</span> <span class="pre">double</span> <span class="pre">)</span> <span class="pre">&gt;</span> <span class="pre">&gt;</span> <span class="pre">&gt;</span></code> Here the noise is defined as a single output. If the observable is multi-valued, the same function is called to generate the noise for each of the entries of the observable. Note that the function is called separately for each entry.</li>
<li><code class="docutils literal"><span class="pre">std::map&lt;</span> <span class="pre">ObservableType,</span> <span class="pre">boost::function&lt;</span> <span class="pre">Eigen::VectorXd(</span> <span class="pre">const</span> <span class="pre">double</span> <span class="pre">)</span> <span class="pre">&gt;</span> <span class="pre">&gt;</span></code> Here, the noise is not defineed separately for each set of <code class="docutils literal"><span class="pre">LinkEnds</span></code>, only per <code class="docutils literal"><span class="pre">ObservableType</span></code>, the same function is used for each set link ends of a given type of observable.</li>
<li><code class="docutils literal"><span class="pre">std::map&lt;</span> <span class="pre">ObservableType,</span> <span class="pre">boost::function&lt;</span> <span class="pre">double(</span> <span class="pre">const</span> <span class="pre">double</span> <span class="pre">)</span> <span class="pre">&gt;</span> <span class="pre">&gt;</span></code> A combination of the previous two input types.</li>
<li><code class="docutils literal"><span class="pre">boost::function&lt;</span> <span class="pre">double(</span> <span class="pre">const</span> <span class="pre">double</span> <span class="pre">)</span> <span class="pre">&gt;</span></code> The same noise function is used for each observable, link ends, and observable entry (for multi-valued observables)</li>
</ul>
</div>
</div>


           </div>
           <div class="articleComments">
            
           </div>
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="parameterEstimationSettings.html" class="btn btn-neutral float-right" title="6.4. Setting Up Estimated Parameters" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="observationModelSetup.html" class="btn btn-neutral" title="6.2. Setting up Observation Models" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2017, Delft University of Technology.

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'../../../',
            VERSION:'',
            LANGUAGE:'None',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true,
            SOURCELINK_SUFFIX: '.txt'
        };
    </script>
      <script type="text/javascript" src="../../../_static/jquery.js"></script>
      <script type="text/javascript" src="../../../_static/underscore.js"></script>
      <script type="text/javascript" src="../../../_static/doctools.js"></script>
      <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

  

  
  
    <script type="text/javascript" src="../../../_static/js/theme.js"></script>
  

  
  
  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.StickyNav.enable();
      });
  </script>
  
 <script type="text/javascript">
    $(document).ready(function() {
        $(".toggle > *").hide();
        $(".toggle .header").show();
        $(".toggle .header .arrow").click(function() {
            $(this).closest('.toggle').children().not(".header").toggle(400);
            $(this).toggleClass("open");
            // $(this).html() == "More" ? $(this).html('Less') : $(this).html('More');
        });
        $(".showall").click(function() {
            $(".toggle > *").show(400);
            $(".toggle .header .arrow").addClass("open");
        });
        $(".hideall").click(function() {
            $(".toggle > *").hide(400);
            $(".toggle .header").show(400);
            $(".toggle .header .arrow").removeClass("open");
        });
    });
</script>


</body>
</html>