

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>5.1. Frame/State Transformations &mdash; TU Delft Astrodynamic Toolbox  documentation</title>
  

  
  
  
  

  

  
  
    

  

  
  
    <link rel="stylesheet" href="../../../_static/css/theme.css" type="text/css" />
  

  
    <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
  
    <link rel="stylesheet" href="../../../_static/css/theme.css" type="text/css" />
  
    <link rel="stylesheet" href="../../../_static/graphviz.css" type="text/css" />
  
    <link rel="stylesheet" href="../../../_static/custom.css" type="text/css" />
  

  
        <link rel="index" title="Index"
              href="../../../genindex.html"/>
        <link rel="search" title="Search" href="../../../search.html"/>
    <link rel="top" title="TU Delft Astrodynamic Toolbox  documentation" href="../../../index.html"/>
        <link rel="up" title="5. Basic Astrodynamics Tools" href="index.html"/>
        <link rel="next" title="5.2. Mission Segments" href="missionSegments.html"/>
        <link rel="prev" title="5. Basic Astrodynamics Tools" href="index.html"/> 

  
  <script src="../../../_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav" role="document">

   
  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="../../../index.html" class="icon icon-home"> TU Delft Astrodynamic Toolbox
          

          
          </a>

          
            
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption" role="heading"><span class="caption-text">Contents</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../../../index.html">Start Page</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../started/index.html">Getting Started</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../installation/index.html">Installation Guide</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="../../index.html">Tutorials and Documentation</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="../../applicationWalkthroughs/index.html">Application Tutorials</a></li>
<li class="toctree-l2 current"><a class="reference internal" href="../index.html">Tudat Libraries</a><ul class="current">
<li class="toctree-l3"><a class="reference internal" href="../environmentSetup/index.html">1. Environment Set-up</a></li>
<li class="toctree-l3"><a class="reference internal" href="../accelerationSetup/index.html">2. Setting up State Derivative Models</a></li>
<li class="toctree-l3"><a class="reference internal" href="../propagationSetup/index.html">3. Simulator Set-Up</a></li>
<li class="toctree-l3"><a class="reference internal" href="../estimationSetup/index.html">4. Estimation Set-Up</a></li>
<li class="toctree-l3 current"><a class="reference internal" href="index.html">5. Basic Astrodynamics Tools</a><ul class="current">
<li class="toctree-l4 current"><a class="current reference internal" href="#">5.1. Frame/State Transformations</a></li>
<li class="toctree-l4"><a class="reference internal" href="missionSegments.html">5.2. Mission Segments</a></li>
<li class="toctree-l4"><a class="reference internal" href="trajectoryDesign.html">5.3. Trajectory Design</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../lowThrustTrajectoryDesign/index.html">Low-Thrust Trajectory Design Module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../mathTools/index.html">6. Basic Mathematics Tools</a></li>
<li class="toctree-l3"><a class="reference internal" href="../otherLibraries/index.html">7. Other Libraries</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../basics/index.html">Tudat Basics</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../jsonInterface/index.html">JSON Interface</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../matlabInterface/index.html">MATLAB Interface</a></li>
<li class="toctree-l2"><a class="reference external" href="http://doxygen.tudat.tudelft.nl">Doxygen</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../troubleshooting/index.html">Troubleshooting</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../../FAQ/index.html">FAQ</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../developerGuide/index.html">Developer Guide</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">TU Delft Astrodynamic Toolbox</a>
        
      </nav>


      
      <div class="wy-nav-content">
        <div class="rst-content">
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../../index.html">Docs</a> &raquo;</li>
        
          <li><a href="../../index.html">Tutorials and Documentation</a> &raquo;</li>
        
          <li><a href="../index.html">Tudat Libraries</a> &raquo;</li>
        
          <li><a href="index.html"><span class="section-number">5. </span>Basic Astrodynamics Tools</a> &raquo;</li>
        
      <li><span class="section-number">5.1. </span>Frame/State Transformations</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="../../../_sources/tutorials/tudatFeatures/astroTools/framestateTransformations.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="frame-state-transformations">
<span id="tudatfeaturesframestatetransformations"></span><h1><span class="section-number">5.1. </span>Frame/State Transformations<a class="headerlink" href="#frame-state-transformations" title="Permalink to this headline">¶</a></h1>
<div class="section" id="state-type-conversions">
<h2><span class="section-number">5.1.1. </span>State Type Conversions<a class="headerlink" href="#state-type-conversions" title="Permalink to this headline">¶</a></h2>
<p>Depending on your application, you will be using any of a number of translational state (position and velocity) representations. In Tudat, conversions involving the following state representations are available:</p>
<ul class="simple">
<li><p>Cartesian elements.</p></li>
<li><p>Keplerian elements.</p></li>
<li><p>Spherical-orbital elements.</p></li>
<li><p>Modified Equinoctial elements.</p></li>
<li><p>Unified State Model elements.</p></li>
</ul>
<p>For each of these element types, conversions to/from Cartesian elements are available. Converting between two element types, where neither is Cartesian, will typically involve first transforming to Cartesian elements, and then transforming to your output state type.</p>
<p>In case you are also working with rotational motion, in Tudat the following representations for attitude are available:</p>
<ul class="simple">
<li><p>Quaternions.</p></li>
<li><p>Modified Rodrigues parameters.</p></li>
<li><p>Exponential map.</p></li>
</ul>
<p>Transformation between these elements is done by passing through quaternions first. In fact, this is the default attitude representation in Tudat.</p>
<p>For each state type, the physical meaning of each of the elements is defined in the <code class="docutils literal notranslate"><span class="pre">statevectorIndices.h</span></code> file. In this file, you will see for instance:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">//! Keplerian elements indices.</span>
<span class="k">enum</span> <span class="nc">KeplerianElementIndices</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="n">semiMajorAxisIndex</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"></span>
<span class="n">eccentricityIndex</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"></span>
<span class="n">inclinationIndex</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"></span>
<span class="n">argumentOfPeriapsisIndex</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">3</span><span class="p">,</span><span class="w"></span>
<span class="n">longitudeOfAscendingNodeIndex</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">4</span><span class="p">,</span><span class="w"></span>
<span class="n">trueAnomalyIndex</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">5</span><span class="p">,</span><span class="w"></span>
<span class="n">semiLatusRectumIndex</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="w"></span>
<span class="p">};</span><span class="w"></span>
</pre></div>
</div>
<p>This indicates that, for instance the eccentricity is index 1 and the true anomaly is index 5. As a result, you can use the following to retrieve the eccentricity from a vector if Kepler elements:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">//! Keplerian elements indices.</span>
<span class="n">Eigen</span><span class="o">::</span><span class="n">Vector6d</span><span class="w"> </span><span class="n">keplerElements</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">....</span><span class="w"></span>
<span class="kt">double</span><span class="w"> </span><span class="n">currentEccentricity</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">keplerElements</span><span class="p">(</span><span class="w"> </span><span class="n">orbital_element_conversions</span><span class="o">::</span><span class="n">eccentricityIndex</span><span class="w"> </span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<p>or alternatively:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">//! Keplerian elements indices.</span>
<span class="n">Eigen</span><span class="o">::</span><span class="n">Vector6d</span><span class="w"> </span><span class="n">keplerElements</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">....</span><span class="w"></span>
<span class="kt">double</span><span class="w"> </span><span class="n">currentEccentricity</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">keplerElements</span><span class="p">(</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<p>which yields the exact same result.</p>
<p>In the definition of the <code class="docutils literal notranslate"><span class="pre">KeplerianElementIndices</span></code> enumeration, you can see something peculiar: both <code class="docutils literal notranslate"><span class="pre">semiMajorAxisIndex</span></code> and <code class="docutils literal notranslate"><span class="pre">semiLatusRectumIndex</span></code> are defined as index 0. The latter option is only applicable when the orbit is parabolic (when the eccentricity is 1.0). That is, if the orbit is parabolic, element 0 does not represent the semi-major axis (as it is not defined) but the semi-latus rectum. Below, we list the details of the implementation of each of these state types in Tudat:</p>
<div class="section" id="kepler-elements">
<h3><span class="section-number">5.1.1.1. </span>Kepler Elements<a class="headerlink" href="#kepler-elements" title="Permalink to this headline">¶</a></h3>
<p>The Kepler elements are the standard orbital elements used in classical celestial mechanics, with the element indices shown above.
Converting to/from Cartesian state requires an additional piece of information in addition to the state itself: the gravitational parameter of the body w.r.t. the Keplerian elements are defined. Conversion to/from Cartesian elements is done as</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">Eigen</span><span class="o">::</span><span class="n">Vector6d</span><span class="w"> </span><span class="n">cartesianState</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">....</span><span class="w"></span>
<span class="kt">double</span><span class="w"> </span><span class="n">centralBodyGravitationalParameter</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">...</span><span class="w"></span>
<span class="n">Eigen</span><span class="o">::</span><span class="n">Vector6d</span><span class="w"> </span><span class="n">keplerianState</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">convertCartesianToKeplerianElements</span><span class="p">(</span><span class="w"> </span><span class="n">cartesianState</span><span class="p">,</span><span class="w"> </span><span class="n">centralBodyGravitationalParameter</span><span class="w"> </span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<p>Similarly, the inverse operation is done as:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">Eigen</span><span class="o">::</span><span class="n">Vector6d</span><span class="w"> </span><span class="n">keplerianState</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">....</span><span class="w"></span>
<span class="kt">double</span><span class="w"> </span><span class="n">centralBodyGravitationalParameter</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">...</span><span class="w"></span>
<span class="n">Eigen</span><span class="o">::</span><span class="n">Vector6d</span><span class="w"> </span><span class="n">cartesianState</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">convertKeplerianToCartesianElements</span><span class="p">(</span><span class="w"> </span><span class="n">keplerianState</span><span class="p">,</span><span class="w"> </span><span class="n">centralBodyGravitationalParameter</span><span class="w"> </span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<p>In the definition of the state elements, you will notice that element 5 is the true anomaly, not the eccentric or mean anomaly. Tudat also contains functions to convert to these alternative anomalies. Converting between true and eccentric anomaly is done as follows:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="kt">double</span><span class="w"> </span><span class="n">trueAnomaly</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">....</span><span class="w"></span>
<span class="kt">double</span><span class="w"> </span><span class="n">eccentricity</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">...</span><span class="w"></span>
<span class="kt">double</span><span class="w"> </span><span class="n">eccentricAnomaly</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">convertTrueAnomalyToEccentricAnomaly</span><span class="p">(</span><span class="w"> </span><span class="n">trueAnomaly</span><span class="p">,</span><span class="w"> </span><span class="n">eccentricity</span><span class="w"> </span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<p>or directly from the orbital elements:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">Eigen</span><span class="o">::</span><span class="n">Vector6d</span><span class="w"> </span><span class="n">keplerianState</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">...</span><span class="w"></span>
<span class="kt">double</span><span class="w"> </span><span class="n">eccentricAnomaly</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">convertTrueAnomalyToEccentricAnomaly</span><span class="p">(</span><span class="w"> </span><span class="n">keplerianState</span><span class="p">(</span><span class="w"> </span><span class="n">trueAnomalyIndex</span><span class="w"> </span><span class="p">),</span><span class="w"> </span><span class="n">keplerianState</span><span class="p">(</span><span class="w"> </span><span class="n">eccentricityIndex</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<p>Note that this function automatically identifies whether the orbit is elliptical or hyperbolic, and computes the associated eccentric anomaly. The function for the inverse operation is <code class="docutils literal notranslate"><span class="pre">convertEccentricAnomalyToTrueAnomaly</span></code>. Similarly, Tudat contains functions to convert from eccentric to mean anomaly (automatically checking whether the orbit is elliptical or hyperbolic):</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="kt">double</span><span class="w"> </span><span class="n">trueAnomaly</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">....</span><span class="w"></span>
<span class="kt">double</span><span class="w"> </span><span class="n">eccentricity</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">...</span><span class="w"></span>
<span class="kt">double</span><span class="w"> </span><span class="n">eccentricAnomaly</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">convertTrueAnomalyToEccentricAnomaly</span><span class="p">(</span><span class="w"> </span><span class="n">trueAnomaly</span><span class="p">,</span><span class="w"> </span><span class="n">eccentricity</span><span class="w"> </span><span class="p">);</span><span class="w"></span>
<span class="kt">double</span><span class="w"> </span><span class="n">meanAnomaly</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">convertEccentricAnomalyToMeanAnomaly</span><span class="p">(</span><span class="w"> </span><span class="n">eccentricAnomaly</span><span class="p">,</span><span class="w"> </span><span class="n">eccentricity</span><span class="w"> </span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<p>The inverse operation, mean to eccentric anomaly, is done separately for hyperbolic and elliptical orbits, through the functions <code class="docutils literal notranslate"><span class="pre">convertMeanAnomalyToEccentricAnomaly</span></code> for elliptical and <code class="docutils literal notranslate"><span class="pre">convertMeanAnomalyToHyperbolicEccentricAnomaly</span></code> for hyperbolic orbits. In general, you will use them as follows:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="kt">double</span><span class="w"> </span><span class="n">meanAnomaly</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">....</span><span class="w"></span>
<span class="kt">double</span><span class="w"> </span><span class="n">eccentricity</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">...</span><span class="w"></span>
<span class="kt">double</span><span class="w"> </span><span class="n">eccentricAnomaly</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">convertMeanAnomalyToEccentricAnomaly</span><span class="p">(</span><span class="w"> </span><span class="n">eccentricity</span><span class="p">,</span><span class="w"> </span><span class="n">meanAnomaly</span><span class="w"> </span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<p>However, this conversion involves the solution of an implicit algebraic equation, for which a root finder is used. Root finders are discussed in more detail here. When calling the function as in the above example, a <code class="xref py py-class docutils literal notranslate"><span class="pre">RootFinder</span></code> is created internally. However, in some cases you may want to specify your own root finder, as well as a first initial guess for the eccentric anomaly (which the root finder uses at its first iteration). When doing so, you create a pointer to a root finder object and pass it to the conversion function as follows:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="kt">double</span><span class="w"> </span><span class="n">meanAnomaly</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">....</span><span class="w"></span>
<span class="kt">double</span><span class="w"> </span><span class="n">eccentricity</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">...</span><span class="w"></span>
<span class="kt">double</span><span class="w"> </span><span class="n">initialGuess</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">...</span><span class="w"></span>
<span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="w"> </span><span class="n">RootFinder</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">rootFinder</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">...</span><span class="w"></span>
<span class="kt">double</span><span class="w"> </span><span class="n">eccentricAnomaly</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">convertMeanAnomalyToEccentricAnomaly</span><span class="p">(</span><span class="w"> </span><span class="n">eccentricity</span><span class="p">,</span><span class="w"> </span><span class="n">meanAnomaly</span><span class="p">,</span><span class="w"> </span><span class="nb">false</span><span class="p">,</span><span class="w"> </span><span class="n">initialGuess</span><span class="p">,</span><span class="w"> </span><span class="n">rootFinder</span><span class="w"> </span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<p>where the argument <code class="docutils literal notranslate"><span class="pre">false</span></code> indicates that the user-specified initial guess is to be used. If you want to use a custom-defined root finder, but not an initial guess, use the following:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="kt">double</span><span class="w"> </span><span class="n">meanAnomaly</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">....</span><span class="w"></span>
<span class="kt">double</span><span class="w"> </span><span class="n">eccentricity</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">...</span><span class="w"></span>
<span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="w"> </span><span class="n">RootFinder</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">rootFinder</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">...</span><span class="w"></span>
<span class="kt">double</span><span class="w"> </span><span class="n">eccentricAnomaly</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">convertMeanAnomalyToEccentricAnomaly</span><span class="p">(</span><span class="w"> </span><span class="n">eccentricity</span><span class="p">,</span><span class="w"> </span><span class="n">meanAnomaly</span><span class="p">,</span><span class="w"> </span><span class="nb">true</span><span class="p">,</span><span class="w"> </span><span class="n">TUDAT_NAN</span><span class="p">,</span><span class="w"> </span><span class="n">rootFinder</span><span class="w"> </span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
</div>
<div class="section" id="spherical-orbital-elements">
<h3><span class="section-number">5.1.1.2. </span>Spherical-orbital Elements<a class="headerlink" href="#spherical-orbital-elements" title="Permalink to this headline">¶</a></h3>
<p>The spherical elements are typically used to denote the conditions in atmospheric flight. In most applications, they will be used to denote the state in a body-fixed frame. The details of the physical meaning of the elements is discussed here. The element indices in Tudat are the following:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">//! Spherical orbital state element indices</span>
<span class="k">enum</span> <span class="nc">SphericalOrbitalStateElementIndices</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">radiusIndex</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="n">latitudeIndex</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="n">longitudeIndex</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="n">speedIndex</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">3</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="n">flightPathIndex</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">4</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="n">headingAngleIndex</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">5</span><span class="w"></span>
<span class="p">};</span><span class="w"></span>
</pre></div>
</div>
<p>The spherical elements consist of 6 entries, with no additional information required for the conversion to/from Cartesian elements. The conversion from Cartesian to spherical elements is performed as:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">Eigen</span><span class="o">::</span><span class="n">Vector6d</span><span class="w"> </span><span class="n">cartesianState</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">....</span><span class="w"></span>
<span class="n">Eigen</span><span class="o">::</span><span class="n">Vector6d</span><span class="w"> </span><span class="n">sphericalState</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">convertCartesianToSphericalOrbitalState</span><span class="p">(</span><span class="w"> </span><span class="n">cartesianState</span><span class="w"> </span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<p>Similarly, the inverse operation is done as:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">Eigen</span><span class="o">::</span><span class="n">Vector6d</span><span class="w"> </span><span class="n">sphericalState</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">....</span><span class="w"></span>
<span class="n">Eigen</span><span class="o">::</span><span class="n">Vector6d</span><span class="w"> </span><span class="n">cartesianState</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">convertSphericalOrbitalToCartesianState</span><span class="p">(</span><span class="w"> </span><span class="n">sphericalState</span><span class="w"> </span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
</div>
<div class="section" id="modified-equinoctial-elements">
<h3><span class="section-number">5.1.1.3. </span>Modified Equinoctial Elements<a class="headerlink" href="#modified-equinoctial-elements" title="Permalink to this headline">¶</a></h3>
<p>The modified equinoctial elements are typically used for orbits with eccentricities near 0 or 1 and/or inclinations near 0 or <span class="math notranslate nohighlight">\(\pi\)</span>. The element indices in Tudat are the following:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">//! Modified equinoctial element vector indices.</span>
<span class="k">enum</span> <span class="nc">ModifiedEquinoctialElementVectorIndices</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">semiParameterIndex</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="n">fElementIndex</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="n">gElementIndex</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="n">hElementIndex</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">3</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="n">kElementIndex</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">4</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="n">trueLongitudeIndex</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">5</span><span class="w"></span>
<span class="p">};</span><span class="w"></span>
</pre></div>
</div>
<p>The modified equinoctial elements consists of 6 elements. The conversion to/from Cartesian elements requires the gravitation parameter of the body w.r.t. which the Modified Equinoctial elements are defined. Furthermore, a <code class="docutils literal notranslate"><span class="pre">bool</span></code> is used to indicate whether the singularity of this element set occurs for inclinations of 0 or <span class="math notranslate nohighlight">\(\pi\)</span>. The conversion from Cartesian elements is done as:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">Eigen</span><span class="o">::</span><span class="n">Vector6d</span><span class="w"> </span><span class="n">cartesianState</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">....</span><span class="w"></span>
<span class="kt">double</span><span class="w"> </span><span class="n">centralBodyGravitationalParameter</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">...</span><span class="w"></span>
<span class="n">Eigen</span><span class="o">::</span><span class="n">Vector6d</span><span class="w"> </span><span class="n">cartesianState</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">convertCartesianToModifiedEquinoctial</span><span class="p">(</span><span class="w"> </span><span class="n">cartesianState</span><span class="p">,</span><span class="w"> </span><span class="n">centralBodyGravitationalParameter</span><span class="p">,</span><span class="w"> </span><span class="n">flipSingularityToZeroInclination</span><span class="w"> </span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The input <code class="docutils literal notranslate"><span class="pre">flipSingularityToZeroInlination</span></code> is optional for this conversion. If left empty, an overloaded function will determine whether this value is true or false based on the inclination of the orbit.</p>
</div>
<p>Similarly, the inverse operation is done as:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">Eigen</span><span class="o">::</span><span class="n">Vector6d</span><span class="w"> </span><span class="n">modifiedEquinoctialElements</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">....</span><span class="w"></span>
<span class="kt">double</span><span class="w"> </span><span class="n">centralBodyGravitationalParameter</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">...</span><span class="w"></span>
<span class="n">Eigen</span><span class="o">::</span><span class="n">Vector6d</span><span class="w"> </span><span class="n">cartesianState</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">convertModifiedEquinoctialToCartesian</span><span class="p">(</span><span class="w"> </span><span class="n">modifiedEquinoctialElements</span><span class="p">,</span><span class="w"> </span><span class="n">centralBodyGravitationalParameter</span><span class="p">,</span><span class="w"> </span><span class="n">flipSingularityToZeroInclination</span><span class="w"> </span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
</div>
<div class="section" id="unified-state-model-elements">
<h3><span class="section-number">5.1.1.4. </span>Unified State Model Elements<a class="headerlink" href="#unified-state-model-elements" title="Permalink to this headline">¶</a></h3>
<p>Three different versions of the Unified State Model are present in Tudat. They differ based on the coordinates chosen to represent the rotation from local orbital to inertial frame, which can be expressed in quaternions, modified Rodrigues parameters or exponantial map. The element indices for the Unified State Model elements with quaternions (or USM7) are the following:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">//! Unified state model with quaternions indices.</span>
<span class="k">enum</span> <span class="nc">UnifiedStateModelQuaternionsElementIndices</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">CHodographUSM7Index</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="n">Rf1HodographUSM7Index</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="n">Rf2HodographUSM7Index</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="n">etaUSM7Index</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">3</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="n">epsilon1USM7Index</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">4</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="n">epsilon2USM7Index</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">5</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="n">epsilon3USM7Index</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">6</span><span class="w"></span>
<span class="p">};</span><span class="w"></span>
</pre></div>
</div>
<p>For the Unified State Model elements with modified Rodrigues parameters (or USM6) the indeces are:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">//! Unified state model with modified Rodrigues parameters indices.</span>
<span class="k">enum</span> <span class="nc">UnifiedStateModelModifiedRodriguesParametersElementIndices</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">CHodographUSM6Index</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="n">Rf1HodographUSM6Index</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="n">Rf2HodographUSM6Index</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="n">sigma1USM6Index</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">3</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="n">sigma2USM6Index</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">4</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="n">sigma3USM6Index</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">5</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="n">shadowFlagUSM6Index</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">6</span><span class="w"></span>
<span class="p">};</span><span class="w"></span>
</pre></div>
</div>
<p>And finally, for the Unified State Model elements with exponential map (or USMEM) they are:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">//! Unified state model with exponential map indices.</span>
<span class="k">enum</span> <span class="nc">UnifiedStateModelExponentialMapElementIndices</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">CHodographUSMEMIndex</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="n">Rf1HodographUSMEMIndex</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="n">Rf2HodographUSMEMIndex</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="n">e1USMEMIndex</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">3</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="n">e2USMEMIndex</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">4</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="n">e3USMEMIndex</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">5</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="n">shadowFlagUSMEMIndex</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">6</span><span class="w"></span>
<span class="p">};</span><span class="w"></span>
</pre></div>
</div>
<p>Regardless of the rotational coordinates chosen, the Unified State Model elements consists of 7 elements. For each Unified State Model representation, conversion to and from Keplerian and Cartesian coordinates is implemented. As an example, the conversion from Keplerian elements for the USM7 elements is shown here:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">Eigen</span><span class="o">::</span><span class="n">Vector6d</span><span class="w"> </span><span class="n">keplerianElements</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">....</span><span class="w"></span>
<span class="kt">double</span><span class="w"> </span><span class="n">centralBodyGravitationalParameter</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">...</span><span class="w"></span>
<span class="n">Eigen</span><span class="o">::</span><span class="n">Vector6d</span><span class="w"> </span><span class="n">cartesianState</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">convertKeplerianToUnifiedStateModelElements</span><span class="p">(</span><span class="w"> </span><span class="n">keplerianElements</span><span class="p">,</span><span class="w"> </span><span class="n">centralBodyGravitationalParameter</span><span class="w"> </span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<p>Similarly, the inverse operation is done as:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">Eigen</span><span class="o">::</span><span class="n">Vector6d</span><span class="w"> </span><span class="n">unifiedStateModelElements</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">....</span><span class="w"></span>
<span class="kt">double</span><span class="w"> </span><span class="n">centralBodyGravitationalParameter</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">...</span><span class="w"></span>
<span class="n">Eigen</span><span class="o">::</span><span class="n">Vector6d</span><span class="w"> </span><span class="n">cartesianState</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">convertUnifiedStateElementsToKeplerian</span><span class="p">(</span><span class="w"> </span><span class="n">unifiedStateModelElements</span><span class="p">,</span><span class="w"> </span><span class="n">centralBodyGravitationalParameter</span><span class="w"> </span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
</div>
<div class="section" id="quaternions">
<h3><span class="section-number">5.1.1.5. </span>Quaternions<a class="headerlink" href="#quaternions" title="Permalink to this headline">¶</a></h3>
<p>As mentioned at the beginning of this chapter, quaternions are the default attitude representation in Tudat. Depending on the location in the Tudat framework, you will find a quaternion element expressed as either of the two types below:</p>
<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">As</span> <span class="pre">an</span> <span class="pre">Eigen::Quaterniond</span></span></dt>
<dd><p>This method is used mainly in the <a class="reference internal" href="../environmentSetup/setup.html#Body" title="Body"><code class="xref py py-class docutils literal notranslate"><span class="pre">Body</span></code></a> class, to express various rotations, such as the rotation to base frame. The advantage of this class, is that it comes with some very useful member functions. For instance, if you have a <code class="docutils literal notranslate"><span class="pre">Quaterniond</span></code> object, you can directly transform it to a direction cosine matrix (or transformation matrix) by using the method <code class="docutils literal notranslate"><span class="pre">.toRotationMatrix(</span> <span class="pre">)</span></code>. You can find more details on the definition and use of the <code class="docutils literal notranslate"><span class="pre">Quaterniond</span></code> in the Eigen website.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>The definition of rotations in Eigen is slightly different than in Tudat. This means that when using Eigen functions such as <code class="docutils literal notranslate"><span class="pre">.toRotationMatrix(</span> <span class="pre">)</span></code> to quaternions defined within Tudat, the result will be the inverse of what is desired. Thus, the tranformation to matrix should always be followed by <code class="docutils literal notranslate"><span class="pre">.transpose(</span> <span class="pre">)</span></code>, to give the correct rotation matrix.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">As</span> <span class="pre">an</span> <span class="pre">Eigen::Vector4d</span></span></dt>
<dd><p>This method is mainly used, on the other hand, in propagation. By defining the quaternion as a simple four-dimensional vector, its element can be easily extracted and replaced from the rotational state vector (which also includes rotational velocity).</p>
</dd></dl>

<p>Transformation between the two methods is defined in the linear algebra module of Tudat (see <code class="docutils literal notranslate"><span class="pre">linearAlgebra.h</span></code>). To transform a quaternion to vector format, one can use:</p>
<blockquote>
<div><div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">Eigen</span><span class="o">::</span><span class="n">Quaterniond</span><span class="w"> </span><span class="n">quaternionAsQuaternion</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">...</span><span class="w"></span>
<span class="n">Eigen</span><span class="o">::</span><span class="n">Vector4d</span><span class="w"> </span><span class="n">quaternionAsVector</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">linear_algebra</span><span class="o">::</span><span class="n">convertQuaternionToVectorFormat</span><span class="p">(</span><span class="w"> </span><span class="n">quaternionAsQuaternion</span><span class="w"> </span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
</div></blockquote>
<p>and vice-versa as:</p>
<blockquote>
<div><div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">Eigen</span><span class="o">::</span><span class="n">Vector4d</span><span class="w"> </span><span class="n">quaternionAsVector</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">...</span><span class="w"></span>
<span class="n">Eigen</span><span class="o">::</span><span class="n">Quaterniond</span><span class="w"> </span><span class="n">quaternionAsQuaternion</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">linear_algebra</span><span class="o">::</span><span class="n">convertVectorToQuaternionFormat</span><span class="p">(</span><span class="w"> </span><span class="n">quaternionAsVector</span><span class="w"> </span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
</div></blockquote>
<p>Finally, the quaternion indices are defined as follows:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">//! Quaternions indices.</span>
<span class="k">enum</span> <span class="nc">QuaternionsElementIndices</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">etaQuaternionIndex</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="n">epsilon1QuaternionIndex</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="n">epsilon2QuaternionIndex</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="n">epsilon3QuaternionIndex</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">3</span><span class="w"></span>
<span class="p">};</span><span class="w"></span>
</pre></div>
</div>
<p>Before continuing to the next rotational coordinates, there is one last fact about quaternions that needs to be discussed. This relates to the property that the sum of the square of the quaternion vector equals one, i.e., <span class="math notranslate nohighlight">\(\sum_{i=0}^3 q_i^2 = 1\)</span>. In fact, during numerical propagation it is possible that this property is violated, due to various sources of differs from one by more than about <span class="math notranslate nohighlight">\(5 \times 10^{-15}\)</span>. Note that this also applies to the quaternion vector present in the Unified State Model with quaternions, or USM7, state.</p>
</div>
<div class="section" id="modified-rodrigues-parameters">
<h3><span class="section-number">5.1.1.6. </span>Modified Rodrigues Parameters<a class="headerlink" href="#modified-rodrigues-parameters" title="Permalink to this headline">¶</a></h3>
<p>One of the other two supported attitude representations is the modified Rodrigues parameters (MRPs). The indeces for MRPs are defined as follows:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">//! Modified Rodrigues parameters indices.</span>
<span class="k">enum</span> <span class="nc">ModifiedRodriguesParametersElementIndices</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">sigma1ModifiedRodriguesParametersIndex</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="n">sigma2ModifiedRodriguesParametersIndex</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="n">sigma3ModifiedRodriguesParametersIndex</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="n">shadowFlagModifiedRodriguesParametersIndex</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">3</span><span class="w"></span>
<span class="p">};</span><span class="w"></span>
</pre></div>
</div>
<p>Transformation to and from quaternions is achieved with the functions <code class="docutils literal notranslate"><span class="pre">convertModifiedRodriguesParametersToQuaternionElements</span></code> and <code class="docutils literal notranslate"><span class="pre">convertQuaternionsToModifiedRodriguesParameterElements</span></code>, respectively, where the only input is the attitude element (in vector format).</p>
<p>The last element shown in the <code class="docutils literal notranslate"><span class="pre">ModifiedRodriguesParametersElementIndices</span></code> enumeration is the flag that triggers the shadow modifed Rodrigues parameters (SMRPs). Its use is introduced to avoid the singularity at <span class="math notranslate nohighlight">\(\pm 2\pi\)</span> radians. If its value is 0, then the elements are MRPs, whereas if it is 1, then they are SMRPs. The use of SMRPs results in slightly different equations of motion and transformations. The switch between MRPs and SMRPs occurs whenever the magnitude of the rotation represented by the MRP vector is larger than <span class="math notranslate nohighlight">\(\pi\)</span>.</p>
</div>
<div class="section" id="exponential-map">
<h3><span class="section-number">5.1.1.7. </span>Exponential Map<a class="headerlink" href="#exponential-map" title="Permalink to this headline">¶</a></h3>
<p>The final attitude representations is the exponential map (EM). The indeces for EM are defined as follows:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">//! Exponential map indices.</span>
<span class="k">enum</span> <span class="nc">ExponentialMapElementIndices</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">e1ExponentialMapIndex</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="n">e2ExponentialMapIndex</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="n">e3ExponentialMapIndex</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="n">shadowFlagExponentialMapIndex</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">3</span><span class="w"></span>
<span class="p">};</span><span class="w"></span>
</pre></div>
</div>
<p>and transformation to and from quaternions is achieved with the aid of the functions <code class="docutils literal notranslate"><span class="pre">convertExponentialMapToQuaternionElements</span></code> and <code class="docutils literal notranslate"><span class="pre">convertQuaternionsToExponentialMapElements</span></code>, respectively. Also for these equations the only input is the attitude element (in vector format).</p>
<p>Similarly to MRPs, the exponential map elements also make use of the shadow flag. In this case, this flag signals whether the shadow exponential map (SEM) is in use. This flag is also introduces to avoid the singularity at <span class="math notranslate nohighlight">\(\pm 2\pi\)</span> radians, but interestingly, there is no difference between the equations of motion and transformations in terms of EM or SEM. In fact, they are only introduced to make sure that when converting from EM to quaternions, the resulting quaternion sign history is continuous. The switch between EM and SEM occurs whenever the magnitude of the rotation represented by the EM vector is larger than <span class="math notranslate nohighlight">\(\pi\)</span>.</p>
</div>
</div>
<div class="section" id="frame-transformations">
<h2><span class="section-number">5.1.2. </span>Frame Transformations<a class="headerlink" href="#frame-transformations" title="Permalink to this headline">¶</a></h2>
<p>Every state, regardless of its representation is expressed with a particular origin and orientation. This is most easy to understand for Cartesian elements, where the origin represents the (0,0,0) position, and the orientation defines the direction of the x-, y- and z-axes. Below, we discuss how to perform these operations in Tudat.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>Do not use the <code class="docutils literal notranslate"><span class="pre">getCurrentState</span></code> or <code class="docutils literal notranslate"><span class="pre">getCurrentRotation</span></code> functions in the body objects! These functions are used during numerical propagation, and calling them outside of the numerical propagation will generally not lead to meaningful results.</p>
</div>
<div class="section" id="frame-translations">
<h3><span class="section-number">5.1.2.1. </span>Frame Translations<a class="headerlink" href="#frame-translations" title="Permalink to this headline">¶</a></h3>
<p>To change the origin of a Cartesian, one can simply add a Cartesian state that represents the difference between the original and the new origin. For instance, when transforming a vector (state of a vehicle) from Earth-centered to Moon-centered (keeping the orientation constant):</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">Eigen</span><span class="o">::</span><span class="n">Vector6d</span><span class="w"> </span><span class="n">vehicleCartesianStateInEarthCenteredFrame</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">....</span><span class="w"></span>
<span class="n">Eigen</span><span class="o">::</span><span class="n">Vector6d</span><span class="w"> </span><span class="n">moonCartesianStateInEarthCenteredFrame</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">....</span><span class="w"></span>
<span class="n">Eigen</span><span class="o">::</span><span class="n">Vector6d</span><span class="w"> </span><span class="n">vehicleCartesianStateInMoonCenteredFrame</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">vehicleCartesianStateInEarthCenteredFrame</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">moonCartesianStateInEarthCenteredFrame</span><span class="p">;</span><span class="w"></span>
</pre></div>
</div>
<p>The challenge here, of course, is determining the <code class="docutils literal notranslate"><span class="pre">moonCartesianStateInEarthCenteredFrame</span></code> vector. We provide a few ways in which to achieve this. When performing a numerical simulation using a set of body objects, you can use the following (asuming the the <code class="docutils literal notranslate"><span class="pre">bodyMap</span></code> contains both an Earth and Moon entry):</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">NamedBodyMap</span><span class="w"> </span><span class="n">bodyMap</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">...</span><span class="w"></span>
<span class="kt">double</span><span class="w"> </span><span class="n">currentTime</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">...</span><span class="w"></span>
<span class="n">Eigen</span><span class="o">::</span><span class="n">Vector6d</span><span class="w"> </span><span class="n">moonCartesianStateInEarthCenteredFrame</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">bodyMap</span><span class="p">.</span><span class="n">at</span><span class="p">(</span><span class="w"> </span><span class="s">&quot;Moon&quot;</span><span class="w"> </span><span class="p">)</span><span class="o">-&gt;</span><span class="n">getStateInBaseFrameFromEphemeris</span><span class="p">(</span><span class="w"> </span><span class="n">currentTime</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="o">-</span><span class="w"></span>
<span class="w">      </span><span class="n">bodyMap</span><span class="p">.</span><span class="n">at</span><span class="p">(</span><span class="w"> </span><span class="s">&quot;Earth&quot;</span><span class="w"> </span><span class="p">)</span><span class="o">-&gt;</span><span class="n">getStateInBaseFrameFromEphemeris</span><span class="p">(</span><span class="w"> </span><span class="n">currentTime</span><span class="w"> </span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<p>You can also bypass the body map altogether, and use Spice to obtain the relative state. Note, however, that this will use whichever <code class="docutils literal notranslate"><span class="pre">spice</span></code> kernels you have loaded, and may not be consistent with the states you are using the bodies in your simulation.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="kt">double</span><span class="w"> </span><span class="n">currentTime</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">...</span><span class="w"></span>
<span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="n">frameOrientation</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;J2000&quot;</span><span class="p">;</span><span class="w"></span>
<span class="n">Eigen</span><span class="o">::</span><span class="n">Vector6d</span><span class="w"> </span><span class="n">moonCartesianStateInEarthCenteredFrame</span><span class="w"> </span><span class="o">=</span><span class="w"></span>
<span class="w">    </span><span class="n">spice_interface</span><span class="o">::</span><span class="n">getBodyCartesianStateAtEpoch</span><span class="p">(</span><span class="w"> </span><span class="s">&quot;Moon&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;Earth&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">frameOrientation</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;NONE&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">currentTime</span><span class="w"></span>
</pre></div>
</div>
<p>where the <code class="docutils literal notranslate"><span class="pre">NONE</span></code> arguments indicates that no light-time corrections are used, and the frame orientation denotes the orientation of the frame in which the relative state is returned.</p>
</div>
<div class="section" id="frame-rotations">
<h3><span class="section-number">5.1.2.2. </span>Frame Rotations<a class="headerlink" href="#frame-rotations" title="Permalink to this headline">¶</a></h3>
<p>Rotating the frame in which a Cartesian state is expressed requires two pieces of information:</p>
<blockquote>
<div><ol class="arabic simple">
<li><p>The rotation matrix from one frame to the other</p></li>
<li><p>The first time derivative of the rotation matrix from one frame to the other</p></li>
</ol>
</div></blockquote>
<p>Manually, the state may then be transformed as:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">Eigen</span><span class="o">::</span><span class="n">Matrix3d</span><span class="w"> </span><span class="n">rotationToFrame</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">...</span><span class="w"></span>
<span class="n">Eigen</span><span class="o">::</span><span class="n">Matrix3d</span><span class="w"> </span><span class="n">timeDerivativeOfRotationToFrame</span><span class="w">  </span><span class="o">=</span><span class="w"> </span><span class="p">...</span><span class="w"></span>
<span class="n">Eigen</span><span class="o">::</span><span class="n">Vector6d</span><span class="w"> </span><span class="n">originalState</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">...</span><span class="w"></span>
<span class="n">Eigen</span><span class="o">::</span><span class="n">Vector6d</span><span class="w"> </span><span class="n">rotatedState</span><span class="p">;</span><span class="w"></span>
<span class="n">rotatedState</span><span class="p">.</span><span class="n">segment</span><span class="p">(</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">rotationToFrame</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">originalState</span><span class="p">(</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="p">);</span><span class="w"></span>
<span class="n">rotatedState</span><span class="p">.</span><span class="n">segment</span><span class="p">(</span><span class="w"> </span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">rotationToFrame</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">originalState</span><span class="p">(</span><span class="w"> </span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">timeDerivativeOfRotationToFrame</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">originalState</span><span class="p">(</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<p>In many cases, however, your frame rotation will be from the inertial frame to a body-fixed frame. All information required for this is stored in <code class="docutils literal notranslate"><span class="pre">RotationalEphemeris</span></code> objects. This object contains a base (inertial) and target (body-fixed) frame and defines the rotation between the two. Assuming that you are using a body map to store your environment, you can transform the state from an inertial to a body-fixed frame as follows, for the example of transforming a vehicle’s Cartesian state from an inertial to the body-fixed frame of the Earth:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">NamedBodyMap</span><span class="w"> </span><span class="n">bodyMap</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">...</span><span class="w"></span>
<span class="kt">double</span><span class="w"> </span><span class="n">currentTime</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">...</span><span class="w"></span>
<span class="n">Eigen</span><span class="o">::</span><span class="n">Vector6d</span><span class="w"> </span><span class="n">inertialState</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">...</span><span class="w"></span>
<span class="n">Eigen</span><span class="o">::</span><span class="n">Vector6d</span><span class="w"> </span><span class="n">bodyFixedState</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">transformStateToTargetFrame</span><span class="p">(</span><span class="w"> </span><span class="n">inertialState</span><span class="p">,</span><span class="w"> </span><span class="n">currentTime</span><span class="p">,</span><span class="w"> </span><span class="n">bodyMap</span><span class="p">.</span><span class="n">at</span><span class="p">(</span><span class="w"> </span><span class="s">&quot;Earth&quot;</span><span class="w"> </span><span class="p">)</span><span class="o">-&gt;</span><span class="n">getRotationalEphemeris</span><span class="p">(</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<p>the inverse rotation is done as follows:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">NamedBodyMap</span><span class="w"> </span><span class="n">bodyMap</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">...</span><span class="w"></span>
<span class="kt">double</span><span class="w"> </span><span class="n">currentTime</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">...</span><span class="w"></span>
<span class="n">Eigen</span><span class="o">::</span><span class="n">Vector6d</span><span class="w"> </span><span class="n">bodyFixedState</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">...</span><span class="w"></span>
<span class="n">Eigen</span><span class="o">::</span><span class="n">Vector6d</span><span class="w"> </span><span class="n">inertialState</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">transformStateToGlobalFrame</span><span class="p">(</span><span class="w"> </span><span class="n">bodyFixedState</span><span class="p">,</span><span class="w"> </span><span class="n">currentTime</span><span class="p">,</span><span class="w"> </span><span class="n">bodyMap</span><span class="p">.</span><span class="n">at</span><span class="p">(</span><span class="w"> </span><span class="s">&quot;Earth&quot;</span><span class="w"> </span><span class="p">)</span><span class="o">-&gt;</span><span class="n">getRotationalEphemeris</span><span class="p">(</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
</div>
</div>
</div>


           </div>
           <div class="articleComments">
            
           </div>
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="missionSegments.html" class="btn btn-neutral float-right" title="5.2. Mission Segments" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="index.html" class="btn btn-neutral" title="5. Basic Astrodynamics Tools" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2018, Delft University of Technology.

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'../../../',
            VERSION:'',
            LANGUAGE:'None',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true,
            SOURCELINK_SUFFIX: '.txt'
        };
    </script>
      <script type="text/javascript" src="../../../_static/documentation_options.js"></script>
      <script type="text/javascript" src="../../../_static/jquery.js"></script>
      <script type="text/javascript" src="../../../_static/underscore.js"></script>
      <script type="text/javascript" src="../../../_static/doctools.js"></script>
      <script type="text/javascript" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>

  

  
  
    <script type="text/javascript" src="../../../_static/js/theme.js"></script>
  

  
  
  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.StickyNav.enable();
      });
  </script>
  
 <script type="text/javascript">
    $(document).ready(function() {
        $(".toggle > *").hide();
        $(".toggle .header").show();
        $(".toggle .header .arrow").click(function() {
            $(this).closest('.toggle').children().not(".header").toggle(400);
            $(this).toggleClass("open");
            // $(this).html() == "More" ? $(this).html('Less') : $(this).html('More');
        });
        $(".showall").click(function() {
            $(".toggle > *").show(400);
            $(".toggle .header .arrow").addClass("open");
        });
        $(".hideall").click(function() {
            $(".toggle > *").hide(400);
            $(".toggle .header").show(400);
            $(".toggle .header .arrow").removeClass("open");
        });

        var nav_top_height = Math.round($(".wy-side-nav-search").outerHeight())+2;
        $(".wy-nav-content-wrap").prepend("<div id='announcement'><p>⚠️ This website is now mostly outdated! ⚠️</p><p>Please visit <a href='https://tudat-space.readthedocs.io/en/latest'>tudat-space.readthedocs.io</a> instead.</p></div>");
        $("#announcement").css("height", String(nav_top_height) + "px");
        $(".rst-content").css("margin-top", String(nav_top_height) + "px");
    });
</script>


</body>
</html>